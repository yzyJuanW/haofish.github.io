[{"categories":["总结"],"content":"常用模板（包括网络赛） ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:0:0","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"一、基础板子 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:1:0","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"1. 二分 整数二分. // 1 while (l \u003c r) { int mid = (l + r) \u003e\u003e 1; if (check(mid)) l = mid + 1; else r = mid; } // 2 while (l \u003c r) { int mid = (l + r + 1) \u003e\u003e 1; if (check(mid)) l = mid; else r = mid - 1; } // 常用 while (l \u003c= r) { int mid = (l + r) \u003e\u003e 1; if (check(mid)) ans = mid, l = mid + 1; else r = mid - 1; } 浮点数二分 // 通用版 while (r - l \u003e 1e-5) { double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; } // 防卡精度 for (int i = 0; i \u003c 100; ++i) { double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:1:1","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"2. 离散化 vector\u003cint\u003e vt; //二分找离散化值 inline int get_id(int x) { return lower_bound(vt.begin(), vt.end(), x) - vt.begin() + 1; } inline void erase_vt() { // 离散化后去重 sort(vt.begin(), vt.end()); vt.erase(unique(vt.begin(), vt.end()), vt.end()); } inline void id_table(int n, int *a, vector\u003cint\u003e\u0026 res) { // 打表, 注意，原数组下标要从1开始，返回离散化后的表 res.emplace_back(0); for (int i = 1; i \u003c= n; ++i) res.emplace_back(get_id(a[i])); } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:1:2","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"3. 高精 #include \u003ccstdio\u003e#include \u003ccctype\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cstring\u003e#include \u003ciostream\u003e using namespace std; typedef long long ll; /* 用前必读： 本高精采用可调压位式运算对于不同需求记得更改下面的压位代码 注意笔者只封装了 bign * int 没有封装 int * bign , 用时注意顺序 若出现 bign * x,中 x 不是常量变量或者不是变量（例如具体数字 3 4 5……） 记得把封装的与int相关的 运算符重载函数 的const和取地址符\u0026去掉，防止报错 若是爆栈请尝试开全局变量或者把数组改小即 M 改小 本代码暂时只支持 高精 + 高精 高精1 - 高精2 （高精1 \u003e 高精2） 高精 * 低精 高精 / 低精 高精 * 高精 高精 % 低精 高精 与 高精 的大小对比 高精 += 高精 高精1 -= 高精2 （高精1 \u003e 高精2） 高精 *= 低精 高精 /= 低精 高精 *= 高精 高精 %= 低精 尚未完成的功能 高精 / 高精 高精 % 高精 高精1 - 高精2 （高精1 \u003c 高精2） …… 其余请读者自己体会 */ const int w = 1e8, M = 1e4, wsize = 8;//压位8个0 const char pout[] = \"%08lld\";//记得修改 struct bign{ ll num[M]; char str[M * wsize]; int len; void clear() { memset(num, 0, sizeof num); len = 0;} /* 初始化 */ bign() : len(0) { clear(); } bign(int n); bign(ll n); bign(char str[]); bign(string str); void change(); void operator= (const int x) { *this = bign(x); } void operator= (const ll x) { *this = bign(x); } void operator= (char x[]) { *this = bign(x); } void operator= (string x) { *this = bign(x); } ll \u0026operator[] (int x) { return num[x]; } /* 输出 */ void print(); void print() const; /* 比较(未验证) */ bool operator\u003c (const bign \u0026b) const; bool operator\u003e (const bign \u0026b) const { return b \u003c *this; } bool operator\u003c= (const bign \u0026b) const { return !(b \u003c *this); } bool operator\u003e= (const bign \u0026b) const { return !(*this \u003c b); } bool operator!= (const bign \u0026b) const { return b \u003c *this || *this \u003c b; } bool operator== (const bign \u0026b) const { return !(b \u003c *this) \u0026\u0026 !(*this \u003c b); } /* 各种运算 */ bign operator+ (const bign \u0026b) const; // 高精 + 高精 bign operator* (const int \u0026b) const; // 高精 * 低精 bign operator* (const bign \u0026b); // 高精 * 高精 bign operator- (const bign \u0026b) const; // 高精 - 高精 bign operator/ (const int \u0026b) const; // 高精 / 低精 bign operator% (const int \u0026b); // 高精 % 低精 void operator+= (const bign \u0026b); // 高精 += 高精 void operator*= (const int \u0026b); // 高精 *= 低精 void operator*= (const bign \u0026b); // 高精 *= 高精 void operator-= (const bign \u0026b); // 高精 -= 高精 void operator/= (const int \u0026b); // 高精 /= 低精 void operator%= (const int \u0026b); // 高精 %= 低精 /* 输入输出重载 */ friend istream\u0026 operator\u003e\u003e (istream \u0026in, bign \u0026res) ; friend ostream\u0026 operator\u003c\u003c (ostream \u0026out, const bign \u0026res) ; }; bign::bign(int n) : len(0) { clear(); while (1) { num[++len] = n % w, n /= w; if (!n) break; } } bign::bign(ll n) : len(0) { clear(); while (1) { num[++len] = n % w, n /= w; if (!n) break; } } bign::bign(char str[]) : len(0) { clear(); int l = strlen(str) - 1; for (int i = l; i \u003e= 0; i -= wsize) { ll tmp = 0, k = 1; for (int j = 0; j \u003c wsize \u0026\u0026 i - j \u003e= 0; j++, k *= 10) { tmp += (str[i - j] - '0') * k; } num[++len] = tmp; } } bign::bign(string str) : len(0) { clear(); int l = str.size() - 1; for (int i = l; i \u003e= 0; i -= wsize) { ll tmp = 0, k = 1; for (int j = 0; j \u003c wsize \u0026\u0026 i - j \u003e= 0; j++, k *= 10) { tmp += (str[i - j] - '0') * k; } num[++len] = tmp; } } void bign::change() { int l = strlen(str) - 1; len = 0; for (int i = l; i \u003e= 0; i -= wsize) { ll tmp = 0, k = 1; for (int j = 0; j \u003c wsize \u0026\u0026 i - j \u003e= 0; j++, k *= 10) { tmp += (str[i - j] - '0') * k; } num[++len] = tmp; } } /* 输出 */ void bign::print() { printf(\"%lld\", num[len]); for (int i = len - 1; i \u003e 0; i--) printf(pout, num[i]); puts(\"\"); } void bign::print() const { printf(\"%lld\", num[len]); for (int i = len - 1; i \u003e 0; i--) printf(pout, num[i]); // puts(\"\"); } /* 比较(未验证) */ bool bign::operator\u003c (const bign \u0026b) const { if (len != b.len) return len \u003c b.len; for (int i = len; i \u003e 0; i--) { if (num[i] != b.num[i]) return num[i] \u003c b.num[i]; } return false; } /************************常用****************************/ /* 各种运算 */ bign bign::operator+ (const bign \u0026b) const { bign res = *this; if (res.len \u003c b.len) res.len = b.len; for (int i = 1; i \u003c= res.len; i++) { res.num[i] += b.num[i]; res.num[i + 1] += res.num[i] / w; res.num[i] %= w; } while (res.num[res.len + 1]) res.len++; return res; } bign bign::operator* (const int \u0026b) const { bign res; ll carry = 0; for (int i = 1; i \u003c= len; i++","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:1:3","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"4. 差分 const int M = 1e5 + 10; int dif[M], arr[M], res[M]; void change(int l, int r, int v) { // [l, r] + v dif[l] += v, dif[r + 1] -= v; } void init(int n) { dif[1] = arr[1]; for (int i = 2; i \u003c= n; ++i) dif[i] = arr[i] - arr[i - 1]; } void get_res(int n) { res[1] = dif[1]; for (int i = 2; i \u003c= n; ++i) { res[i] = dif[i] + res[i - 1]; } } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:1:4","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"5.三分 double ts(int l, int r) { double ans1 = 0x3f3f3f3f, ans2 = 0x3f3f3f3f; while (l \u003c r) { int lmid = l + (r - l) / 3; int rmid = r - (r - l) / 3; ans1 = f(lmid), ans2 = f(rmid); if (ans1 \u003c= ans2) r = rmid - 1; // 凹函数的最小值， 凸函数\u003c=反过来 else l = lmid + 1; } return min(ans1, ans2); //凸函数这里记得改成max } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:1:5","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"6. cout控制宽度和精度 #include \u003ciomanip\u003e// setw()只对其后面紧跟的输出产生作用 cout \u003c\u003c setw(8) \u003c\u003c setfill('0') \u003c\u003c 123 \u003c\u003c endl; // 00000123 cout.precision(3); // 之后的输出都置保留3位有效数字 cout.setf(ios::fixed); // 固定小数点，即之后的都保留3位小数 cout.unsetf(ios::fixed); // 取消固定小数点 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:1:6","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"7. 快读快输 inline char getc() {// 重写getchar static char buf[1 \u003c\u003c 21], *p1 = buf, *p2 = buf; return p1 == p2 \u0026\u0026 (p2 = (p1 = buf) + fread(buf, 1, 1 \u003c\u003c 21, stdin), p1 == p2) ? EOF : *p1++; } inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } //if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } void getstr(string \u0026s) { // 字符串快读 int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); //if (c == -1) exit(0); for(;c \u003e 32; c = getchar()) s.push_back(c); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:1:7","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"二、数论 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:0","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"1. gcd与lcm typedef long long ll; //最大公因数，公约数 ll gcd(ll a, ll b, ll m = 1) { while(b) m = a % b, a = b, b = m; return a; } //最小公倍数 ll lcm(ll a, ll b) { return a / gcd(a, b) * b; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:1","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"2. ex_gcd /* 通解为 x' = x * c / gcd + (b / gcd) * k y' = y * c / gcd - (a / gcd) * k */ typedef long long ll; // 扩展欧几里得算法核心函数 void exgcd(ll a, ll b, ll \u0026g, ll \u0026x, ll \u0026y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } /** * 此函数为 求解 ax + by = c * 返回 x的最小正整数解 * 返回 -1 说明无解 */ ll minx(ll a, ll b, ll c) { ll x, y, g; exgcd(a, b, g, x, y); if (c % g != 0) return -1; ll t = abs(b / g); x = (x * c / g % t + t) % t; return x == 0 ? x + t : x; // 返回最小正整数解 } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:2","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"3. 素数筛 埃式筛 const int M = 101000; int pri[M], cnt = 0; bool isp[M]; // 复杂度O(nlogn) // true 为非素数， false 为素数 void table() { isp[0] = isp[1] = true; for (int i = 2; i \u003c M; i++) { if (isp[i]) continue; pri[cnt++] = i; for (int j = i + i; j \u003c M; j += i) isp[j] = true; } } 线性筛 // 复杂度O(n) const int M = 1e5 + 10; int pri[M], cnt = 0; bool isp[M]; // true 为非素数， false 为素数 void table() { isp[0] = isp[1] = 1; for (int i = 2; i \u003c M; i++) { if (!isp[i]) pri[cnt++] = i; for (int j = 0; j \u003c cnt \u0026\u0026 i * pri[j] \u003c M; j++) { isp[i * pri[j]] = 1; if (!(i % pri[j])) break; } } } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:3","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"4. 逆元 线性法 typedef long long ll; // 时间复杂度O(n) void fny(const int \u0026n, ll *inv, const ll mod) { inv[0] = inv[1] = 1; for (ll i = 2; i \u003c= n; i++) { inv[i] =((mod - mod / i) * inv[mod % i]) % mod; } } 扩欧法 typedef long long ll; void exgcd(ll a, ll b, ll \u0026g, ll \u0026x, ll \u0026y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } // ax=1(mod m) ll inverse(ll a, ll m) {//扩展欧几里得法求逆元，返回-1代表没有逆元 ll g, x, y; exgcd(a, m, g, x, y); return g == 1 ? (x % m + m) % m : -1; } 费马小定理法 //a ^ (p - 1) = 1 (mod p), p为素数 //a ^ (p - 2) = a ^ (-1) (mod p) //a 的逆元为 a ^ (p - 2) typedef long long ll; ll pow_f(ll a, ll b, const ll mo) { ll ans = 1; a %= mo; while (b) { if (b \u0026 1) ans = (ans * a) % mo; a = (a * a) % mo; b \u003e\u003e= 1; } return ans; } ll inverse(ll a, ll m) { return pow_f(a, m - 2, m); } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:4","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"5. 快速幂 #define ll long long ll powf(ll a, ll b, const ll mod) {// 返回a^b % mod a %= mod; ll res = 1; while (b) { if (b \u0026 1) res = res * a % mod; a = a * a % mod, b \u003e\u003e= 1; } return res; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:5","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"6. 矩阵快速幂 结构体版 const ll MOD = 1e9 + 7; #define MO(x) ((x) % MOD) struct Mat { ll mat[10][10]; int n; // n * n 阶矩阵 Mat(int n = 2) : n(n) { memset(mat, 0, sizeof mat); }//记得修改 void to_one() { for (int i = 0; i \u003c n; i++) mat[i][i] = 1; } Mat operator*(const Mat a) const { Mat res; for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j++) { ll sum = 0; for (int k = 0; k \u003c n; k++) { sum += MO(this-\u003emat[i][k] * a.mat[k][j]); } res.mat[i][j] = MO(sum); } } return res; } ll *operator[](int x) { return mat[x]; } }; Mat pow_f(Mat a, ll b) { //a ^ b次幂 Mat ans; ans.to_one(); while (b) { if (b \u0026 1) ans = ans * a; a = a * a; b \u003e\u003e= 1; } return ans; } vector 重载运算符版 #define ll long long #define vi vector\u003cll\u003e #define Mat vector\u003cvi\u003e const int X = 6; const ll mod = 1e9 + 7; Mat operator* (Mat a, Mat b) { Mat res(X, vi(X, 0)); for (int i = 0; i \u003c X; ++i) for (int j = 0; j \u003c X; ++j) for (int k = 0; k \u003c X; ++k) res[i][j] = (res[i][j] + a[i][k] * b[k][j] % mod) % mod; return res; } Mat operator^ (Mat a, long long b) { Mat res(X, vi(X, 0)); for (int i = 0; i \u003c X; ++i) res[i][i] = 1; while (b) { if (b \u0026 1) res = res * a; a = a * a, b \u003e\u003e= 1; } return res; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:6","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"7. 高斯消元 普通浮点数高斯消元，洛谷模板题 // 洛谷模板题 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003cvector\u003e using namespace std; const int N = 110; const double eps = 1e-6; // 用来控制进度 // 普通的高斯消元是将矩阵转化成上三角的形式，再回带求出答案 double ans[N]; // 用来记录答案 int gauss(int n, int m, vector\u003cvector\u003cdouble\u003e\u003e \u0026a) { // n行m + 1列的增广矩阵 int r, c; // 当前行和当前列 for (r = c = 0; c \u003c m \u0026\u0026 r \u003c n; ++ c) { int maxr = r; // 记录最大 for (int i = r + 1; i \u003c n; ++i) if (abs(a[i][c]) \u003e abs(a[maxr][c])) maxr = i; // 寻找从当前行开始向下走的当前列中的绝对值最大值 if (r ^ maxr) swap(a[r], a[maxr]); // 如果不是当前行，则交换两行 if (abs(a[r][c]) \u003c eps) continue; // 如果当前行当前列的最大值为0则不作消元 for (int i = m; i \u003e= c; --i) a[r][i] /= a[r][c]; // 将当前行的从当前列开始到最后一列 for (int i = r + 1; i \u003c n; ++i) { if (abs(a[i][c]) \u003c eps) continue; // 如果改行的当前列已经是0，则不作消元 for (int j = m; j \u003e= c; --j) { // 逆向消元，可以少开一个变量 a[i][j] -= a[r][j] * a[i][c]; } } ++r; } if (r \u003c n) { // 无穷解 或者 无解 for (int i = r; i \u003c n; ++r) if (abs(a[i][n]) \u003c eps) return 0; return -1; // 无穷解 } for (int i = n - 1; ~i; --i) { // 回带 for (int j = i + 1; j \u003c n; ++j) { a[i][n] -= a[i][j] * ans[j]; } ans[i] = a[i][n]; } return 1; // 唯一解 } vector\u003cvector\u003cdouble\u003e\u003e a; int main() { int n; scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; ++i) { a.push_back({}); for (int j = 0; j \u003c= n; ++j) { double x; scanf(\"%lf\", \u0026x); a[i].push_back(x); } } if (gauss(n, n, a) == 1) { for (int i = 0; i \u003c n; ++i) printf(\"%.2f\\n\", ans[i]); } else puts(\"No Solution\"); return 0; } 浮点数高斯约旦消元法， 洛谷模板题 // 洛谷模板题 #include \u003ccstdio\u003e#include \u003ccmath\u003e#include \u003cvector\u003e using namespace std; const double eps = 1e-6; double ans[110]; // 记录答案 int gauss_j(int n, int m, vector\u003cvector\u003cdouble\u003e\u003e \u0026a) { // n行m + 1列增广矩阵 int r, c; // 当前行当前列 for (r = c = 0; c \u003c m \u0026\u0026 r \u003c n; ++c) { // int maxr = r; // 记录最大值 for (int i = r + 1; i \u003c n; ++i) if (abs(a[i][c]) \u003e abs(a[maxr][c])) maxr = i; // 寻找从当前行开始向下走的当前列中的绝对值最大值 if (maxr ^ r) swap(a[r], a[maxr]); // 交换两行 if (abs(a[r][c]) \u003c eps) continue; // 如果为当前行中的当前列的值为0 for (int i = 0; i \u003c n; ++i) { // 约旦消元 if (abs(a[i][c]) \u003c eps || i == r) continue; // 如果是当前行或者改行的当前列已经是0 for (int j = m; j \u003e= c; --j) a[i][j] -= a[i][c] / a[r][c] * a[r][j]; } ++r; } if (r \u003c n) return 0; // 无解或者无穷解 for (int i = 0; i \u003c n; ++i) ans[i] = a[i][n] / a[i][i]; // 回带 return 1; } vector\u003cvector\u003cdouble\u003e\u003e a; int main() { int n; scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; ++i) { a.push_back({}); for (int j = 0; j \u003c= n; ++j) { double x; scanf(\"%lf\", \u0026x); a[i].push_back(x); } } if (gauss_j(n, n, a) == 1) { for (int i = 0; i \u003c n; ++i) printf(\"%.2f\\n\", ans[i]); } else puts(\"No Solution\"); return 0; } 模意义下的高斯消元法，POJ - 2065 SETI // POJ - 2065 SETI #include \u003ccassert\u003e#include \u003cvector\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e using namespace std; int gcd(int a, int b) { int m; while(b) m = a % b, a = b, b = m; return a; } int lcm(int a, int b) { return a / gcd(a, b) * b; } int p, ans[310]; // 记录答案 int powf(int a, int b, const int mod, int ans = 1) { a %= mod; while (b) { if (b \u0026 1) ans = ans * a % mod; b \u003e\u003e= 1, a = a * a % mod; } return ans; } int inv(int a, int m) { return powf(a, m - 2, m); } //模意义下的高斯消元不需要用约旦的方式，因为整数不用考虑精度问题 // n 行 m + 1列的增广矩阵，从0开始 int gauss(int n, int m, vector\u003cvector\u003cint\u003e \u003e \u0026a, const int \u0026p) { // 传入模p int r, c; // 当前行和当前列 for (r = c = 0; c \u003c m \u0026\u0026 r \u003c n; ++c) { int maxr = r; // 记录最大值 for (int i = r + 1; i \u003c n; ++i) if (abs(a[i][c]) \u003e abs(a[maxr][c])) maxr = i; // 寻找当前列中从当前行开始的绝对值的最大值 if (maxr ^ r) swap(a[r], a[maxr]); // 交换两行 if (!a[r][c]) continue; // 如果为0 for (int i = r + 1; i \u003c n; ++i) { if (!a[i][c]) continue; // 如果当前列中 改行已经为0 int LCM = lcm(abs(a[i][c]), abs(a[r][c])); int x = LCM / abs(a[i][c]), y = LCM / abs(a[r][c]); // 使该行乘x，当前行乘y使得他们在当前列的数都变成同一个数 if (a[i][c] * a[r][c] \u003c 0) y = -y; // 如果有一个是负数 for (int j = c; j \u003c= m; ++j) a[i][j] = ((a[i][j] * x - a[r][j] * y) % p + p) % p; } ++r; } for (int i = r; i \u003c n; ++i) if (a[i][c]) return 0; // 无解 if (r \u003c m) return -1; // 无穷解 for (int i = m - 1; ~i; --i) { int tmp = a[i][m]; for (int j = i + 1; j \u003c m; ++j) { if (!a[i][j]) continue; tmp -= ans[j] * a[i][j]; tmp = ((tmp % p) + p) % p; } an","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:7","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"8. lucas const ll mod = 10007; ll fac[mod + 10], inv[mod + 10]; void fny(const int \u0026n, ll *inv, const ll mod) { fac[0] = fac[1] = inv[0] = inv[1] = 1; for (ll i = 2; i \u003c= n; i++) { inv[i] =((mod - mod / i) * inv[mod % i]) % mod; fac[i] = fac[i - 1] * i % mod; } } ll comb(ll n, ll m) { if (m \u003e n) return 0; return fac[n] * inv[fac[n - m] * fac[m] % mod] % mod; } ll lucas(ll n, ll m) { if (m == 0) return 1; if (n \u003c mod) return comb(n, m); return comb(n % mod, m % mod) * lucas(n / mod, m / mod) % mod; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:8","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"9. 线性基 struct LB { using ll = long long; ll d[65], cnt, num; // cnt 原序列的个数， num 基的个数 bool re; LB () : cnt(0), num(0), re(false) { memset(d, 0, sizeof d); } // 添加一个数x void add(ll x) { ++cnt; for (int i = 60; ~i \u0026\u0026 x; --i) { if ((x \u003e\u003e i) \u0026 1) { if (d[i]) x ^= d[i]; else d[i] = x, x = 0, ++num, re = 0; } } } // 询问是否能异或出x bool check(ll x) { for (int i = 60; ~i \u0026\u0026 x; --i) { if ((x \u003e\u003e i) \u0026 1) { if (d[i]) x ^= d[i]; else return true; } } return false; } ll get_max() { ll res = 0; for (int i = 60; ~i; --i) { if ((d[i] ^ res) \u003e res) res ^= d[i]; } return res; } // 求的是线性基的异或最小值，不是原序列，否则要特判是否为0 ll get_min() { for (int i = 0; i \u003c= 60; ++i) { if (d[i]) return d[i]; } } void rebuild() { for (int i = 0; i \u003c= 60; ++i) { for (int j = 0; j \u003c i; ++j) { if ((d[i] \u003e\u003e j) \u0026 1) { d[i] ^= d[j]; } } } re = true; } ll k_th(ll k) { if (!re) rebuild(); if (k == 1 \u0026\u0026 num \u003c cnt) return 0; // 如果异或得到0 if (num \u003c cnt) --k; ll res = 0; for (int i = 0; i \u003c= 60; ++i) { if (d[i]) { if (k \u0026 1) res ^= d[i]; k \u003e\u003e= 1; } } return res; } }; ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:9","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"10. CRT ll crt(ll *a, ll *b, int n) {// x % b[i] = a[i], 返回最小的x， b[i]中互质 ll mul = 1, ret = 0; for (int i = 0; i \u003c n; ++i) mul *= b[i]; for (int i = 0; i \u003c n; ++i) { ll minlcm = mul / b[i]; ll inv = inverse(minlcm, b[i]); // 求逆元 ret = (ret + minlcm * inv * a[i]) % mul; } return (ret + mul) % mul; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:10","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"11. 欧拉函数 线性O(n) void getphi() { phi[1] = 1; for (int i = 2; i \u003c M; ++i) { if (!isp[i]) pri[cnt++] = i, phi[i] = i - 1; for (int j = 0; j \u003c cnt \u0026\u0026 i * pri[j] \u003c M; ++j) { isp[i * pri[j]] = 1; if (i % pri[j] == 0) { phi[i * pri[j]] = pri[j] * phi[i]; break; } else { phi[i * pri[j]] = (pri[j] - 1) * phi[i]; } } } } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:11","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"12. 求组合数 递推 ll comb(ll n, ll m) { if (n \u003c m) return 0; ll ret = 1; for (int i = 1; i \u003c= m; ++i) ret = ret * (n - i + 1) / i; return ret; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:12","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"三、数据结构 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:0","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"1. 并查集 简便的路径压缩版 const int Max = 1e5 + 10; int fa[Max]; inline void init() { for (int i = 0; i \u003c Max; i++) fa[i] = i; } int findfa(int x) { return x == fa[x] ? x : fa[x] = findfa(fa[x]); } void Un(int a, int b) { int fa1 = findfa(a); int fa2 = findfa(b); if (fa1 != fa2) fa[fa1] = fa2; } 网络赛版 class UF { public: vector\u003cint\u003e parent; vector\u003cint\u003e size; int n; // 当前连通分量数目 int cnt; public: UF(int _n): n(_n), cnt(_n), parent(_n), size(_n, 1) { int i = 0; for (auto \u0026x : parent) x = i++; } int findset(int x) { return parent[x] == x ? x : parent[x] = findset(parent[x]); } bool unite(int x, int y) { x = findset(x); y = findset(y); if (x == y) { return false; } if (size[x] \u003c size[y]) { swap(x, y); } parent[y] = x; size[x] += size[y]; --cnt; return true; } bool conn(int x, int y) { x = findset(x); y = findset(y); return x == y; } }; ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:1","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"2. 树状数组 单点修改与区间查询 // 修改复杂度与查询复杂度O(logn) #define lb(x) ((x) \u0026 (-x)) #define ll long long const int N = 1e6 + 5, M = 2e5 + 5; ll n, m, a[N], bit[N]; // 初始化 void build(int n) { for (int i = 1; i \u003c= n; ++i) { bit[i] += a[i]; int j = lb(i) + i; if (j \u003c= n) bit[j] += bit[i]; } } // 单点修改 void update(int index, ll val) { a[index] += val; while (index \u003c= n) { bit[index] += val; index += lb(index); } } // 前缀查询 ll get(int index) { ll res = 0; while (index) { res += bit[index]; index -= lb(index); } return res; } // 区间和查询 ll get(int l, int r) { return get(r) - get(l - 1); } 区间修改，区间查询 设$d[i] = a[i] - a[i - 1]$ 则 $a[ x ] = \\sum_{i = 1}^{x}{d_i}$ 设 $sum[ x ] = \\sum_{i = 1}^{x}{a_i}$ 即 $sum[ x ] = d[1] + d[1] + d[2] + d[1] + d[2] + d[3] + …… + d[1] + ……+ d[n]$ 化简得 $sum[ x ] = \\sum_{i = 1}^{x}{d_i \\times (n - i + 1)}$ 得 $sum[ x ] = (n + 1) \\times \\sum_{i = 1}^{x}{d_i} - \\sum_{i = 1}^{x}{i \\times d_i}$ 固开两个树状数组，一个维护差分数组$d_i$，一个维护$i \\times d_i$ #define lb(x) ((x) \u0026 (-x)) #define int long long const int N = 5e3 + 5, M = 1e6 + 5; int n, m, d[M], id[M]; // 基础树状数组单点更新 void update(int i, int val, int *bit) { while (i \u003c= n) { bit[i] += val; i += lb(i); } } // 单点修改 void update(int i, int val) { update(i, val, d), update(i, val * i, id); } // 区间修改 void update(int l, int r, int val) { update(l, val, d), update(r + 1, -val, d); update(l, l * val, id), update(r + 1, (-val) * (r + 1), id); } // 前缀查询 int get(int i, int *bit) { int res = 0; while (i) res += bit[i], i -= lb(i); return res; } // 区间和查询 int get(int l, int r) { int res = get(r, d) * (r + 1) - get(r, id); res -= get(l - 1, d) * l - get(l - 1, id); return res; } 网络赛类封装版 template\u003cclass T\u003e class BIT{ #define lb(x) ((x) \u0026 (-x)) vector\u003cT\u003e sum, maxv, arr; const int inf = 0x3f3f3f3f; T getSum(int i) { T ret = 0; while (i) { ret += sum[i]; i -= lb(i); } return ret; } int n; public: BIT(int n, T *a) : sum(n + 1, 0), maxv(n + 1, -inf), arr(n + 1), n(n) { for (int i = 1; i \u003c= n; ++i) arr[i] = a[i]; for (int i = 1; i \u003c= n; ++i) { sum[i] += a[i]; //求和 maxv[i] = max(maxv[i], a[i]); //最大值 int j = i + lb(i); if (j \u003c= n) { sum[j] += sum[i]; maxv[j] = max(maxv[i], maxv[j]); } } } BIT(int n) : sum(n + 1, 0), maxv(n + 1, -inf), arr(n + 1, 0), n(n) {} void update(int indx, T val) { // 将indx下标的数加v int i = indx; T \u0026tmp = arr[indx]; tmp += val; while (i \u003c= n) { sum[i] += val; maxv[i] = arr[i]; for (int j = 1; j \u003c lb(i); j \u003c\u003c= 1) { maxv[i] = max(maxv[i], maxv[i - j]); } i += lb(i); } } T getSum(int l, int r) { return getSum(r) - getSum(l - 1); } T getMax(int l, int r) { T ret = arr[r]; while(r \u003e= l) { ret = max(arr[r], ret); for (r--; r - lb(r) \u003e= l; r -= lb(r)) ret = max(maxv[r], ret); } return ret; } T getMax(int i) { return getMax(1, i); } void clear() { fill(sum.begin(), sum.end(), 0); fill(arr.begin(), arr.end(), 0); fill(maxv.begin(), maxv.end(), -inf); } }; ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:2","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"3. 线段树 精简版 // 宏 #define ls ((node) \u003c\u003c 1) #define rs (((node) \u003c\u003c 1) | 1) // 变量 const int N = 2e5 + 5; ll seg[N \u003c\u003c 2], lazy[N \u003c\u003c 2], arr[N]; // 操作 ll op(ll a, ll b) { return a + b; } // 题意不同，函数内部不同 void push_down(int l, int r, int node) { if (!lazy[node]) return; // 这里如果0也有意义的话多开一个数组标记 int mid = (l + r) \u003e\u003e 1; lazy[ls] += lazy[node], lazy[rs] += lazy[node]; seg[ls] += (mid - l + 1) * lazy[node]; seg[rs] += (r - mid) * lazy[node]; lazy[node] = 0; } // 初始化 void build(int l, int r, int node) { if (l == r) { seg[node] = arr[l]; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls), build(mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 单点修改 void update(int indx, ll v, int l, int r, int node) { if (l == r) { // 题意不同，这里更新操作不同 seg[node] = v; return; } int mid = (l + r) \u003e\u003e 1; if (indx \u003c= mid) update(indx, v, l, mid, ls); else update(indx, v, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间修改 void update(int ql, int qr, ll v, int l, int r, int node) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) { // 题意不同，这里更新操作不同 lazy[node] += v; seg[node] += (r - l + 1) * v; return; } push_down(l, r, node); int mid = (l + r) \u003e\u003e 1; if (ql \u003c= mid) update(ql, qr, v, l, mid, ls); if (qr \u003e mid) update(ql, qr, v, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间查找 ll get(int ql, int qr, int l, int r, int node) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) return seg[node]; push_down(l, r, node); // 保证单点的情况下这句话可以注释掉 int mid = (l + r) \u003e\u003e 1; ll ret = 0; // 题意不同，初始化不同 if (ql \u003c= mid) ret = get(ql, qr, l, mid, ls); if (qr \u003e mid) ret = op(get(ql, qr, mid + 1, r, rs), ret); return ret; } 结构体版 #include \u003cbits/stdc++.h\u003eusing namespace std; const int M = 1e6; typedef long long ll; template\u003cclass T\u003e struct Tree{ #define ls(node) (node \u003c\u003c 1) #define rs(node) ((node \u003c\u003c 1) | 1) Tree(int len = 10): len(len) {} T sum[M \u003c\u003c 2], lazy[M \u003c\u003c 2], arr[M]; int len; private: void pushup(const int node) {// 写题目要求维护的代码，如求和，最大最小…… sum[node] = max(sum[ls(node)], sum[rs(node)]); } void pushdown(int l, int r, const int node) {//同pushup int mid = (l + r) \u003e\u003e 1; lazy[ls(node)] += lazy[node], lazy[rs(node)] += lazy[node]; sum[ls(node)] += (mid - l + 1) * lazy[node]; sum[rs(node)] += (r - mid) * lazy[node]; lazy[node] = 0; } void build(int l, int r, int node) { if (l == r) { sum[node] = arr[l]; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls(node)), build(mid + 1, r, rs(node)); pushup(node); } void update(int ql, int qr, T v, int l, int r, int node) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) { sum[node] += (r - l + 1) * v;//更新操作根据题目要求更改 lazy[node] += v; return; } if (lazy[node]) pushdown(l, r, node); int mid = (l + r) \u003e\u003e 1; if (ql \u003c= mid) update(ql, qr, v, l, mid, ls(node)); if (qr \u003e mid) update(ql, qr, v, mid + 1, r, rs(node)); pushup(node); } T getAsk(int ql, int qr, int l, int r, int node) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) return sum[node];//上同 if (lazy[node]) pushdown(l, r, node); T res = 0; int mid = (l + r) \u003e\u003e 1; if (ql \u003c= mid) res = getAsk(ql, qr, l, mid, ls(node)); if (qr \u003e mid) res = max(res, getAsk(ql, qr, mid + 1, r, rs(node))); return res; } public: //以下为可以，直接调用的函数 void build() { build(1, len, 1); } void update(int ql, int qr, T v) { update(ql, qr, v, 1, len, 1); } void update(int index, T v) { update(index, index, v, 1, len, 1); } T getAsk(int ql, int qr) { return getAsk(ql, qr, 1, len, 1); } void clear() { memset(arr, 0, sizeof(T) * (len + 10)); memset(sum, 0, sizeof(T) * (len \u003c\u003c 2)); memset(lazy, 0, sizeof(T) * (len \u003c\u003c 2)); } T\u0026 operator[] (int x) { return arr[x]; } }; int main(){ return 0; } 类版-网络赛 #include \u003cbits/stdc++.h\u003e using namespace std; /** * 使用说明： * 本线段树板子可用于多数 网络赛 * 需要注意的是此板子在性能方面由于三层封装，固较简洁版的线段树性能慢，但灵活性高（适合网络赛抢时间） * 使用时只需要修改 \"可修改区的上下界\" 中间的代码部分 * lazy使用结构体封装是应付在某些题目在区间修改时有两种操作，下面给的例题有示例 * vals是最终题目需要维护的东西（sum, max, min……），针对不同的操作只需修改结构体内的加法（+）操作即可 * 同时若题目需要区间修改，则直接修改区间修改部分的代码即可，单点修改同理 * 注意：区间修改针对不同的操作，lazy中的加等于（+=）也要具体根据题意修改 * 例题1：洛谷 */ /****************************可修改区上界******************************/ template\u003cclass T\u003e struct lazy{ T lazy1; lazy(T lazy1 = 0){ this-\u003elazy1 = lazy1; } void operator+= (const lazy\u003c","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:3","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"4. ST表 const int M = 1e5 + 5; int st[M][30], lg[M]; // st表预处理, 注意下标从1开始到n结束 void init(int *a, int n) { lg[0] = -1; for (int i = 1; i \u003c= n; ++i) lg[i] = lg[i \u003e\u003e 1] + 1, st[i][0] = a[i]; for (int j = 1; j \u003c= lg[n]; ++j) { int k = 1 \u003c\u003c (j - 1); for (int i = 1; i + k - 1 \u003c= n; ++i) { st[i][j] = max(st[i][j - 1], st[i + k][j - 1]); } } } // 询问 // 尽可能让l + 2^(len) - 1接近r int get(int l, int r) { int x = lg[r - l + 1]; return max(st[l][x], st[r - (1 \u003c\u003c x) + 1][x]); } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:4","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"5. 分块 const int N = 1e5 + 5, M = 500; #define ll long long ll a[N]; int belong[N]; struct blocks { int l, r; ll lazy; blocks() : lazy(0){} }b[M]; // 以下函数是基本不变的 void build(int n) { int siz = sqrt(n), cnt = n / siz; if (n % siz) ++cnt; for (int i = 1; i \u003c= cnt; ++i) { b[i].l = (i - 1) * siz + 1; b[i].r = i * siz; } b[cnt].r = n; for (int i = 1; i \u003c= n; ++i) belong[i] = (i - 1) / siz + 1; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:5","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"6. 莫队 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e using namespace std; const int M = 1e5 + 10; int n, m, block, arr[M], pos[M], ans[M], res; struct MO{ int l, r, k; MO(int l = 0, int r = 0, int k = 0) : l(l), r(r), k(k) {} }q[M]; bool cmp(MO a, MO b) { if (pos[a.l] ^ pos[b.l]) {//不在同一个块 return pos[a.l] \u003c pos[b.l]; } if (pos[a.l] \u0026 1) return a.r \u003c b.r; return b.r \u003c a.r; } void add(int x) { } void del(int x) { } void solve() { int l = 1, r = 0; for (int i = 0; i \u003c m; i++) { while (l \u003e q[i].l) add(--l); while (l \u003c q[i].l) del(l++); while (r \u003c q[i].r) add(++r); while (r \u003e q[i].r) del(r--); ans[q[i].k] = res;//res根据题目意思来 } } void init() { scanf(\"%d %d\", \u0026n, \u0026m); block = sqrt(n); for (int i = 1; i \u003c= n; i++) { scanf(\"%d\", arr + i); pos[i] = i / block; } for (int i = 0; i \u003c m; i++) { int l, r; scanf(\"%d %d\", \u0026l, \u0026r); q[i] = MO(l, r, i); } sort(q, q + m, cmp); } int main() { init(); solve(); return 0; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:6","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"7. 平衡树 fhq treap // 洛谷板子题 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003crandom\u003e#include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } using namespace std; const int N = 4e5 + 10; mt19937 rnd(233); struct treap{ int val, l, r, size, key; }fhq[N]; int root, cnt; inline void update(int now) { fhq[now].size = fhq[fhq[now].l].size + fhq[fhq[now].r].size + 1; } int new_node(int val) { fhq[++cnt] = {.val = val, .l = 0, .r = 0, .size = 1, .key = rnd()}; return cnt; } void split(int now, int val, int \u0026x, int \u0026y) { if (!now) { x = y = 0; return; } if (fhq[now].val \u003c= val) x = now, split(fhq[now].r, val, fhq[now].r, y); else y = now, split(fhq[now].l, val, x, fhq[now].l); update(now); } int merge(int x, int y) { if (!x || !y) return x | y; // 大根堆 if (fhq[x].key \u003e fhq[y].key) { //右下角 fhq[x].r = merge(fhq[x].r, y), update(x); return x; } // 左下角 fhq[y].l = merge(x, fhq[y].l), update(y); return y; } // 插入 inline void insert(int val) { int x, y; split(root, val, x, y); root = merge(merge(x, new_node(val)), y); } // 按值删除 inline void del(int val) { int x, y, z; split(root, val, x, z); split(x, val - 1, x, y); y = merge(fhq[y].l, fhq[y].r); root = merge(merge(x, y), z); } // 按值获取排名 inline int getrank(int val) { int x, y, ans; split(root, val - 1, x, y); ans = fhq[x].size + 1; root = merge(x, y); return ans; } // 按排名获取值 inline int getval(int rank) { int now = root; while (now) { if (fhq[fhq[now].l].size + 1 == rank) break; else if (fhq[fhq[now].l].size \u003e= rank) now = fhq[now].l; else rank -= fhq[fhq[now].l].size + 1, now = fhq[now].r; } return fhq[now].val; } // 求前驱，即严格比val小的最大值 inline int pre(int val) { int x, y; split(root, val - 1, x, y); int now = x; while (fhq[now].r) now = fhq[now].r; root = merge(x, y); return fhq[now].val; } // 求后继，即严格比val大的最小值 inline int nxt(int val) { int x, y; split(root, val, x, y); int now = y; while (fhq[now].l) now = fhq[now].l; root = merge(x, y); return fhq[now].val; } int main() { int t = IO(); while (t--) { int q = IO(), val = IO(); if (q == 1) insert(val); else if (q == 2) del(val); else if (q == 3) printf(\"%d\\n\", getrank(val)); else if (q == 4) printf(\"%d\\n\", getval(val)); else if (q == 5) printf(\"%d\\n\", pre(val)); else printf(\"%d\\n\", nxt(val)); } return 0; } spaly 替罪羊 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:7","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"8. 左偏树 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:8","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"9. 主席树 主席树（静态）洛谷模板题 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } using namespace std; /*************************************离散化********************************************/ // vt存放可用于查询原本的数（用离散化值），打表后用于查询离散化表（用下标） vector\u003cint\u003e vt; inline int get_id(const int \u0026x) { return lower_bound(vt.begin(), vt.end(), x) - vt.begin() + 1; } inline void erase_vt() { sort(vt.begin(), vt.end()); vt.erase(unique(vt.begin(), vt.end()), vt.end()); } // 打表, 注意，原数组下标要从1开始，返回离散化后的表大小 inline int id_table(int n, int *a, vector\u003cint\u003e \u0026res) { res.emplace_back(0); for (int i = 1; i \u003c= n; ++i) res.emplace_back(get_id(a[i])); return vt.size(); } /*************************************主席树********************************************/ const int N = 2e5 + 5; struct nodes{ int l, r, sum; nodes() : sum(0) {} }hjt[N \u003c\u003c 5]; int root[N], cnt; // 记录每个根结点的内存池编号， 内存池 int build(int l, int r) { int now = ++cnt; // 内存申请 if (l \u003c r) { int mid = (l + r) \u003e\u003e 1; hjt[now].l = build(l, mid); hjt[now].r = build(mid + 1, r); } return now; } // 插入新节点的操作 int update(int pre, int l, int r, int x) { int now = ++cnt; // 内存申请 hjt[now] = hjt[pre], ++hjt[now].sum; // 继承 if (l \u003c r) { // 寻找拼接点 int mid = (l + r) \u003e\u003e 1; if (x \u003c= mid) hjt[now].l = update(hjt[now].l, l, mid, x); // 如果x在左边，则让当前新节点的左孩子接继承后的左孩子 else hjt[now].r = update(hjt[now].r, mid + 1, r, x); // 否则同理 } return now; } // 返回第qr版本的主席树 - 第ql版本的主席树， 注意返回的是离散化后的值 int get(int ql, int qr, int l, int r, int k) { if (l == r) return l; int mid = (l + r) \u003e\u003e 1; int dif = hjt[hjt[qr].l].sum - hjt[hjt[ql].l].sum; if (k \u003c= dif) return get(hjt[ql].l, hjt[qr].l, l, mid, k); // 左孩子上 return get(hjt[ql].r, hjt[qr].r, mid + 1, r, k - dif); // 右孩子上 } /*************************************主函数********************************************/ int a[N]; int main() { int n = IO(), m = IO(); for (int i = 1; i \u003c= n; ++i) a[i] = IO(), vt.emplace_back(a[i]); erase_vt(); vector\u003cint\u003e id; int siz = id_table(n, a, id); root[0] = build(1, siz); for (int i = 1; i \u003c= n; ++i) root[i] = update(root[i - 1], 1, siz, id[i]); while (m--) { int l = IO(), r = IO(), k = IO(); printf(\"%d\\n\", vt[get(root[l - 1], root[r], 1, siz, k) - 1]); } return 0; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:9","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"10. LCA // 洛谷板子题 // 注意，尽量让结点编号从1开始 #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccctype\u003e#define ll long long inline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } using namespace std; const int maxn = 5e5 + 5, maxm = 5e5 + 5; const int INF = 0x3f3f3f3f; int head[maxn], cnt; struct edges { int to, next; void add(int t, int n) { to = t, next = n; } }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v) { edge[++cnt].add(v, head[u]); head[u] = cnt; } int fa[maxn][35], dep[maxn], lg[maxn]; /* 另一种写法 void dfs(int u, int f) { deep[u] = deep[f] + 1; fa[u][0] = f; for (int i = 1; (1 \u003c\u003c i) \u003c= deep[u]; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int\u0026 v : mp[u]) { if (v ^ f) dfs(v, u); } } int lca(int a, int b) { if (deep[a] \u003c deep[b]) swap(a, b); for (int i = 18; ~i; --i) if (deep[fa[a][i]] \u003e= deep[b]) a = fa[a][i]; if (a == b) return a; for (int i = 20; ~i; --i) { if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; } return fa[a][0]; } */ void dfs(int u, int f) { fa[u][0] = f; dep[u] = dep[f] + 1; for (int i = 1; i \u003c= lg[dep[u]]; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v ^ f) dfs(v, u); } } void init(int root, int n) { // 通过检查代码，反向51行dep[root] = -1没意义，具体细节以后填这个坑 dep[root] = lg[0] = -1; memset(head, -1, sizeof head); cnt = 0; for (int i = 1; i \u003c= n; ++i) lg[i] = lg[i \u003e\u003e 1] + 1; } int lca(int a, int b) { if (dep[a] \u003c dep[b]) swap(a, b); while (dep[a] \u003e dep[b]) a = fa[a][lg[dep[a] - dep[b]]]; if (a == b) return a; for (int i = lg[dep[a]]; ~i; --i) { if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; } return fa[a][0]; } int main() { int n = IO(), m = IO(), root = IO(); init(root, n); for (int i = 1; i \u003c n; ++i) { int u = IO(), v = IO(); add(u, v), add(v, u); } dfs(root, 0); while (m--) { int a = IO(), b = IO(); printf(\"%d\\n\", lca(a, b)); } return 0; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:10","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"11. 树链剖分 // 洛谷板子题 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ciostream\u003e#include \u003ccmath\u003e#include \u003cbitset\u003eusing namespace std; #define ll long long const int N = 1e5 + 5, M = 2e5 + 5; const int maxn = 1e5 + 5, maxm = 2e5 + 5; const int INF = 0x3f3f3f3f; int head[maxn], cnt; //初始化 void init() { memset(head, -1, sizeof head); cnt = -1; } struct edges { int to, next; void add(int t, int n) { to = t, next = n; } }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v) { edge[++cnt].add(v, head[u]); head[u] = cnt; } /*******************************树链剖分**********************************/ int fa[N], dep[N], siz[N], son[N]; void dfs1(int u, int f) { fa[u] = f, siz[u] = 1; dep[u] = dep[f] + 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == f) continue; dfs1(v, u); siz[u] += siz[v]; if (siz[v] \u003e siz[son[u]]) son[u] = v; // 找重儿子 } } int v[N]; // 点上的权值 int tim, dfn[N], top[N], w[N]; // w的下标是时间戳，对应的是相应时间戳上的点的点权 void dfs2(int u, int t) { dfn[u] = ++tim, top[u] = t; w[tim] = v[u]; if (!son[u]) return; dfs2(son[u], t); for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa[u] || v == son[u]) continue; dfs2(v, v); } } /*******************************线段树******************************/ inline int ls(const int\u0026 x) { return x \u003c\u003c 1;} inline int rs(const int\u0026 x) { return x \u003c\u003c 1 | 1;} ll seg[N \u003c\u003c 2], lazy[N \u003c\u003c 2], p; int n, m; inline ll op(const ll\u0026 a, const ll\u0026 b) { // seg[x] = max(seg[ls(x)], seg[rs(x)]); return (a + b) % p; } inline void push_down(const int\u0026 l, const int\u0026 r, const int\u0026 node) { if (!lazy[node]) return; lazy[ls(node)] += lazy[node], lazy[rs(node)] += lazy[node]; lazy[ls(node)] %= p, lazy[rs(node)] %= p; int mid = (l + r) \u003e\u003e 1; seg[ls(node)] = (lazy[node] * (mid - l + 1) + seg[ls(node)]) % p; seg[rs(node)] = (lazy[node] * (r - mid) + seg[rs(node)]) % p; lazy[node] = 0; } void build(int l, int r, int node = 1) { if (l == r) { seg[node] = w[l]; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls(node)), build(mid + 1, r, rs(node)); seg[node] = op(seg[ls(node)], seg[rs(node)]); } void update(int ql, int qr, ll x, int l = 1, int r = n, int node = 1) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) { lazy[node] = (lazy[node] + x) % p; seg[node] = (seg[node] + (r - l + 1) * x) % p; return; } push_down(l, r, node); int mid = (l + r) \u003e\u003e 1; if (ql \u003c= mid) update(ql, qr, x, l, mid, ls(node)); if (qr \u003e mid) update(ql, qr, x, mid + 1, r, rs(node)); seg[node] = op(seg[ls(node)], seg[rs(node)]); } int get(int ql, int qr, int l = 1, int r = n, int node = 1) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) return seg[node]; push_down(l, r, node); int mid = (l + r) \u003e\u003e 1, res = 0; if (ql \u003c= mid) res = get(ql, qr, l, mid, ls(node)); if (qr \u003e mid) res = op(res, get(ql, qr, mid + 1, r, rs(node))); return res; } /********************************树上操作**********************************/ void update_chain(int x, int y, ll z) { while (top[x] != top[y]) { if (dep[top[x]] \u003c dep[top[y]]) swap(x, y); update(dfn[top[x]], dfn[x], z); x = fa[top[x]]; } if (dep[x] \u003e dep[y]) swap(x, y); update(dfn[x], dfn[y], z); } ll get_chain(int x, int y) { int res = 0; while (top[x] != top[y]) { if (dep[top[x]] \u003c dep[top[y]]) swap(x, y); res = op(res, get(dfn[top[x]], dfn[x])); x = fa[top[x]]; } if (dep[x] \u003e dep[y]) swap(x, y); return op(res, get(dfn[x], dfn[y])); } void update_son(int x, ll z) { update(dfn[x], dfn[x] + siz[x] - 1, z); } ll get_son(int x) { return get(dfn[x], dfn[x] + siz[x] - 1); } /********************************主函数************************************/ int main() { std::ios::sync_with_stdio(false); cout.tie(0), cin.tie(0); init(); int root; cin \u003e\u003e n \u003e\u003e m \u003e\u003e root \u003e\u003e p; for (int i = 1; i \u003c= n; ++i) cin \u003e\u003e v[i]; for (int i = 1; i \u003c n; ++i) { int u, v; cin \u003e\u003e u \u003e\u003e v; add(u, v), add(v, u); } dfs1(root, root), dfs2(root, root); build(1, n); while (m--) { int q, x, y, z; cin \u003e\u003e q \u003e\u003e x; if (q == 1) { cin \u003e\u003e y \u003e\u003e z; update_chain(x, y, z % p); } else if (q == 2) { cin \u003e\u003e y; cout \u003c\u003c get_chain(x, y) \u003c\u003c endl; } else if (q == 3) { cin","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:11","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"四、图论 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:4:0","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"前置存图 const int N = 1e5 + 10, M = 2e5 + 10; const int INF = 0x3f3f3f3f; int head[N], cnt; //初始化 void init(int n) { fill_n(head, n + 5, -1); cnt = -1; } struct edges { int to, next; int w; void add(int t, int n, int w) { to = t, next = n, this-\u003ew = w; } }edge[N \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v, int w) { edge[++cnt].add(v, head[u], w); head[u] = cnt; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:4:1","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"1. 最短路 dijkstra //顶点数和边数 const int maxn = 1e5 + 10, maxm = 2e5 + 10; const int INF = 0x3f3f3f3f; int head[maxn], cnt, dis[maxn]; bool vis[maxn]; //初始化 void init(int n) { // n个点 fill_n(head, n + 1, -1); cnt = 0; } struct edges { int to, next; int w; edges(int to = 0, int next = -1, int w = 0) : to(to), next(next), w(w) {} }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add_edges(int u, int v, int w) { edge[++cnt] = edges(v, head[u], w); head[u] = cnt; } struct qnode{ int v; int w; qnode(int v = 0, int w = 0) : v(v), w(w) {} bool operator\u003c (const qnode \u0026t) const { return w \u003e t.w; } }; void dij(int n, int s) {//n 为顶点数， m 为边数 for (int i = 0; i \u003c= n; ++i) dis[i] = INF, vis[i] = 0; dis[s] = 0; priority_queue\u003cqnode\u003e heap; heap.push(qnode(s, dis[s])); while (heap.size()) { int u = heap.top().v; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; int w = edge[i].w; if (!vis[v] \u0026\u0026 dis[u] + w \u003c dis[v]) { //松弛 dis[v] = dis[u] + w; heap.push(qnode(v, dis[v])); } } } } bellman-ford const int maxn = 1e5 + 10, maxm = 2e5 + 10, inf = 0x3f3f3f3f; int dis[maxn]; struct edges { int u, v, w; edges(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) {} } edge[maxm]; bool bf(int n, int m, int s) { // n个点， m个边， s为起点 fill_n(dis, n + 1, inf); dis[s] = 0; for (int k = 1; k \u003c n; k++) { int ok = 1; for (int i = 1; i \u003c= m; i++) { if (dis[edge[i].v] \u003e dis[edge[i].u] + edge[i].w) { //松弛 dis[edge[i].v] = dis[edge[i].u] + edge[i].w; ok = 0; } } if (ok) break; // 小优化，无松弛操作 } for (int i = 1; i \u003c= m; i++) { if (dis[edge[i].v] \u003e dis[edge[i].u] + edge[i].w) { return false; // 有负环 } } return true;// 无负环 } spfa const int maxn = 1e5 + 10, maxm = 2e5 + 10, inf = 0x3f3f3f3f; int dis[maxn], num[maxn], head[maxn], cnt; //num 数组是判断是否有负环 bool inq[maxn]; void init(int n) { // n个点 fill_n(head, n + 5, -1); cnt = 0; } struct edges { int to, w, next; edges(int to = 0, int w = 0, int next = -1) : to(to), w(w), next(next) {} } edge[maxm]; inline void add_edges(int u, int v, int w) { edge[++cnt] = edges(v, w, head[u]); head[u] = cnt; } bool spfa(int n, int s) {// n个点， s为起点 for (int i = 0; i \u003c= n; ++i) { dis[i] = inf, num[i] = inq[i] = 0; } queue\u003cint\u003e q; q.push(s); inq[s] = num[s] = 1, dis[s] = 0; while (q.size()) { int u = q.front(); q.pop(); inq[u] = false; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to, w = edge[i].w; if (dis[v] \u003e dis[u] + w) { dis[v] = dis[u] + w; if (!inq[v]) { q.push(v); inq[v] = true, num[v]++; if (num[v] \u003e= n) return false; //如果从1号点到x的最短路中包含至少n个点（不包括自己），则存在环 } } } } return true; } floyd const int M = 2e2; int n, m; //顶点数和边数 int dis[M][M]; void floyd() { for (int k = 0; k \u003c n; k++) { for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j++) { if (dis[i][j] \u003e dis[i][k] + dis[k][j]) { dis[i][j] = dis[i][k] + dis[k][j]; } } } } } void init() { memset(dis, 0x3f, sizeof dis); for (int i = 0; i \u003c M; ++i) dis[i][i] = 0; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:4:2","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"2. 生成树 kruskal 适合稀疏图 #define ll long long using namespace std; #include \u003ccctype\u003einline long long IO() {} //省略快读 const int M = 2e5 + 10, N = 5e5 + 5; int fa[M]; struct edges { int u, v; ll w; } e[N]; bool cmp(edges\u0026 i, edges\u0026 j) { return i.w \u003c j.w; } int findset(int x) { return x == fa[x] ? x : fa[x] = findset(fa[x]); } bool un(int a, int b) { int fa1 = findset(a), fa2 = findset(b); if (fa1 == fa2) return false; fa[fa1] = fa2; return true; } ll kruskal(int n, int m) { sort(e, e + m, cmp); for (int i = 0; i \u003c= n; ++i) fa[i] = i; int cnt = 0; ll ans = 0; for (int i = 0; i \u003c m; ++i) { if (un(e[i].u, e[i].v)) { ans += e[i].w; if (++cnt == n - 1) break; } } return n - 1 == cnt ? ans : -1; } int main() { int n = IO(), m = IO(); for (int i = 0; i \u003c m; ++i) e[i].u = IO(), e[i].v = IO(), e[i].w = IO(); printf(\"%lld\\n\", kruskal(n, m)); return 0; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:4:3","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"3. tarjan ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:4:4","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"4. 网络流 Edmonds-Karp算法，速度较慢 #define ll long long #include \u003ccctype\u003einline long long IO() // 快读略 const int N = 205, M = 1e4 + 5; struct edges{ int to, next; ll cap, flow;// flow为记录当前路径流的流量，cap为容量 void add(int a, int b, ll c) { to = a, next = b; cap = c, flow = 0; } }; struct EK{ edges e[M]; const ll inf = 1e18; int head[N], cnt, n = 0, vis[N], pre[N];// vis记录是否在队内, pre记录前驱内存池编号 ll minc[N]; // 记录增广路的最小流 void init(int n) { this-\u003en = n, cnt = -1; fill_n(head, n + 1, -1); } void add(int u, int v, ll cap, int f = 1) { e[++cnt].add(v, head[u], cap); head[u] = cnt; if (f) add(v, u, 0, 0); } int bfs(int s, int t) { queue\u003cint\u003e q; for (int i = 0; i \u003c= n; ++i) vis[i] = 0, pre[i] = -1; q.push(s), vis[s] = 1, minc[s] = inf;// 初始化minc为无穷大 while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (vis[v] || e[i].cap == e[i].flow) continue; vis[v] = 1, pre[v] = i; minc[v] = min(minc[u], e[i].cap - e[i].flow);// 更新最小流 if (v == t) return 1;//找到了终点（汇点） q.push(v); } } return 0; } ll ek(int s, int t) { ll ans = 0, \u0026dif = minc[t]; while (bfs(s, t)) { ans += dif; for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { e[i].flow += dif; // 正向边flow+ e[i ^ 1].flow -= dif; // 反向边flow- } } return ans; } void clearflow() { // 清空流 for (int i = 0; i \u003c= cnt; ++i) e[i].flow = 0; } }ek; int main() { int n = IO(), m = IO(), s = IO(), t = IO(); ek.init(n); for (int i = 0; i \u003c m; ++i) { int u = IO(), v = IO(), cap = IO(); ek.add(u, v, cap); } printf(\"%lld\", ek.ek(s, t)); return 0; } dinic, 当前弧优化+多路增广优化+炸点优化(模板题),复杂度$O(n^2m)$ inline long long IO() // 快读略 const int N = 205, M = 1e4 + 5; struct edges{ int to, next; ll cap, flow;// flow为记录当前路径流的流量，cap为容量 void add(int a, int b, ll c) { to = a, next = b; cap = c, flow = 0; } }; struct Dinic { edges e[M]; const ll inf = 1e18; int head[N], cnt, n = 0, deep[N], cur[N]; void init(int n) { this-\u003en = n, cnt = -1; fill_n(head, n + 1, -1); } void add(int u, int v, ll cap, int f = 1) { e[++cnt].add(v, head[u], cap); head[u] = cnt; if (f) add(v, u, 0, 0); } // bfs求增广路，一次求出多条增广路 int bfs(int s, int t) { queue\u003cint\u003e q; fill_n(deep, n + 1, 0); deep[s] = 1, q.push(s); while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (deep[v] || e[i].cap == e[i].flow) continue; deep[v] = deep[u] + 1; q.push(v); } } return deep[t] != 0; } ll dfs(int u, int t, ll flow) { if (u == t) return flow; ll nowflow = 0; for (int i = cur[u]; ~i; i = e[i].next) { cur[u] = i;// 当前弧优化 int v = e[i].to; if (deep[v] != deep[u] + 1 || e[i].cap == e[i].flow) continue; if (ll low = dfs(v, t, min(flow - nowflow, e[i].cap - e[i].flow))) { e[i].flow += low, e[i ^ 1].flow -= low; nowflow += low;// 多路增广优化 if (nowflow == flow) break; } } if (!nowflow) deep[u] = -2;// 炸点优化 return nowflow; } ll dinic(int s, int t) { ll ans = 0; while (bfs(s, t)) { for (int i = 0; i \u003c= n; ++i) cur[i] = head[i];// 预处理，方便当前弧优化 ans += dfs(s, t, inf);// 进过多路增广优化可不用循环 } return ans; } void clearflow() { // 清空流 for (int i = 0; i \u003c= cnt; ++i) e[i].flow = 0; } }dinic; int main() { int n = IO(), m = IO(), s = IO(), t = IO(); dinic.init(n); for (int i = 0; i \u003c m; ++i) { int u = IO(), v = IO(); ll c = IO(); dinic.add(u, v, c); } printf(\"%lld\", dinic.dinic(s, t)); return 0; } 最小费用最大流，将ek算法中的bfs换成spfa inline long long IO() // 快读代码略 const int N = 410, M = 2e5 + 5; struct edges { int to, next; ll cap, cost, flow; void add(int a, int b, ll c, ll d) { to = a, next = b; cap = c, cost = d, flow = 0; } }; struct MCMF{ const ll inf = 1e15; int head[N], pre[N], cnt, n, inq[N]; ll maxflow, mincost, dist[N]; edges e[M]; void add(int u, int v, ll cap, ll cost, int f = 1) { e[++cnt].add(v, head[u], cap, cost); head[u] = cnt; if (f) add(v, u, 0, -cost, 0);// 建立反向弧，费用相反 } int spfa(int s, int t) {// 利用spaf找最小费用的路，即最短路 for (int i = 0; i \u003c= n; ++i) inq[i] = 0, dist[i] = inf, pre[i] = -1; queue\u003cint\u003e q; inq[s] = 1, q.push(s), dist[s] = 0; while (q.size()) { int u = q.front(); q.pop(); inq[u] = 0; for (int i = head[u]; ~i; i = e[i]","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:4:5","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"5. 二分图 匈牙利算法，时间复杂度$O(ev)$ int match[M]; bool vis[M]; bool dfs(int u) { for (int \u0026v : gp[u]) { if (vis[v]) continue; vis[v] = true; if (!match[v] || dfs(match[v])) { match[u] = v, match[v] = u; return true; } } return false; } // 主函数里 fill_n(match, n + 1, 0); // n是点的个数 for (int i = 1; i \u003c= n; ++i) { if (match[i]) continue; fill_n(vis, n + 1, false); dfs(i); } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:4:6","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"五、字符串 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:5:0","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"1. KMP const int M = 1e6 + 5; //普通版本 void getnext(char *x, int len, int *nxt) { int i = 0, j; j = nxt[0] = -1; while (i \u003c len) { while(j != -1 \u0026\u0026 x[i] != x[j]) j = nxt[j]; nxt[++i] = ++j; } } //略微优化版本 void getNext(char *x, int len, int *nxt) { int i = 0, j; j = nxt[0] = -1; while (i \u003c len) { while (j != -1 \u0026\u0026 x[i] != x[j]) j = nxt[j]; if (x[++i] == x[++j]) nxt[i] = nxt[j]; else nxt[i] = j; } } // y是主串 int nxt[M]; int kmpCount(char *y, int n, char *x, int m) { int i = 0, j = 0, ans = 0; getnext(x, m, nxt); while (i \u003c n) { while (j != -1 \u0026\u0026 y[i] != x[j]) j = nxt[j]; ++i, ++j; if (j \u003e= m) ++ans, j = nxt[j]; } return ans; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:5:1","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"2. 字符串Hash unsigned int DJBHash(const char *str) { unsigned int hash = 5381; while (*str) hash += (hash \u003c\u003c 5) + (*str++); return (hash \u0026 0x7fffffff); //7个f } unsigned int BKDRHash(const char *str) { unsigned int seed = 131; // 31 131 1313 13131 131313... unsigned int hash = 0; while (*str) hash = hash * seed + (*str++); return (hash \u0026 0x7fffffff); } #define ull unsigned long long ull strhash(const char *s) { ull seed = 1313, res = 0; // 31 131 1313 13131 while (*s) res = res * seed + (*s++); return res; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:5:2","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"3. 马拉车 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:5:3","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"4. exkmp void pre_exkmp(char x[], int m, int next[]) { next[0] = m; int j = 0; while (j + 1 \u003c m \u0026\u0026 x[j] == x[j + 1]) j++; next[1] = j; int k = 1; for (int i = 2; i \u003c m; i++) { int p = next[k] + k - 1; int L = next[i - k]; if (i + L \u003c p + 1) next[i] = L; else { j = max(0, p - i + 1); while (i + j \u003c m \u0026\u0026 x[i + j] == x[j]) j++; next[i] = j; k = i; } } } void exkmp(char x[], int m, char y[], int n, int next[], int extend[]) { pre_exkmp(x, m, next); int j = 0; while (j \u003c n \u0026\u0026 j \u003c m \u0026\u0026 x[j] == y[j]) j++; extend[0] = j; int k = 0; for (int i = 1; i \u003c n; i++) { int p = extend[k] + k - 1; int L = next[i - k]; if (i + L \u003c p + 1) extend[i] = L; else { j = max(0, p - i + 1); while (i + j \u003c n \u0026\u0026 j \u003c m \u0026\u0026 y[i + j] == x[j]) j++; extend[i] = j; k = i; } } } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:5:4","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"六、 计算几何 未完善 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003ccmath\u003e#include \u003cvector\u003e /** * 本板子属于半成品，有些功能并没有验证 * 函数说明： * 关于点的函数 * 点的Point(double, double) 构造函数 * + 向量加法 * - 向量减法 * == 判断两个点是否相等 * *(Point) 向量点乘 * *(double) 向量伸长(没有除法，要用除法直接乘倒数) * ^ 向量叉乘 * \u003c 点对点的比较 * double len() 向量的长度，也可以用来求两个点的距离 * Point rotate(double angle) 向量逆时针旋转angle弧度 * Point rotate(Point, double) 点让点p逆时针旋转angle弧度 * void print() 将点输出 * int init() 输入点的坐标 返回值和scanf相同 * 其他非结构体函数 * angle(Point\u0026, Point\u0026) 计算两个向量的夹角 * * 关于线的函数 * Line(Point, Point) 构造函数 * Line(Point, double) 根据一个点和一个倾斜角 0 \u003c= angle \u003c PI确定直线 （未验证） * double len() 返回线段的长度 * double point(double t) 返回距离点p向前t倍向量的点 * double angle() 返回直线的倾斜角 范围[0, PI) (未验证) * double disPointToLine(const Point\u0026) 点到这条直线的距离 * double disPointToSeg(const Point\u0026) 点到这条线段的距离（未验证） * Point getPro(const Point\u0026) 点在这条线上的投影 （未验证） * Point getSym(const Point\u0026) 点关于这条线的对称点 （未验证） * bool isOnLine(const Point\u0026) 验证该点是否在这条直线上（未验证） * bool isOnSeg(const Point\u0026) 验证该点是否在这条线段上（未验证） * Point cross(Line\u0026) 直线和这条直线的交点，前提是相交 * void print() 输出这条线段 * * 其他非结构体 * int LineAndLine(Line\u0026, Line\u0026) 直线和直线的关系 0平行 1重合 2相交 （未验证） * Point getLineInter(const Line\u0026, const Line\u0026) 求两直线的交点,必须相交才能调用 （此函数有问题） * int SegAndSeg(const Line\u0026 l1, const Line\u0026 l2) 两个线段的关系 0不相交 1非规范相交(其中一个线段的端点和另一个线段相交) 2规范相交 （未验证） * int LineAndSeg(const Line\u0026 line, const Line\u0026 seg) 直线和线段的关系，0不相交 1非规范相交 2规范相交 （未验证） * * 关于圆的函数 * Circle(Point, double) 构造函数 * Circle(Point, Point, Point) 过三点的圆 * double area() const; 返回圆的面积 * double circum() const 返回圆的周长 * int PointAndCircle(Point\u0026) 点和圆的关系 返回 0圆外 1圆上 2圆内 * int LineAndCircle(Point\u0026) 点和圆的关系 返回 0不相交 1相交 2相交两个点（未验证） * int CircleAndCircle(Circle\u0026) 圆和圆的关系 返回 0内含 1内切 2相交两点 3外切 4外离 （未验证） * * 关于三角形的函数 * Triangle(Point, Point, Point) 构造函数 * double area() const 返回三角形函数 * Circle outerCircle() 获取三角形的外接圆 * * 关于多边形的函数 * Polygon(vector\u003cPoint\u003e\u0026) 构造函数 * double circum(); 求凸包的周长 * void graham(Polygon\u0026) 求凸包 传入值为需要求出的凸包的点集 * int PointAndPolgon(Point\u0026) 判断点与多边形的关系，0外 1内 2边上 3点上 （未实现） * double minRectCover() 点集的最小矩形覆盖，自己必须是（逆时针）凸包才能调用 （未实现） * Circle minCircleCover() 点集的最小圆覆盖 */ using namespace std; const double eps = 1e-8, PI = acos(-1.0); int dcmp(double x) { if (fabs(x) \u003c eps) return 0; return x \u003e 0 ? 1 : -1; } /******************************点*******************************/ /* 除了结构体内部函数还有 angle(Point\u0026 a, Point\u0026 b) // 两个向量的夹角 */ struct Point { double x, y; Point(double x = 0, double y = 0) : x(x), y(y) {} Point operator + (const Point\u0026) const; Point operator - (const Point\u0026) const; double operator * (const Point\u0026) const; // 点乘 double operator ^ (const Point\u0026) const; // 叉乘 bool operator == (const Point\u0026) const; bool operator \u003c (const Point\u0026) const; // 排序需要 Point operator * (double); //向量伸长b倍 double len() const; // 向量的长度 Point rotate(double); // 向量逆时针旋转a弧度后 Point rotate(Point\u0026, double); // 点绕p点顺时针旋转a弧度后 void print() { printf(\"%.2f %.2f\", x, y); } int init() { return scanf(\"%lf%lf\", \u0026x, \u0026y); } }; Point Point::operator + (const Point\u0026 b) const { return Point(x + b.x, y + b.y); } Point Point::operator - (const Point\u0026 b) const { return Point(x - b.x, y - b.y); } // 点乘 double Point::operator * (const Point\u0026 b) const { return x * b.x + y * b.y; } // 叉乘 double Point::operator ^ (const Point\u0026 b) const { return x * b.y - y * b.x; } bool Point::operator == (const Point\u0026 b) const { return !dcmp(x - b.x) \u0026\u0026 !dcmp(y - b.y); } bool Point::operator \u003c (const Point\u0026 b) const { return (!dcmp(x - b.x)) ? dcmp(y - b.y) \u003c 0 : x \u003c b.x; } // 向量的长度 double Point::len() const { return sqrt(x * x + y * y); } //向量伸长b倍 Point Point::operator * (double b) { return Point(x * b, y * b); } // 向量逆时针旋转a弧度后 // cosx -sinx // sinx cosx Point Point::rotate(double a) { return Point(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a)); } // 点绕p点顺时针旋转a弧度后 Point Point::rotate(Point \u0026p, double a) { Point vec = (*this) - p; return vec.rotate(a) + p; } // 两个向量的夹角 double angle(Point\u0026 a, Point\u0026 b) { return acos(a * b / a.len() / b.len()); } /******************************线*******************************/ /* 除了结构体内部函数还有 in","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:6:0","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"七、动态规划 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:7:0","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"1. 树形dp 树的最大独立集 /* Loj 10160 每个点都有一个快乐值，子结点和父节点不能同时被选，问你最大的快乐值 dp[i][0]表示第i号结点不选时最大的快乐值 dp[i][1]表示第i号结点选时的最大的快乐值 */ #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccctype\u003e#include \u003ccstring\u003eusing namespace std; const int M = 6e3 + 5; inline int read() { int x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - 48); c = getchar(); } return f ? -x : x; } struct es{ int to, nxt; }e[M \u003c\u003c 1]; int head[M], cnt; inline void init() { memset(head, -1, sizeof head); cnt = 0; } inline void add(int u, int v) { e[++cnt] = {.to = v, .nxt = head[u]}; head[u] = cnt; } int n, h[M], vis[M], dp[M][2]; void dfs(int u) { dp[u][1] = h[u]; for (int i = head[u]; ~i; i = e[i].nxt) { int v = e[i].to; dfs(v); dp[u][0] += max(dp[v][0], dp[v][1]); dp[u][1] += dp[v][0]; } } int main() { int n = read(); for (int i = 1; i \u003c= n; ++i) h[i] = read(); int u = read(), v = read(); init(); while (u | v) { add(v, u); vis[u] = true; u = read(), v = read(); } int root = 0; for (int i = 1; i \u003c= n; ++i) { if (!vis[i]) root = i; } dfs(root); printf(\"%d\\n\", max(dp[root][0], dp[root][1])); return 0; } 树的最小支配集 /* Loj 10157 每个点都有点权，一个点可以看守连着他的边上的点，选一些点出来，使他们能够看守整颗树上所有的点 问你最小选出来的权值 dp[0][i]表示i点被选上，则其 += min({dp[0][son], dp[2][son], dp[1][son]}) dp[1][i]表示i点没被选上，但是其父亲被选上了，则其 += min(dp[0][son], dp[2][son]) dp[2][i]表示i点没被选上，但是去其中某几个儿子被选上了，注意这个比较难转移，转移方式如下 先求出所有儿子min(dp[0][son], dp[1][son])的总和，然后在递归完后选出最小是那个儿子的dp[0][son] 即dp[2][u] = min(dp[2][u], sum - min(dp[2][v], dp[0][v]) + dp[0][v]);这行 */ #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; #define ll long long #include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } const int maxn = 1e5, maxm = 1e5; const int INF = 0x3f3f3f3f; int head[maxn], cnt, dis[maxn]; //初始化 void init() { memset(head, -1, sizeof head); // memset(vis, false, sizeof vis); cnt = 0; } struct edges { int to, next; int w; edges(int to = 0, int next = -1, int w = 0) : to(to), next(next), w(w) {} }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v, int w = 0) { if (cnt == 0) init(); edge[++cnt] = edges(v, head[u], w); head[u] = cnt; } const int M = 1e4, inf = 0x3f3f3f3f; int n, m, dp[3][M], vis[M], c[M]; void dfs(int u, int fa) { dp[0][u] = c[u], dp[2][u] = inf; int sum = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; dfs (v, u); dp[0][u] += min({dp[0][v], dp[2][v], dp[1][v]}); if (fa != -1) dp[1][u] += min(dp[2][v], dp[0][v]); sum += min(dp[2][v], dp[0][v]); } for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; dp[2][u] = min(dp[2][u], sum - min(dp[2][v], dp[0][v]) + dp[0][v]); } } int main() { n = IO(); init(); for (int i = 0; i \u003c n; ++i) { int u = IO(), w = IO(), k = IO(); c[u] = w; while (k--) { int v = IO(); add(u, v), add(v, u); } } dfs(1, -1); printf(\"%d\", min(dp[0][1], dp[2][1])); return 0; } 树的最小点覆盖 /* Loj10156 每个点都能看到他所连着的边，问你选出最少的点使树上所有的边都能被看到 dp[0][i]表示不选i点的最小选择数 则其 += dp[1][son] dp[1][i]表示选i点的最小选择数，则其 += min(dp[0][son], dp[1][son]) */ #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; #define ll long long #include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } const int maxn = 1e5, maxm = 1e5; const int INF = 0x3f3f3f3f; int head[maxn], cnt, dis[maxn]; //初始化 void init() { memset(head, -1, sizeof head); // memset(vis, false, sizeof vis); cnt = 0; } struct edges { int to, next; int w; edges(int to = 0, int next = -1, int w = 0) : to(to), next(next), w(w) {} }edge[maxm \u003c\u003c 1]; ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:7:1","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"最长上升子序列 朴素动态规划 dp[N], ans = 1; for (int i = 1; i \u003c= n; ++i) { dp[i] = 1; for (int j = 1; j \u003c i; ++j) { if (a[j] \u003c a[i]) { // 严格上升用 \u003c , 否则用 \u003c= dp[i] = max(dp[i], dp[j] + 1); } } ans = max(ans, dp[i]); } 贪心 树状数组（或线段树）优化动态规划（直接优化） inline long long IO() {} using namespace std; const int N = 1e5 + 5, M = 1e6 + 5, inf = 1e9; int a[M]; unordered_map\u003cint, int\u003e mp; void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } #define lb(x) (x \u0026 (-x)) int bit[M], n; int get(int i) { int res = 0; while (i) { res = max(res, bit[i]), i -= lb(i); } return res; } void update(int i, int v, int\u0026 len) { while(i \u003c= len) { bit[i] = max(bit[i], v), i += lb(i); } } void problem() { int n = IO(); vector\u003cint\u003e arr; for (int i = 0; i \u003c n; ++i) a[i] = IO(), arr.push_back(a[i]); sort(arr.begin(), arr.end()); arr.erase(unique(arr.begin(), arr.end()), arr.end()); int cnt = 0, res = 0, len = arr.size(); for (int x : arr) mp[x] = ++cnt; for (int i = 0; i \u003c n; ++i) { int ans = get(mp[a[i]] - 1) + 1; res = max(ans, res); update(mp[a[i]], ans, len); } print(res); } int main() { int n = 1; while (n--) { problem(); } return 0; } 树状数组（或线段树）优化（将值排序，求下标的最长上升子序列） #define ll long long #define all(x) x.begin(), x.end() inline long long IO() {} using namespace std; const int N = 1e5 + 5, M = 1e6 + 5, inf = 1e9; int num[N], sum[410]; ll a[210]; void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } struct pii{ int x, indx; }p[N]; #define lb(x) (x \u0026 (-x)) int bit[N], n; int get(int i) { int res = 0; while (i) { res = max(res, bit[i]), i -= lb(i); } return res; } void update(int i, int v) { while(i \u003c= n) { bit[i] = max(bit[i], v), i += lb(i); } } void problem() { n = IO(); for (int i = 0; i \u003c n; ++i) p[i].x = IO(), p[i].indx = i + 1; sort(p, p + n, [] (pii \u0026i, pii \u0026j) { if (i.x == j.x) return i.indx \u003e j.indx; return i.x \u003c j.x; }); int res = 0; for (int i = 0; i \u003c n; ++i) { int ans = get(p[i].indx - 1) + 1; res = max(ans, res); update(p[i].indx, ans); } print(res); } int main() { int n = 1; while (n--) { problem(); } return 0; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:7:2","tags":null,"title":"我的模板","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"记录一些有用的数学公式","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"数学公式小总结 ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:0:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"质数 算术基本定理：$N = {P_1}^{k_1} \\times{P_2}^{k_2} \\times {P_3}^{k_3} \\cdots \\times {P_n}^{k_n} \\ \\ , \\ \\ P_1 \u003c P_2 \u003c P_3 \u003c \\cdots \u003c P_n$ 一个数N约数个数：$(k_1 + 1) \\times (k_2 + 1) \\times (k_3 + 1) \\times \\cdots \\times (k_n + 1)$，k是算术基本定理中的k 一个数N的所有正因数的和：$({P_1} ^ {0} + {P_1} ^ {1} + {P_1} ^ {2} \\cdots + {P_1} ^ {k_1})\\times ({P_2} ^ {0} + {P_2} ^ {1} + {P_2} ^ {2} \\cdots + {P_2} ^ {k_2}) \\times \\cdots \\times ({P_n} ^ {0} + {P_n} ^ {1} + {P_n} ^ {2} \\cdots + {P_n} ^ {k_n})$ 费马小定理：$a^{p - 1} \\equiv 1 (modp)$，p是素数 ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:1:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"gcd $gcd(a, b) = gcd(b, a % b)$ $gcd(a, b) = gcd(a, b - a)$ 由算术基本定理： 假设$N = {P_1}^{a_1} \\times{P_2}^{a_2} \\times {P_3}^{a_3} \\cdots \\times {P_n}^{a_n}$ 而$M = {P_1}^{b_1} \\times{P_2}^{b_2} \\times {P_3}^{b_3} \\cdots \\times {P_n}^{b_n}$ 则$gcd(N, M) = P_1^{min(a_1, b_1)}\\times P_2^{min(a_2, b_2)}\\times P_3^{min(a_3, b_3)}\\times \\dots \\times P_n^{min(a_n, b_n)}$ $lcm(N, M) = P_1^{max(a_1, b_1)}\\times P_2^{max(a_2, b_2)}\\times P_3^{max(a_3, b_3)}\\times \\dots \\times P_n^{max(a_n, b_n)}$ 斐波那契数列$f(1) = 1, f(2) = 1, f(3) = 2\\dots$，则$gcd(f(a), f(b)) = f(gcd(a, b))$ 由第2条性质可推广：$gcd(a_1, a_2, a_3, \\dots a_n) = gcd(a_1, a_2 - a_1, a_3 - a_2\\dots a_n - a_{n- 1})$ $gcd$具区间单调性：对于区间$l_3 \\le l_2 \\le l_1 \\le r_1 \\le r_2 \\le r_3$ $gcd(l_3, r_3)\\le gcd(l_2, r_2) \\le gcd(l_1, r_1)$ $gcd$具有区间反向包含性质：对于$gcd(l_1, r_1)$，$gcd(l_2, r_2)$，$l_1\\le l_2 \\le r_2 \\le r_1$则$gcd(l_1, r_1)$一定是$gcd(l_2, r_2)$的因子 ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:2:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"卡特兰 公式一：$f(n) = \\sum_{i = 0}^{n - 1}{f(i) \\times f(n - i - 1)}$ 公式二：$f(n) = \\frac{f(n - 1) \\times (4n - 2)}{n + 1}$ 公式三：$f(n) = \\frac{C_{2n}^{n}}{n + 1}$ 公式四：$f(n) = C_{2n}^{n} - C_{2n}^{n - 1}$ 变形：给你$n$个1和$m$个0组合$n \\ge m$，求一个组合满足前k个中1的个数不少于0的个数的方案数：$C_{n + m}^{n} - C_{n + m}^{n - 1}$ ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:3:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"组合数 通项公式：$C_{n}^{m} = \\frac{n!}{m!(n - m)!} = \\frac{n\\times(n - 1)\\times \\dots \\times (n - m + 1)}{m!}$ 递推公式：$C_{n}^{m} = C_{n - 1}^{m - 1} + C_{n - 1}^{m} = \\frac{n - m + 1}{m}\\times C_{n}^{m - 1}$ 有重复元素的全排列：有k个元素，取其中第i个元素有$n_i$个，全排列的个数：$\\frac{n!}{n_1!n_2!n_3!\\dots n_k!}$，其中$n = \\sum{n_i}$ 可重复选择的组合：有n个不同元素，每个元素可以选多次，一共选k个元素，方案数：$C_{k + n - 1}^{n - 1}$ 性质1：$C_{n + m + 1}^{m} = \\sum_{i = 0}^{m}{C_{n + i}^{i}}$ 性质2：$C_{n}^{m}\\times C_{m}^{i} = C_{n}^{i}\\times C_{n - i}^{m - i}$ 性质3：$\\sum_{i = 0}^{n}{C_{n}^{i}} = 2 ^ n$ 性质4：$\\sum_{i = 0}^{n}{C_{n}^{i}\\times x^i} = (x + 1)^n$ 性质5：$C_{n}^{0} - C_{n}^{1} + C_{n}^{2} - \\dots \\pm C_{n}^{n} = 0$ 性质6：$C_{n}^{0} + C_{n}^{2} + C_{n}^{4}+\\dots = C_{n}^{1}+C_{n}^{3}+C_{n}^{5}+\\dots = 2^{n - 1}$ 性质7：$C_{n + m}^{i} = C_{n}^{0} \\times C_{m}^{i} + C_{n}^{1} \\times C_{m}^{i - 1} \\times \\dots \\times C_{n}^{i}\\times C_{m}^{0}$ 性质8：$m \\times C_{n}^{m} = n \\times C_{n - 1}^{m - 1}$ 性质9：$\\sum_{i = 1}^{n}{C_{n}^{i}\\times i}= n \\times 2^{n - 1}$ 性质10：$\\sum_{i = 1}^{n}{C_{n}^{i}} \\times i^2 = n \\times (n + 1) \\times 2^{n - 2}$ 性质11：$\\sum_{i = 0}^{n}{(C_{n}^{i})^2} = C_{2n}^{n}$ ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:4:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"斯特林数 ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:5:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"欧拉函数 ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:6:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"概率 假设有一个整数随机变量X，则有$p(X = k) = p(X \\ge k) - p(X \u003e k)$ ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:7:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"期望 期望的线性：$E(X + Y) = E(X) + E(Y)$ 同理，如果$X_1 + X_2 = X$，则$E(X) = E(X_1) + E(X_2)$ 假如X是一个随机正整数变量，则$E(X) = \\sum_{i = 1}^{\\infty}{P(X \\ge i)}$ ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:8:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"树形dp总结 ","date":"2021-07-20","objectID":"/2021/07/%E6%A0%91%E5%BD%A2dp/:0:0","tags":["dp","树形dp"],"title":"树形dp总结","uri":"/2021/07/%E6%A0%91%E5%BD%A2dp/"},{"categories":["总结"],"content":"树形背包常用思考模型 ","date":"2021-07-20","objectID":"/2021/07/%E6%A0%91%E5%BD%A2dp/:1:0","tags":["dp","树形dp"],"title":"树形dp总结","uri":"/2021/07/%E6%A0%91%E5%BD%A2dp/"},{"categories":["总结"],"content":"模型一 首先对于每个节点我们在dfs中dp转移时可以想象成一个分组背包，每次新遍历一个子树就可以想象成一个分组背包的下一组，转移时利用之前的背包状态进行转移，如果觉得这个模型比较难理解可以看下面的模型二。 ","date":"2021-07-20","objectID":"/2021/07/%E6%A0%91%E5%BD%A2dp/:1:1","tags":["dp","树形dp"],"title":"树形dp总结","uri":"/2021/07/%E6%A0%91%E5%BD%A2dp/"},{"categories":["总结"],"content":"模型二 首先对于每次新遍历一个结点我们都可以想象成是在给这个结点拼接一颗子树如下图 模型图 解释：圆点为树的结点，三角形为一颗子树，线段为边，箭头是拼接方向。蓝色为之前计算好的状态的树，红色为即将拼接上去的一颗子树（这颗子树在dfs时计算好了所有状态） ","date":"2021-07-20","objectID":"/2021/07/%E6%A0%91%E5%BD%A2dp/:1:2","tags":["dp","树形dp"],"title":"树形dp总结","uri":"/2021/07/%E6%A0%91%E5%BD%A2dp/"},{"categories":["总结"],"content":"模型一与模型二的联系 回到模型二，我们可以把蓝色部分想象成是分组背包中的前k - 1个背包状态，红色被第k组背包，子树中的每个方案都是分组背包中的一个物品，可以结合题目进行理解 需要注意的点：当我们在转移时一定要保证状态合法，例如转移时利用到的状态必须是这个树真的有这么多个结点 ","date":"2021-07-20","objectID":"/2021/07/%E6%A0%91%E5%BD%A2dp/:1:3","tags":["dp","树形dp"],"title":"树形dp总结","uri":"/2021/07/%E6%A0%91%E5%BD%A2dp/"},{"categories":["总结"],"content":"【例题1】P3177 树上染色 思路 一道树形dp题，想了好久，最终看了题解发现是突破口不对 突破口：首先思考怎么求一条边被算过的次数，用组合数学方法思考可以想到就是这条边两个方向（定义一个左边，一个右边）的黑点个数的乘积 + 白点个数的乘积 假设左边黑点的个数是x，且其左边节点个数是size， 树的总结点个数为n，则这条边计算次数有下面的公式 $$ tot = x \\times (k - x) + (size - x) \\times (n - size - k + x) $$ 有了这个突破口就可以思考怎么dp了 首先要明白每条边必定会对最终的答案做出贡献，固我们可以这样来定义状态：$dp[u][i]$表示节点u的子树选i个黑点的最大贡献，由树形背包模型(对应博客点这里)可以得到方程，不难得出状态方程这样写 $$ dp[u][i] = max{ dp[son][j] + dp[u][i - j] + tot \\times w } $$ 值得注意的点：$i - j$可能并没有这个状态，即可能这颗树在当前转移之前并没有$i - j$个节点，有一种解决方式就是将dp值初始化为-1，若在转移时dp值变了就证明他是合法的，否则并不合法 但是这种转移经过讨论好像他的复杂度接近$O(n^3)$ 还有一种的转移方式就是 $$ dp[u][i + j] = max{ dp[son][i] + dp[u][j] + tot \\times w} $$ 这样转移的话洛谷是可以拿到100分的，这样就能保证转移时每个子树都只在他们的lca上计算一次，代码如下 int dfs(int u, int fa) { int cnt = 1; // dp[u][1] = dp[u][0] = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v ^ fa) { ll \u0026w = edge[i].w; int son = dfs(v, u); for (int k = min(m, cnt); ~k; --k) { // 还是要反过来遍历 for (int j = min(son, m); ~j; --j) { if (j + k \u003e m) continue; ll tot = j * (m - j) + (son - j) * (n - son - m + j); dp[u][j + k] = max(dp[u][j + k], dp[u][k] + dp[v][j] + tot * w); } } cnt += son; } } return cnt; } 注意到我第8行和之前的代码对应的循环都是反过来遍历的，原因也解释过了，这个是01背包中我们空间优化时利用到的转移方式用来防止转移覆盖的问题，当然还有一种不用担心转移覆盖的方式，贴上学长巨巨的代码，简单易懂 #include\u003cbits/stdc++.h\u003eusing namespace std; #define ll long long #define pii pair\u003cint,int\u003e #define pb push_back #define mp make_pair const int maxn = 2000 + 5; const int mod = 1e9 + 7; ll dp[maxn][maxn]; ll sz[maxn] , n; vector\u003cpii\u003e e[maxn]; ll tmp[maxn] , up; void dfs (int u , int fa) { sz[u] = 1; for (auto g : e[u]){ int v = g.first; ll w = g.second; if (v == fa) continue; dfs(v , u); for (int i = 0 ; i \u003c= sz[u] + sz[v]; i++) tmp[i] = dp[u][i]; for (int i = 0 ; i \u003c= min(sz[u] , up) ; i++){ for (int j = 0 ; j \u003c= min(sz[v] , up) ; j++){ if (i + j \u003e up) continue; ll val = 1ll * j * (up - j) /*黑点*/ + 1ll * (sz[v] - j) * (n - sz[v] - (up - j)); val *= w; tmp[i + j] = max (tmp[i + j] , dp[u][i] + dp[v][j] + val); } } for (int i = 0 ; i \u003c= sz[u] + sz[v] ; i++) dp[u][i] = tmp[i]; sz[u] += sz[v]; } return ; } int main() { ios::sync_with_stdio(false); cin \u003e\u003e n \u003e\u003e up; for (int i = 1 ; i \u003c n ; i++){ int x , y , z; cin \u003e\u003e x \u003e\u003e y \u003e\u003e z; e[x].pb (mp(y , z)); e[y].pb (mp(x , z)); } dfs (1 , 0); cout \u003c\u003c dp[1][up] \u003c\u003c endl; return 0; } 总结：这题是一个基础的树上背包问题，但是找到突破口很重要，不然可能怎么树上dp都不知道，解决方式：多刷题 ","date":"2021-07-20","objectID":"/2021/07/%E6%A0%91%E5%BD%A2dp/:2:0","tags":["dp","树形dp"],"title":"树形dp总结","uri":"/2021/07/%E6%A0%91%E5%BD%A2dp/"},{"categories":["总结"],"content":"【例题2】P1272 重建道路 思路 根据树上背包模型可以想到状态定义：$dp[u][i]$表示以u结点为根结点的子树生成只有i个结点的最少去掉的边数，转移方程如下： $$ dp[u][i + j] = min{ dp[u][i] + dp[son][j]} $$ 这里有一个技巧，为了防止转移时覆盖，固用一个tmp函数存起计算的状态 其余需要注意的细节看代码注释 ac代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } #define ll long long using namespace std; const int M = 2e3 + 5; const int maxn = 2e3 + 5, maxm = 2e3 + 5; const int INF = 0x3f3f3f3f; int head[maxn], cnt; //初始化 void init() { memset(head, -1, sizeof head); cnt = -1; } struct edges { int to, next; }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v) { edge[++cnt] = {.to = v, .next = head[u]}; head[u] = cnt; } int dp[M][M], siz[M], tmp[M]; int n, m; void dfs(int u, int fa) { // 初始化，根据树形背包模型，一开始的只保留一个结点去掉的边数为0， 保留0个的去掉的边数是1，即拼接上去的那条边 siz[u] = 1, dp[u][1] = 0, dp[u][0] = 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; dfs(v, u); for (int j = 1; j \u003c= siz[u] + siz[v]; ++j) tmp[j] = INF; // 用一个tmp存计算的状态，防止转移覆盖原来需要用到的dp值 for (int j = 1; j \u003c= siz[u]; ++j) { // 当前树保证必须选一个 for (int k = 0; k \u003c= siz[v]; ++k) { // 子树从0开始 tmp[j + k] = min(tmp[j + k], dp[u][j] + dp[v][k]); } } siz[u] += siz[v]; for (int j = 1; j \u003c= siz[u]; ++j) dp[u][j] = tmp[j]; } } int main() { n = IO(), m = IO(); init(); for (int i = 1; i \u003c n; ++i) { int u = IO(), v = IO(); add(u, v), add(v, u); } memset(dp, 0x3f, sizeof dp); // 所有都初始化为最大值 dfs(1, -1); int ans = dp[1][m]; for (int i = 2; i \u003c= n; ++i) if(siz[i] \u003e= m) ans = min(ans, dp[i][m] + 1); // 最终的答案不一定是在1号结点上去边， +1是因为要加上去除连接父亲结点的边 printf(\"%d\", ans); return 0; } 总结：树上背包dp的时候无论是初始化还是转移的时候都需要树上背包模型为基础来考虑 ","date":"2021-07-20","objectID":"/2021/07/%E6%A0%91%E5%BD%A2dp/:3:0","tags":["dp","树形dp"],"title":"树形dp总结","uri":"/2021/07/%E6%A0%91%E5%BD%A2dp/"},{"categories":["总结"],"content":"【例题3】P1273 有线电视网 思路 这题想了好久，唯一想到比较有用的就是假设$dp[u][j]$表示以u为根结点的子树花费j元最多可以提供多少用户，然后就没有然后了，都不知道怎么转移，看了学长巨巨的思路后发现新大陆，原来还可以利用换意的方式进行dp，即转台这样定义：$dp[u][i]$表示以u为根结点的子树提供j个用户最多能赚多少钱，这样转移又方便，最后的答案就是$dp[1][i]$中大于等于0的最大i 转移方程： $$ dp[u][i + j] = max{ dp[u][i] + dp[son][j] - w} $$ 其余细节看代码注释 ac代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } #define ll long long using namespace std; const int M = 3e3 + 5; const int maxn = 3e3 + 5, maxm = 3e3 + 5; const ll inf = 0xffffffff; int head[maxn], cnt; //初始化 inline void init() { memset(head, -1, sizeof head); cnt = -1; } struct edges { int to, next; ll w; }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v, ll w) { edge[++cnt] = {.to = v, .next = head[u], .w = w}; head[u] = cnt; } ll mon[M], sum, dp[M][M], son[M], tmp[M]; int n, m; void dfs(int u) { if (u \u003e n - m) son[u] = 1, dp[u][1] = mon[u]; // 如果是叶子节点则赚的钱就是他自己， 且叶子个数为1 dp[u][0] = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; dfs(v); for (int j = 1; j \u003c= son[u] + son[v]; ++j) tmp[j] = -inf; // 防止转移时覆盖，初始化tmp为负无穷，当然用01背包的方式逆向循环也可以 for (int j = 0; j \u003c= son[u]; ++j) { for (int k = 0; k \u003c= son[v]; ++k) { ll w = (k == 0 ? 0 : edge[i].w); // 如果子树一个叶子都不选当然不用减去子树的拼接边（回忆述树上背包模型） tmp[j + k] = max(tmp[j + k], dp[u][j] + dp[v][k] - w); } } son[u] += son[v]; for (int j = 1; j \u003c= son[u]; ++j) dp[u][j] = tmp[j]; } } int main() { n = IO(), m = IO(); init(); for (int i = 1; i \u003c= n - m; ++i) { int k = IO(); while (k--) { int a = IO(), c = IO(); add(i, a, c); } } memset(dp, 0xfe, sizeof dp); // 初始化为最小值 for (int i = n - m + 1; i \u003c= n; ++i) mon[i] = IO(); dfs(1); int ans = 0; for (int i = 1; i \u003c= m; ++i) { // printf(\"%lld\\n\", dp[1][i]); if (dp[1][i] \u003e= 0) ans = max(ans, i); // 寻找最大值i } printf(\"%d\", ans); return 0; } 总结：这题需要状态定义有点新奇，当定义状态时发现没办法转移或者是没办法存下这个状态就考虑换意一下 ","date":"2021-07-20","objectID":"/2021/07/%E6%A0%91%E5%BD%A2dp/:4:0","tags":["dp","树形dp"],"title":"树形dp总结","uri":"/2021/07/%E6%A0%91%E5%BD%A2dp/"},{"categories":["总结"],"content":"一些个人觉得在ACM中比较有用的函数和stl的用法","date":"2021-07-19","objectID":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/","tags":["STL"],"title":"ACM常用C++stl总结","uri":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"一、前言 本博客对ACM的常用的函数和c++STL做一个简单的总结， 显然善用这些函数，可以对代码做大幅度地简化 本文主要对每个头文件/函数分常用和不常用做总结 注意：本博客只是针对编程竞赛中比较常用的用法，只是浅谈（因为用来打比赛够了），想要深入同学可以移步直接看c++官方提供的详细用法 用法：自己根据目录导航到自己想看的地方 ","date":"2021-07-19","objectID":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/:0:1","tags":["STL"],"title":"ACM常用C++stl总结","uri":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"二、一些非STL的常用函数 1. cstdio头文件 1.1 scanf函数（常用） 一个输入函数 基本形式为(以输入整数int型为例)，一般传入两个参数，第一个是格式化字符串，第二个是变量引用 int a, b, c; scanf(\"%d\", \u0026a);//输入一个 scanf(\"%d%d%d\", \u0026a, \u0026b, \u0026c);//输入多个 其中需要注意的是，逗号后面的必须传入的是需要输入的变量的地址，固一般在变量名前加一个\u0026（取地址符） 由于需要传入的是地址，固我们在输入数组时也可以这样做 int arr[10010]; for (int i = 0; i \u003c 10000; ++i) scanf(\"%d\", \u0026arr[i]);//常规输入 for (int i = 0; i \u003c 10000; ++i) scanf(\"%d\", arr + i);//和上面的是同理的 当然，还有一个特别需要注意的就是输入字符串 char str[110]; scanf(\"%s\", str);//下标从0开始的字符串 scanf(\"%s\", \u0026str[1]);//下标从1开始的字符串 一些小技巧 刷题的时候可能有些新手对下面类似这种输入很头痛 3 a 7 b 8 k 100 常规的做法就是开一个char数组，将字符当初字符串输入 char q[2]; int t, n; scanf(\"%d\", t); while (t--) { scanf(\"%s%d\", q, \u0026n); } 这种做法，在某些情况下可能还需要一个getchar()函数进行辅助（例如吃掉换行符），但下面这种做法，可以发挥出强大的scanf的优势。做法就是，他怎么样，在输入是就当成自己输出时会怎么样 char q; int t, n; scanf(\"%d\\n\", \u0026t);//加个换行符 while (t--) { scanf(\"%c %d\\n\", \u0026q, \u0026n); // 加个空格和回车符 } scanf的强大还远远不止这些，例如下面这个时间输入，做题时用到的只有数字，但题目偏偏有其他字符 12:30:22 和上面的同理，我们可以这样输入 int h, m, s; scanf(\"%d:%d:%d\", \u0026h, \u0026m, \u0026s); scanf函数返回的是输入变量的个数，若是无输入，则返回-1，固我们在遇到不定组输入时，scanf可以这样 int n; while (scanf(\"%d\", \u0026n) != -1) { //循环体 } 其余细节见printf函数内容 1.2 printf函数（常用） 与scanf相对，printf是c的一个输出函数 基本形式为(以整数int型为例)，第一个参数是格式化字符串，第二个是需要输出的变量 printf(\"%d\", n);//注意，没有取地址符号 关于printf的一般形式起始和scanf差不多，下面具体要扩展的是不同类型的格式化字符串（引号里的东东）和常见的输出格式 关于不同类型的格式化字符串（常用） 类型 int float double char char * long long 字符 %d %f %lf %c %s %lld 关于不同类型的格式化字符串（不常用） 类型 unsigned int unsigned long long long double size_t 无符型8进制 无符型16进制 字符 %u %llu %Lf %zu %o %x或%X 一些需要注意的 关于long long 好像对与不同的编译器使用的是不同的，但本人用%lld很少出问题 double 如果使用printf函数输出%lf和%f都是可以的，但是scanf必须严格区分 注意long double 的%Lf是大写的 对于不用的编译器size_t对应不同的类型 如果要输出%则打%%就行了 其实以上问题用c++中的cout和cin都可以解决 关于转义字符只需要知道换行符 \\n 便可以了，需要注意的是如果要输入反斜杠或者引号只需要在符号前多加一个反斜杠便可，例如 \\\\ 常用的输出格式 输出精度，自动四舍五入（常用） double x = 3.141592653; printf(\"%.3f\\n\", x); //输出3.142 printf(\"%.5f\\n\", x); //输出3.14159 输出格式每个整数占w格，右对齐，多得补0或者空格（默认是空格）（不常用） int x = 123; printf(\"%5d\\n\", x); //输出 123，默认补空格 printf(\"%05d\\n\", x); //输出00123, 补0 1.3 sscanf函数（不常用） sscanf函数虽然不怎么常用，但其功能也是十分黑科技，此函数在刷UVA的题时用得比较多，但依然这个函数不重要，知道以下用法便好 首先要知道的是，此函数的功能时将字符串中的数字读入至自己声明变量中去，使用方式和scanf十分类似，第一个参数是需要读的字符串，第二个参数是格式化字符串，第三个参数是需要写的变量引用 char str[] = \"x:200 y:100\"; int x, y; sscanf(str, \"x:%d y:%d\", \u0026x, \u0026y); printf(\"%d %d\\n\", x, y); // 输出200 100 1.4 sprintf函数（不常用） 和sscanf同理，用法和printf十分相似，第一个参数是需要写入的字符串，第二个是参数是格式化字符串，第三个参数是需要读的变量，看下面的例子 double PI = 3.1415926; char str[100]; sprintf(str, \"PI = %.3f\", PI); printf(\"%s\", str); // 输出 PI = 3.142 1.5 gets函数（部分不常用） 此函数由于其安全性低被淘汰了（读取一行字符串，不管自己申请的char字符串空间长度够不够都会一直读，直至遇到\\n换行符，还有就是其读取至换行符\\n停止，但好像Linux和Windows的换行符是不一样的），但是这些工程上的东西关我们打比赛的什么事呢？ 之所以说部分不常用是因为有些oj不给使用该函数了（例如洛谷），但还是有很多oj网站支持的，此函数读取字符串不仅速度快，而且能读一行，还是挺有用的 使用形式，传入需要读入的字符串头指针 char str[100]; gets(str); //读入字符串下标从0开始 gets(\u0026str[1]); //下标从1开始 gets(str + 1); //下标从1开始 还有一件事，此函数若读取成功则返回读入的字符串，否则返回NULL（不定组输入有用） 1.6 fgets函数（不常用） 据说此函数比较适合替代gets函数（个人觉得如果可以用gets用也是可以的），可能由于此函数需要的参数比较多，所以许多人不怎么喜欢在做题时使用他 常见形式，第一个参数是需要读入的字符串，第二个参数是需要读入的字符串的长度，第三个参数若没有特殊（读入文件）一般写stdin char str[110]; fgets(str, 110, stdin); 此函数的返回值和gets一样 2. cstring头文件 这个头文件中其实主要知道常用的函数便可以了，其余的想什么处理字符串拼接之类的，说实话如果不卡常，使用stl中的string巨香 2.1 memset函数（常用） memset通常用来初始化数组，需要注意的是他是按字节赋值的（下面会解释），时间复杂度为$O(n)$ 常见形式，第一个参数是需要初始化的数组首地址，第二个参数是初始化字节值，第三个参数是需要初始化的字节大小 memset(arr, val, sizeof arr); 对于上面的代码，若arr的类型为int，则它将会对arr进行字节赋值，就拿此arr来说，每一个arr元素都是一个int类型的变量，即每个元素占4个字节，memset后其每个元素就会变成val val val val的二进制形式，换句话说，若val = 1，则每个元素的二进制形式就会被初始化成 00000001 00000001 00000001 00000001 ，其最终结果就是16843009而不是1 固推荐刚入手的同学可以只将val设置成0(0), -1(-1)对常见的int、long long赋值，其中括号内表示memset后每个元素的值，对于bool类型，val可以设置成0(false),非0即其他数(true) 对于memset的其他进阶操作 首先要知道0x3f = 63，0x7f = 127，0x表示16进制 int类型（long long类型同理） memset(arr, 0x3f, sizeof arr);//每个元素赋值成0x3f3f3f3f，即1061109567，通常看成int的无穷大 memset(arr, 0x7f, sizeof arr);//每个元素赋值成0x7f7f7f7f，即2139062143，通常也看成int的无穷大，但没有上一条常用，原因在于2139062143过大，再做加法时容易爆int double类型（float类型同理） memset(arr, 0, sizeof arr);//每个元素都为0 memset(arr, 0x3f, sizeof arr); //每个元素都为0.0047,由于没有用处，固没用 memset(arr, 0x7f, sizeof arr); //浮点数的正无穷大，这个有用 那么怎么对一维数组指定个数进行memset呢，如下 memset(arr, val, sizeof(type) * num)","date":"2021-07-19","objectID":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/:0:2","tags":["STL"],"title":"ACM常用C++stl总结","uri":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"三、STL 1. 一些需要提前知道的知识 1.1 迭代器 迭代器是用来访问STL中的容器的工具，初学者把它理解成指针也可以 迭代器一般是c++11前用得比较多，但c++11更新了auto的用法后，迭代器逐渐没用了起来 这里提前利用后面要说到的set容器来演示迭代器的基础使用 #include \u003ccstdio\u003e#include \u003ciostream\u003e#include \u003cset\u003eusing namespace std; int main() { set\u003cint\u003e a = {4, 2, 3, 1, 5}; for (set\u003cint\u003e::iterator it = a.begin(); it != a.end(); ++it) { cout \u003c\u003c *it \u003c\u003c ' '; } return 0; } /* 输出： 1 2 3 4 5 */ 1.2 auto 神器 利用它可以大大简化你遍历STL容器的代码量 他的机制是由编译器自行判断用户定义的变量类型，由于过于香，本文后续访问、遍历、赋值会大量使用到auto，而且不难理解 基础用法，可以将上述迭代器的代码改进一下 #include \u003ccstdio\u003e#include \u003ciostream\u003e#include \u003cset\u003eusing namespace std; int main() { set\u003cint\u003e a = {4, 2, 3, 1, 5}; for (auto it = a.begin(); it != a.end(); ++it) { cout \u003c\u003c *it \u003c\u003c ' '; } return 0; } /* 输出： 1 2 3 4 5 */ 当然对于c++11，对于容器的遍历还提供了一种更加简便的方式（前提是该容器封装了begin和end） 还是上面的set #include \u003ccstdio\u003e#include \u003ciostream\u003e#include \u003cset\u003eusing namespace std; int main() { set\u003cint\u003e a = {4, 2, 3, 1, 5}; for (auto x : a) { cout \u003c\u003c x \u003c\u003c ' '; } } /* 输出： 1 2 3 4 5 */ 1.3 Lambda函数 前言：Lambda即匿名函数，对于匿名函数可能玩python比较熟悉，当然c++也有自己的一套Lambda玩法 一般形式： [] () -\u003e return_type {} 常见用处：最常见是用在sort的函数内（sort用法详见下文algorithm），对sort进行制定如何排序 int arr[5] = {3, 4, 2, 1, 7}; sort(arr, arr + 5, [] (int a, int b) { return a \u003e b; //从大到小排序 }); 下面介绍lambda的基础（其实会上面的就够了） 直接看先代码 #include \u003ccstdio\u003eusing namespace std; int main() { int a = 0, b = 1, c = 2, d = 3, e = 4; auto func = [\u0026, a, c](int x, int \u0026y)-\u003eint { b = 5, x = 6, y = 7; return a + b + c + x + y; }; puts(\"函数运行前：\"); printf(\"a = %d\\nb = %d\\nc = %d\\nd = %d\\ne = %d\\n\", a, b, c, d, e); printf(\"func(d, e) = %d\\n\", func(d, e)); puts(\"运行前：\"); printf(\"a = %d\\nb = %d\\nc = %d\\nd = %d\\ne = %d\\n\", a, b, c, d, e); return 0; } /* 输出： 函数运行前： a = 0 b = 1 c = 2 d = 3 e = 4 func(d, e) = 20 运行后： a = 0 b = 5 c = 2 d = 3 e = 7 */ 下面解释每个符号的含义 [] 是捕捉列表，用于捕捉父级的变量 [var]表示值传递方式捕捉变量var； [=]表示值传递方式捕捉所有父作用域的变量（包括this） [\u0026var]表示引用传递捕捉变量var [\u0026]表示引用传递方式捕捉所有父作用域的变量（包括this） [this]表示值传递方式捕捉当前的this指针 [=,\u0026a,\u0026b]表示以引用传递的方式捕捉变量a和b，以值传递方式捕捉其它所有变量 [\u0026,a,this]表示以值传递的方式捕捉变量a和this，引用传递方式捕捉其它所有变量 () 是传参列表，传入的参数规则和普通函数一样，值得注意的是如果什么都不传则可以省略这个传参列表 -\u003ereturn-type 是函数的返回类型，如果无返回或让编译器自己判断则可以省略 {} 是函数体，没什么好说的 2. vector 最常用的STl容器之一，对于新手你可以把他理解成一个数组，他能使用下标访问，能在尾部$O(1)$时间插入元素，固他是动态开辟空间的 头文件为#include \u003cvector\u003e 2.1 基础声明方式 #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int main() { // 直接声明元素类型为int的vector vector\u003cint\u003e v1; // 利用构造函数声明一个长度为5的vector， vector\u003cint\u003e v2(5); // 利用构造函数声明一个长度为5，所有值为1的vector vector\u003cint\u003e v3(5, 1); // 另一种声明方式 vector\u003cint\u003e v4 = {4, 5, 6, 7}; // 也可以这样 int b[4] = {1, 2, 3, 4}; vector\u003cint\u003e v5(b + 1, b + 4); // v5元素为 2， 3， 4 return 0; } 2.2 访问方式/遍历方式 最常用的访问方式就是下标访问 int main() { vector\u003cint\u003e v = {4, 5, 6, 7}; cout \u003c\u003c v[2] \u003c\u003c endl; // 输出6 return 0; } 遍历方式一般可以直接for int main() { vector\u003cint\u003e v = {4, 5, 6, 7}; for(int i = 0; i \u003c 4; ++i) { cout \u003c\u003c v[i] \u003c\u003c ' '; } // 输出为 4 5 6 7 return 0; } 当然也可以使用迭代器，这里推荐使用c++11提供的遍历方式，缺点就是没办法只得当前元素是第几个元素，但是方便 int main() { vector\u003cint\u003e v = {4, 5, 6, 7}; for (int x : v) { // 这里将 int 换成 auto是一样的，只是auto可以自动识别变量类型罢了 cout \u003c\u003c x \u003c\u003c ' '; } // 输出为 4 5 6 7 return 0; } 2.3 push_back和pop_back函数（常用） 分别用于在vector的尾部插入元素和删除与元素的函数，基本用法如下 int main() { vector\u003cint\u003e v = {4, 5, 6, 7}; v.push_back(3); // 往尾部插入3 v.push_back(2); // 往尾部插入2 for (int x : v) cout \u003c\u003c x \u003c\u003c ' '; // 输出：4 5 6 7 3 2 cout \u003c\u003c endl; v.pop_back(); // 删除最后一个元素 for (int x : v) cout \u003c\u003c x \u003c\u003c ' '; // 输出 4 5 6 7 3 return 0; } 2.4 size函数（常用） 返回当前vector的大小（长度） int main() { vector\u003cint\u003e v = {4, 5, 6, 7}; cout \u003c\u003c v.size() \u003c\u003c endl; // 输出4 v.push_back(3); cout \u003c\u003c v.size(); // 输出5 return 0; } 2.5 clear函数（常用） 将vector清空，时间为$O(1)$ int main() { vector\u003cint\u003e v = {4, 5, 6, 7}; cout \u003c\u003c v.size() \u003c\u003c endl; // 输出4 v.clear(); // 清空 cout \u003c\u003c v.size(); // 输出0 return 0; } 2.6 empty函数（不常用） 写法为v.empty()，若该vector为空则返回true，否则返回false 2.7 front和back函数（不常用） 分别返回vector头部和尾部元素的值 很多人不知道的是，其实他返回的是引用类型，这就意味着我们是可以通过该函数修改值的 vector\u003cint\u003e v = {4, 5, 6, 7}; cout \u003c\u003c v.front() \u003c\u003c ' ' \u003c\u003c v.back() \u003c\u003c endl; // 输出为4 7 v.front() = 1; // 将头部的元素修改为1 v.back() = 2; // 将尾部的元素修改为2 cout \u003c\u003c v.front() \u003c\u003c ' ' \u003c\u003c v.back() \u003c\u003c endl; // 输出为1 2 2.8 erase函数（不常用） 删除vector内部的元素 传入需要删除的起始指针和结束指","date":"2021-07-19","objectID":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/:0:3","tags":["STL"],"title":"ACM常用C++stl总结","uri":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"四、algorithm 1. sort 最最最常用的算法函数之一 其传参有两种 第一种：传入需要排序的数组的头的位置和尾的下一个位置指针 第二种：在第一种的前提下多一个比较函数 具体看代码 bool cmp(int a, int b) { return a \u003e b; } int main() { int arr[10] = {8, 7, 4, 2, 1, 3, 9, 10, 5, 6}; // 形式一 sort(arr, arr + 10); // 排序下标范围 [0, 10) // 形式二 sort(arr + 1, arr + 9, cmp); // 排序下标范围[1, 9), 用cmp函数比较，即降序排序 // 形式三 和形式二等价，只是用来lambda表达式罢了 sort(arr + 1, arr + 9, [](int a, int b) { return a \u003e b; }); // 形式四 和形式二等价，只是用了c++封装好的函数 sort(arr + 1, arr + 9, greater\u003cint\u003e()); // 降序 // 对于vector需要传入迭代器 vector\u003cint\u003e vt(arr, arr + 10); // 赋值为arr的元素 // 和上面的其实差不多 sort(vt.begin(), vt.end()); sort(vt.begin() + 1, vt.end() - 1, cmp); sort(vt.begin(), vt.end(), [](int a, int b) { return a \u003e b; }); sort(vt.begin(), vt.end(), less\u003cint\u003e()); //升序 return 0; } abs 返回一个数的绝对值（int、long long、 double） 2. min和max 用于比较两个同类型（注意是同类型）的最小值和最大值 在c++11中还提供了多个数一起比较大小 cout \u003c\u003c max({100, 99, 10, 1000}) \u003c\u003c endl; // 1000 cout \u003c\u003c min({100, 99, 10, 1000}) \u003c\u003c endl; // 10 3. swap 用于交换两个同类型（注意是同类型）的变量 4. reserve 用来翻转指定范围的数组，传参规则和sort第一种传参形式一样 5. lower_bound 用于查找一个有序序列指定范围内的第一个大于等于给定值的位置，返回的是指针或者迭代器，即如果是数组，找不到返回范围的尾部，容器则返回end() 时间复杂度为$O(logn)$ 如果是自己定义的类型，记得重写小于符号（那还不如自己手写二分呢） vector\u003cint\u003e vt = {0,2,4,6,8,10,12}; cout \u003c\u003c *lower_bound(vt.begin(), vt.end(), 3) \u003c\u003c endl; // 4 cout \u003c\u003c *lower_bound(vt.begin(), vt.end(), 4) \u003c\u003c endl; // 4 6. upper_bound 用于查找一个有序序列指定范围内的第一个大于给定值的位置，返回的是指针或者迭代器，即如果是数组，找不到返回范围的尾部，容器则返回end() 时间复杂度为$O(logn)$ vector\u003cint\u003e vt = {0,2,4,6,8,10,12}; cout \u003c\u003c *upper_bound(vt.begin(), vt.end(), 3) \u003c\u003c endl; // 4 cout \u003c\u003c *upper_bound(vt.begin(), vt.end(), 4) \u003c\u003c endl; // 6 7. unique 用于将去除一个有序序列中指定范围内的重复元素（实际没有去除）,返回去除后的尾指针 vector\u003cint\u003e vt = {0,0,2,2,4,4,6,6,8,8,10,10,10,12,12}; int index = unique(vt.begin(), vt.end()) - vt.begin(); cout \u003c\u003c index \u003c\u003c endl; // 7 8. next_permutation 用于将序列指定范围的序列排成下一个排列 具体用法比较模板化 int arr[3] = {1, 2, 3}; do { for (int i = 0; i \u003c 3; ++i) { cout \u003c\u003c arr[i]; } cout \u003c\u003c endl; } while (next_permutation(arr, arr + 3)); /* 输出： 123 132 213 231 312 321 */ 9. nth_element 一般用于获取序列（有序无序都可以）第n小的数 用法比较奇葩 时间复杂度接近$O(n)$ int arr[10] = {8, 7, 4, 2, 1, 3, 9, 10, 5, 6}; nth_element(arr, arr + 6, arr + 10); // 让 arr + 6这个位置的数就绪，即将第7大的数放到arr[6] // 即执行完后，arr + 6位置前的数都比他小，后面的数都不低于他 for (int x : arr) { cout \u003c\u003c x \u003c\u003c ' '; } cout \u003c\u003c endl; // 输出 6 5 4 2 1 3 7 8 10 9 cout \u003c\u003c arr[6] \u003c\u003c endl; // 获取排第7即位置6的数 输出 7 10. find 暴力查找一个序列中指定范围内的某个值第一次出现的位置，返回其位置的指针，若找不到返回尾指针 时间复杂度$O(n)$ 不重要，不细说 11. random_shuffle 一个用于随机打乱给定范围的序列 传入头指针和尾指针 ","date":"2021-07-19","objectID":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/:0:4","tags":["STL"],"title":"ACM常用C++stl总结","uri":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"记录自己做题时的脑残行为","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"做题时的失误记录 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:0:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"提交前检查 提交之前人肉debug一下，最好自己造一下特殊的样例走一下 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:1:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"考虑dp的转移决策上 dp状态转移时要考虑好具体对应的决策，有时候并不是0和1的简单的两种决策 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:2:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"做图论题或者树论题数记得将邻接表初始化 记得在建边的时候要调用init函数初始化 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:3:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"注意数据范围 有时候wa可能是因为没注意到特殊的数据范围，所以要注意 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:4:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"程序比较大时，报错要从大到小排除找错误 当程序比较大的时候，报错了，可以利用注释法，先将大体的函数进行注释，最后一只缩小范围找出错误 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:5:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"思考问题的时候，当想到了一种解决办法，用纸记录关键的处理方式以免忘记 想到了一种方法不要急着码代码，先用纸记录一下关键处理方式，不然码代码的时候容易忘记 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:6:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"HDU 中 string需要string的头文件 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:7:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"状态转移时，需要滚动时，可以考虑用tmp数组复制再转移，这样就不用滚动了 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:8:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"当有查询操作时，可以优先考虑离线打表","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:9:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"数位dp总结 ","date":"2021-07-19","objectID":"/2021/07/%E6%95%B0%E4%BD%8Ddp/:0:0","tags":["dp","数位dp"],"title":"数位dp总结","uri":"/2021/07/%E6%95%B0%E4%BD%8Ddp/"},{"categories":["总结"],"content":"数位dp思考形式与套路 对于区间的询问，一般利用的是前缀和的思想来求得答案 在求解答案时，一般是从高位到低位开始对答案进行累计 求解数位dp时，更像是在求解树上的信息 某一位中在未超过限制位的信息可提前预处理出来 值得注意的 大多数时候要记录前几位设置为最高数的信息 若到了最后一位并将其设置为最高数时还需要特判 0要根据题意思考是否需要特判 允许前导0和和非允许前导0是不一样的 一般递归版的数位dp求解代码 int num[100], dp[100]; int dfs(int indx, int limit, /*参数根据题意来添加*/) { if (indx == 0) { return 1;// 根据题意来返回 } int \u0026ref = dp[indx]; if (!limit \u0026\u0026 ref != -1) return ref; int res = 0; int up = (limit ? num[indx] : 9); for (int i = 0; i \u003c= up; ++i) { // 更新res dfs(indx - 1, limit \u0026\u0026 i == up); } if (!limit) ref = res; return res; } int solve(int x) { if (!x) return 1; // 根据题意来决定返回值 int len = 0; while (x) { num[++len] = x % 10; x /= 10; } return dfs(len, 1); } int main() { memset(dp, - 1, sizeof dp); // 此行省略读入 cout \u003c\u003c solve(r) - solve(l - 1) endl; } 一般递推版的数位dp求解代码 void prework() { // 对每一位未超过最高数时的信息进行预处理 } int solve(int x) { int num[10], len = 0, res = 0; // 不同题意res初始化不同，即一般是0算不算的区别 if (!x) return 1;// 返回什么根据题意来 while (x) { // 抠每一位出来 num[++len] = x % 10; x /= 10; } int last = 0; // 记录前几位需要信息，初始化根据题意来 for (int i = len; i \u003e= 1; --i) { for (int j = 0; j \u003c num[i]; ++j) { // 注意如果题目对前导0有要求可在第一位开始从1开始再到25行处处理第一位如果是0的情况 if (/*j 和 last放在一起不符合题意*/) continue; res += // 对每一位填未超过此位的数字时的答案进行累加，一般这里利用到prework预处理出来的东西 } // 来到这一步说明此位填num[i] if (/*此位填num[i]不符合题意*/) break; last += // 更新last if (last /*符合题意*/ \u0026\u0026 i == 1) { // 更新res } } for (int i = len - 1; i \u003e= 1; --i) { // 假设不能有前导0，则枚举从次高位开始到低位 for (int j = 1; j \u003c 10; ++j) { // 枚举每一位都放1~9 res += // 更新res } } return res; } int main() { prework(); // 此行省略读入 cout \u003c\u003c solve(r) - solve(l - 1) endl; } ","date":"2021-07-19","objectID":"/2021/07/%E6%95%B0%E4%BD%8Ddp/:0:1","tags":["dp","数位dp"],"title":"数位dp总结","uri":"/2021/07/%E6%95%B0%E4%BD%8Ddp/"},{"categories":["总结"],"content":"例题 LOJ 10166 数字游戏 递归写法 /* 由于科协里最近真的很流行数字游戏，某人又命名了一种取模数，这种数字必须满足各位数字之和 为 。现在大家又要玩游戏了，指定一个整数闭区间 ，问这个区间内有多少个取模数。 */ #include \u003ciostream\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccstring\u003e#include \u003ccctype\u003e#define ll long long #define pb push_back ll IO() { ll x = 0; int f = 0, c = getchar(); while (!isdigit(c)) { if (c == '-') f = 1; c = getchar(); } while (isdigit(c)) x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + c - '0', c = getchar(); return f ? -x : x; } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } using namespace std; const int N = 1e4 + 5, M = 1 \u003c\u003c 10; const ll mod = 1e9 + 7; int num[N], n; ll dp[20][101]; ll dfs(int x, int limit, int m) { ll \u0026res = dp[x][m]; if (!limit \u0026\u0026 ~res) return res; if (x == 0) return m == 0; ll sum = 0; int up = (limit ? num[x] : 9); for (int i = 0; i \u003c= up; ++i) { sum += dfs(x - 1, limit \u0026\u0026 i == up, (m + i) % n); } if (!limit) res = sum; return sum; } ll solve(ll x) { if (!x) return 1; int len = 0; while (x) num[++len] = x % 10, x /= 10; return dfs(len, 1, 0); } void problem(ll l, ll r) { n = IO(); memset(dp, -1, sizeof dp); print(solve(r) - solve(l - 1)); puts(\"\"); } int main() { int n = 1, l, r; while (~scanf(\"%d %d\", \u0026l, \u0026r)) problem(l, r); return 0; } 递推写法 #include \u003cbits/stdc++.h\u003e#define ll long long ll IO() { ll x = 0; int f = 0; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = 1; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + c - '0'; c = getchar(); } return f ? -x : x; } using namespace std; ll dp[110][110]; int num[110], l, r, n; int f(int x) { return (x % n + n) % n; } int solve(int x) { if (!x) return 1; int len = 0; while (x) { num[++len] = x % 10; x /= 10; } int last = 0, res = 0; for (int i = len; i \u003e= 1; --i) { for (int j = 0; j \u003c num[i]; ++j) { res += dp[i - 1][f(n - last - j)]; } last = (num[i] + last) % n; if (last == 0 \u0026\u0026 i == 1) res += 1; } return res; } void problem() { dp[0][0] = 1; for (int i = 1; i \u003c= 31; ++i) { for (int j = 0; j \u003c n; ++j) { dp[i][j] = 0; for (int k = 0; k \u003c 10; ++k) { // dp[i][j] += dp[i - 1][f(j + k)]; dp[i][j] += dp[i - 1][f(j - k)]; } } } printf(\"%d\\n\", solve(r) - solve(l - 1)); } int main() { #ifndef ONLINE_JUDGE freopen(\"D:/MYCODE/vsCode-c/test.in\", \"r\", stdin); freopen(\"D:/MYCODE/vsCode-c/test.out\", \"w\", stdout); #endif // int t = 1; while (~scanf(\"%d %d %d\", \u0026l, \u0026r, \u0026n)) { problem(); } return 0; } LOJ windy数 递归写法 #include \u003ciostream\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccstring\u003e#include \u003ccctype\u003e#define ll long long #define pb push_back ll IO() { ll x = 0; int f = 0, c = getchar(); while (!isdigit(c)) { if (c == '-') f = 1; c = getchar(); } while (isdigit(c)) x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + c - '0', c = getchar(); return f ? -x : x; } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } using namespace std; const int N = 1e4 + 5, M = 1 \u003c\u003c 10; const ll mod = 1e9 + 7; int num[N], n; ll dp[20][15], len; ll dfs(int x, int limit, int last) { if (x == 0) { return 1; } ll \u0026ref = dp[x][last], sum = 0; if (!limit \u0026\u0026 ~ref) return ref; int up = (limit ? num[x] : 9); for (int i = 0; i \u003c= up; ++i) { if (abs(last - i) \u003c 2) continue; sum += dfs(x - 1, limit \u0026\u0026 up == i, last == 12 \u0026\u0026 i == 0 ? 12 : i); } if (~limit) ref = sum; return sum; } ll solve(ll x) { if (!x) return 1; len = 0; while (x) num[++len] = x % 10, x /= 10; return dfs(len, 1, 12); } void problem(ll l, ll r) { memset(dp, -1, sizeof dp); // print(solve(r)); print(solve(r) - solve(l - 1)); } int main() { #ifndef ONLINE_JUDGE freopen(\"D:/MYCODE/vsCode-c/test.in\", \"r\", stdin); freopen(\"D:/MYCODE/vsCode-c/test.out\", \"w\", stdout); #endif int n = 1, l, r; while (~scanf(\"%d %d\", \u0026l, \u0026r)) problem(l, r); return 0; } 递推写法 #include \u003ciostream\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccstring\u003e#include \u003ccctype\u003e#define ll long long #define pb push_back ll IO() { ll x = 0; int f = 0, c = getchar(); while (!isdigit(c)) { if (c == '-') f = 1; c = ge","date":"2021-07-19","objectID":"/2021/07/%E6%95%B0%E4%BD%8Ddp/:0:2","tags":["dp","数位dp"],"title":"数位dp总结","uri":"/2021/07/%E6%95%B0%E4%BD%8Ddp/"},{"categories":["总结"],"content":"网络流 ","date":"2021-05-26","objectID":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/:0:0","tags":["网络流"],"title":"网络流","uri":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"categories":["总结"],"content":"一、最大流 ","date":"2021-05-26","objectID":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/:1:0","tags":["网络流"],"title":"网络流","uri":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"categories":["总结"],"content":"Ekmonds-Karp 主要思想就是先找增广路，就是一个贪心的过程，注意这是带反悔的贪心，固要建立一个流为0的反边 时间复杂度$O(nm^2)$ bfs记录前驱的寻找增广路 因为要记录一个点的前驱，该方法一次只能找到一条增广路，具体细节看代码 #include \u003cqueue\u003ebool vis[maxn]; // 记录是否在队内 ll minc[maxn]; // 记录增广路的最小流 struct pairs { int u, i; } pre[maxn]; // 用来记录前驱结点 bool bfs(int s, int t, int n) { queue\u003cint\u003e q; for (int i = 0; i \u003c= n; ++i) vis[i] = false; q.push(s), vis[s] = true, minc[s] = inf; // 初始化minc为无穷大 while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (vis[v] || !edge[i].c) continue; vis[v] = true, pre[v] = {.u = u, .i = i}; //记录当前点的前驱点和当前点的内存池编号 minc[v] = min(minc[u], edge[i].c); // 更新最小流 if (v == t) return true; //找到了终点（汇点） q.push(v); } } return false; } EK核心代码 一直找前驱，然后减去增广路中的最小费用 ll EK(int s, int t, int n) { ll ans = 0, \u0026dif = minc[t]; // 引用到达汇点的最小费用 while (bfs(s, t, n)) { ans += dif; for (int i = t; i != s; i = pre[i].u) { edge[pre[i].i].c -= dif; // 正向边- edge[pre[i].i ^ 1].c += dif; // 反向边+ } } return ans; } 完整代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cqueue\u003eusing namespace std; #define ll long long #include \u003ccctype\u003einline long long IO() // 快读略 const int N = 205, M = 1e4 + 5; struct edges{ int to, next; ll cap, flow;// flow为记录当前路径流的流量，cap为容量 void add(int a, int b, ll c) { to = a, next = b; cap = c, flow = 0; } }; struct EK{ edges e[M]; const ll inf = 1e18; int head[N], cnt, n = 0, vis[N], pre[N];// vis记录是否在队内, pre记录前驱内存池编号 ll minc[N]; // 记录增广路的最小流 void init(int n) { this-\u003en = n, cnt = -1; fill_n(head, n + 1, -1); } void add(int u, int v, ll cap, int f = 1) { e[++cnt].add(v, head[u], cap); head[u] = cnt; if (f) add(v, u, 0, 0); } int bfs(int s, int t) { queue\u003cint\u003e q; for (int i = 0; i \u003c= n; ++i) vis[i] = 0, pre[i] = -1; q.push(s), vis[s] = 1, minc[s] = inf;// 初始化minc为无穷大 while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (vis[v] || e[i].cap == e[i].flow) continue; vis[v] = 1, pre[v] = i; minc[v] = min(minc[u], e[i].cap - e[i].flow);// 更新最小流 if (v == t) return 1;//找到了终点（汇点） q.push(v); } } return 0; } ll ek(int s, int t) { ll ans = 0, \u0026dif = minc[t]; while (bfs(s, t)) { ans += dif; for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { e[i].flow += dif; // 正向边flow+ e[i ^ 1].flow -= dif; // 反向边flow- } } return ans; } void clearflow() { for (int i = 0; i \u003c= cnt; ++i) e[i].flow = 0; } }ek; int main() { int n = IO(), m = IO(), s = IO(), t = IO(); ek.init(n); for (int i = 0; i \u003c m; ++i) { int u = IO(), v = IO(), cap = IO(); ek.add(u, v, cap); } printf(\"%lld\", ek.ek(s, t)); return 0; } ","date":"2021-05-26","objectID":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/:1:1","tags":["网络流"],"title":"网络流","uri":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"categories":["总结"],"content":"Dinic ek算法比较慢，原因在于每次只能找到一条增广路 dinic算法每次可以利用深度（bfs最近距离）找到多个增广路 复杂度$O(n^2m)$ bfs找多个增广路 利用$deep$数组记录每个点的距离源点的最近距离 #include \u003cqueue\u003eint deep[maxn], cur[maxn]; // bfs求增广路，一次求出多条增广路 bool bfs(int s, int t, int n) { queue\u003cint\u003e q; for (int i = 1; i \u003c= n; ++i) deep[i] = 0; deep[s] = 1; // 源点的深度为1 q.push(s); while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = edge[i].next) { const int \u0026v = edge[i].to; const ll \u0026c = edge[i].c; if (deep[v] || !c) continue; // 如果被遍历过，或者没有流量了 deep[v] = deep[u] + 1; q.push(v); } } return deep[t] != 0; } 递归在多个增广路上计算流 由于一次bfs能找到多条增广路，固可以用dfs对多条增广路同时计算流，这是dinic的核心 几个优化 当前弧优化：对于一条路被计算过后，后面的dfs时这条路就不会再进行对这条路进行计算了，例如$1 \\to 2 \\to 3$中当$1\\to 2$被计算过后，我们可以让$1\\to 3$这样 多路增广优化：普通的dinic一般都是一次bfs多次dfs，而利用多路增广的话就可以做到一次bfs一次dfs，做法就是记录后面的路总共的流再进行return流的总共的大小，这个优化较其他两个优秀 炸点优化：当一个点遍历完他的所有他的下一个节点，发现一条增广路都没有即nowflow = 0，则可以将这个点从图中去掉了，即deep[i] = -2 // 当前弧优化+多路增广优化+炸点优化 ll dfs(int u, int t, ll f) { if (u == t) return f; ll nowflow = 0; for (int i = cur[u]; ~i; i = edge[i].next) { cur[u] = i; // 当前弧优化 int \u0026v = edge[i].to; ll \u0026c = edge[i].c; if (deep[v] != deep[u] + 1 || !c) continue; if (ll low = dfs(v, t, min(f - nowflow, c))) { c -= low, edge[i ^ 1].c += low; nowflow += low;// 多路增广优化 if (nowflow == f) break; // 满流了 } } if (!nowflow) deep[u] = -2; // 炸点优化 return nowflow; } ll dinic(int s, int t, int n) { ll ans = 0; while (bfs(s, t, n)) { for (int i = 1; i \u003c= n; ++i) cur[i] = head[i]; // 预处理，方便当前弧优化 ans += dfs(s, t, inf); // 进过多路增广优化可不用循环 } return ans; } 完整代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cqueue\u003e#define ll long long using namespace std; #include \u003ccctype\u003einline long long IO() // 快读略 const int N = 205, M = 1e4 + 5; struct edges{ int to, next; ll cap, flow;// flow为记录当前路径流的流量，cap为容量 void add(int a, int b, ll c) { to = a, next = b; cap = c, flow = 0; } }; struct Dinic { edges e[M]; const ll inf = 1e18; int head[N], cnt, n = 0, deep[N], cur[N]; void init(int n) { this-\u003en = n, cnt = -1; fill_n(head, n + 1, -1); } void add(int u, int v, ll cap, int f = 1) { e[++cnt].add(v, head[u], cap); head[u] = cnt; if (f) add(v, u, 0, 0); } // bfs求增广路，一次求出多条增广路 int bfs(int s, int t) { queue\u003cint\u003e q; fill_n(deep, n + 1, 0); deep[s] = 1, q.push(s); while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (deep[v] || e[i].cap == e[i].flow) continue; deep[v] = deep[u] + 1; q.push(v); } } return deep[t] != 0; } ll dfs(int u, int t, ll flow) { if (u == t) return flow; ll nowflow = 0; for (int i = cur[u]; ~i; i = e[i].next) { cur[u] = i;// 当前弧优化 int v = e[i].to; if (deep[v] != deep[u] + 1 || e[i].cap == e[i].flow) continue; if (ll low = dfs(v, t, min(flow - nowflow, e[i].cap - e[i].flow))) { e[i].flow += low, e[i ^ 1].flow -= low; nowflow += low;// 多路增广优化 if (nowflow == flow) break; } } if (!nowflow) deep[u] = -2;// 炸点优化 return nowflow; } ll dinic(int s, int t) { ll ans = 0; while (bfs(s, t)) { for (int i = 0; i \u003c= n; ++i) cur[i] = head[i];// 预处理，方便当前弧优化 ans += dfs(s, t, inf);// 进过多路增广优化可不用循环 } return ans; } void clearflow() { for (int i = 0; i \u003c= cnt; ++i) e[i].flow = 0; } }dinic; int main() { int n = IO(), m = IO(), s = IO(), t = IO(); dinic.init(n); for (int i = 0; i \u003c m; ++i) { int u = IO(), v = IO(); ll c = IO(); dinic.add(u, v, c); } printf(\"%lld\", dinic.dinic(s, t)); return 0; } ","date":"2021-05-26","objectID":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/:1:2","tags":["网络流"],"title":"网络流","uri":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"categories":["总结"],"content":"二、最小费用最大流 最小费用最大流，我发现如果是普通的更改dinic会退化到比ek的复杂度还大（可能是我太菜了） 计算mcmf只要将计算最大流中寻找增广路的bfs修改成寻找最短路的就可以了（好像有个公式可以证明的） 注意：存图的反向图的边的流必须是0，同时它的费用必须是正向边的费用的相反数 ","date":"2021-05-26","objectID":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/:2:0","tags":["网络流"],"title":"网络流","uri":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"categories":["总结"],"content":"EK版 直接将ek中的bfs换成spfa就好了 完整代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cqueue\u003eusing namespace std; #define ll long long #include \u003ccctype\u003einline long long IO() // 快读代码略 const int N = 410, M = 2e5 + 5; struct edges { int to, next; ll cap, cost, flow; void add(int a, int b, ll c, ll d) { to = a, next = b; cap = c, cost = d, flow = 0; } }; struct MCMF{ const ll inf = 1e15; int head[N], pre[N], cnt, n, inq[N]; ll maxflow, mincost, dist[N]; edges e[M]; void add(int u, int v, ll cap, ll cost, int f = 1) { e[++cnt].add(v, head[u], cap, cost); head[u] = cnt; if (f) add(v, u, 0, -cost, 0);// 建立反向弧，费用相反 } int spfa(int s, int t) {// 利用spaf找最小费用的路，即最短路 for (int i = 0; i \u003c= n; ++i) inq[i] = 0, dist[i] = inf, pre[i] = -1; queue\u003cint\u003e q; inq[s] = 1, q.push(s), dist[s] = 0; while (q.size()) { int u = q.front(); q.pop(); inq[u] = 0; for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; ll \u0026cost = e[i].cost; if (dist[v] \u003e dist[u] + cost \u0026\u0026 e[i].cap \u003e e[i].flow) { dist[v] = dist[u] + cost; pre[v] = i;//记录当前点的前驱的内存池编号 if (inq[v]) continue; inq[v] = 1 , q.push(v); } } } return pre[t] != -1;// 如果说t没有前驱则说明找不到增广路了 } void mcmf(int s, int t) { maxflow = mincost = 0; while (spfa(s, t)) { ll low = inf; for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { low = min(low, e[i].cap - e[i].flow);//寻找最小流 } for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { e[i].flow += low; e[i ^ 1].flow -= low; mincost += low * e[i].cost; } maxflow += low; } } void init(int n) { cnt = -1, this-\u003en = n; fill_n(head, n + 1, -1); } void clearflow() { for (int i = 0; i \u003c= cnt; ++i) e[i].flow = 0; } }mcmf; int main() { int n = IO(), m = IO(); mcmf.init(n); for (int i = 0; i \u003c m; ++i) { int u = IO(), v = IO(); ll cap = IO(), cost = IO(); mcmf.add(u, v, cap, cost); } mcmf.mcmf(1, n); printf(\"%lld %lld\", mcmf.maxflow, mcmf.mincost); return 0; } ","date":"2021-05-26","objectID":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/:2:1","tags":["网络流"],"title":"网络流","uri":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"categories":["总结"],"content":"dsu 树上启发式合并 刷题 ","date":"2021-05-12","objectID":"/2021/05/dsu%E5%88%B7%E9%A2%98/:0:0","tags":["dsu"],"title":"树上dsu总结","uri":"/2021/05/dsu%E5%88%B7%E9%A2%98/"},{"categories":["总结"],"content":"套路代码 int son[M], dep[M], siz[M]; // son记录重儿子 // 寻找重儿子 void dfs(int u, int fa) { siz[u] = 1; dep[u] = dep[fa] + 1; // 记录深度，有些题不需要 for (/*遍历下一个结点*/) { v = /*下一个结点*/; if (v == fa) continue; dfs(v, u); siz[u] += siz[v]; if (siz[v] \u003e siz[son[u]]) son[u] = v; } } int flag; void cal(int u, int fa, int k) { // 计算 // 遍历孩子，并利用 flag 避开重儿子 } void dsu(int u, int fa, int keep) { for (/*遍历下一个结点*/) { v = /*下一个结点*/; if (v != fa \u0026\u0026 v != son[u]) dfs(v, u, 0); } if (son[u]) dfs(son[u], u, 1), flag = son[u]; // 如果存在重儿子 cal(u, fa, 1); // 计算 if (flag) flag = 0; if (!keep) cal(u, fa, -1); //删除 } ","date":"2021-05-12","objectID":"/2021/05/dsu%E5%88%B7%E9%A2%98/:1:0","tags":["dsu"],"title":"树上dsu总结","uri":"/2021/05/dsu%E5%88%B7%E9%A2%98/"},{"categories":["总结"],"content":"例题 ","date":"2021-05-12","objectID":"/2021/05/dsu%E5%88%B7%E9%A2%98/:2:0","tags":["dsu"],"title":"树上dsu总结","uri":"/2021/05/dsu%E5%88%B7%E9%A2%98/"},{"categories":["总结"],"content":"CF570D Tree Requests /* 题意： 有一棵 个结点的以 11 号结点为根的有根树。 每个结点都有一个颜色，颜色是以编号表示的，ii 号结点的颜色编号为 cici 如果一种颜色在以 xx 为根的子树内出现次数最多，称其在以 xx 为根的子树中占主导地位。 显然，同一子树中可能有多种颜色占主导地位。 你的任务是对于每一个 i∈[1,n]i∈[1,n]，求出以 ii 为根的子树中，占主导地位的颜色的编号和。 N\u003c=105,ci\u003c=n */ #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#define ll long long #define rep(u, v, e) for (int i = head[u], v = e[i].to; ~i; i = e[i].next, v = e[i].to) using namespace std; const int N = 1e5 + 5, M = 2e5 + 5; int head[N], cnt; //初始化 void init() { memset(head, -1, sizeof head); cnt = -1; } struct edges { int to, next; int w; void add(int t, int n, int w) { to = t, next = n, this-\u003ew = w; } }edge[N \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v, int w = 1) { edge[++cnt].add(v, head[u], w); head[u] = cnt; } int son[N], siz[N]; void dfs(int u, int fa) { siz[u] = 1; rep(u, v, edge) { if (v == fa) continue; dfs(v, u); siz[u] += siz[v]; if (siz[v] \u003e siz[son[u]]) son[u] = v; } } ll col[N], ans[N], flag, num[N], now, sum, tot; void cal(int u, int fa, int k) { num[col[u]] += k; if (k \u003e 0) { if (num[col[u]] == tot) sum += col[u]; else if (num[col[u]] \u003e tot) tot = num[col[u]], sum = col[u]; } rep(u, v, edge) { if (v == fa || v == flag) continue; cal(v, u, k); } } void dsu(int u, int fa, int keep) { rep(u, v, edge) { if (v == fa || v == son[u]) continue; dsu(v, u, 0); } if (son[u]) dsu(son[u], u, 1), flag = son[u]; now = u; cal(u, fa, 1); ans[u] = sum; if (flag) flag = 0; if (!keep) cal(u, fa, -1), tot = 0; } int main() { int n; scanf(\"%d\", \u0026n); init(); for (int i = 1; i \u003c= n; ++i) scanf(\"%lld\", col + i); for (int i = 1; i \u003c n; ++i) { int u, v; scanf(\"%d %d\", \u0026u, \u0026v); add(u, v), add(v, u); } dfs(1, 0); dsu(1, 0, 1); for (int i = 1; i \u003c= n; ++i) printf(\"%lld \", ans[i]); return 0; } 反思：本题第二次做，sum值必须要开全局且是单值，而不是数组（即记录每个节点的答案），而是如代码所示的做法，直接用ans在dsu内复制，用sum值不开数组开全局的好处就是会一直保留重儿子的信息‘ ","date":"2021-05-12","objectID":"/2021/05/dsu%E5%88%B7%E9%A2%98/:2:1","tags":["dsu"],"title":"树上dsu总结","uri":"/2021/05/dsu%E5%88%B7%E9%A2%98/"},{"categories":["总结"],"content":"CF570D Tree Requests /* 给定一个以1为根的n个节点的树，每个点上有一个字母(a−z) 每个点的深度定义为该节点到1号节点路径上的点数. 每次询问 a,b， 查询以 a 为根的子树内深度为 b 的节点上的字母重新排列之后是否能构成回文串. */ ","date":"2021-05-12","objectID":"/2021/05/dsu%E5%88%B7%E9%A2%98/:2:2","tags":["dsu"],"title":"树上dsu总结","uri":"/2021/05/dsu%E5%88%B7%E9%A2%98/"},{"categories":["总结"],"content":"背包问题总结 本文从dp总结中搬出 背包问题是一类非常经典的动规问题，包括了01背包、完全背包、多重背包、混合背包、二维费用背包、分组背包、有依赖的背包问题、背包问题求方案数、背包问题求具体方案（称为背包九讲） 本片博客会在个人觉得比较重要的地方上啰嗦qwq ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:0:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"01背包 最最经典的背包问题，背包九讲中说到：“它包含了背包问题中设计状态、方程的最基本思想。另外，别的类型的背包问题往往也可以转换成01 背包问题求解。”，固01背包的模型是非常重要的 下面的01背包会展示三种空间的优化手段，我发现这三种优化手段都是非常重要的，针对不同场景三种手段各有优势 直接看到最原汁原味的题 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:1:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题1】AcWing 2. 01背包问题 题意不多说，就是原汁原味的01背包题，值得说的是以下内容均以V为容量，W为价值，c为背包总容量 分析1: 对于每个物品有选和不选的两种决策，固我们可以从dfs的角度加上记忆化来思考这道题 可以考虑每一层都代表一个物品，有选和不选两种方案，意味着有两个递归下去的道路 其余细节具体看代码 //调用时直接调用dfs(n, m)就好了 int dfs(int nums, int sum) {//第nums个物品，还剩下sum的容量， if (nums == n + 1) return 0; // 边界 if (vis[nums][sum]) return dp[nums][sum]; // 记忆化 vis[nums][sum] = true; int \u0026ans = dp[nums][sum]; ans = dfs(nums + 1, sum); //不选当前的物品，则容量依旧还剩sum if (sum \u003e= v[nums]) ans = max(ans, dfs(nums + 1, sum - v[nums]) + w[nums]); // 如果容量够，则选当前物品，则容量剩余sum - v[nums] return ans; } 可以看得出来，dfs+记忆化的好处就是简单易懂，似乎完全不用过多说明代码的意义 分析2： 本题递归+记忆化的好处就是易于思考，不需要过多地打草稿 但考虑到01背包经典性和别的背包问题都可以转换成01背包来解决，所以只会递归是不够的 根据上述分析1的内容，可以很容易定义状态：设dp[i][j]为决策到第i个物品时，还剩j容量的储存的最大价值 根据分析1的代码不难得出状态转移方程 $$ dp[i][j] = max\\lbrace dp[i + 1][j], \\ \\ dp[i + 1][j - v[i]] + w[i]\\rbrace \\ \\ (j \u003e= v[i]) $$ 递推部分代码如下，答案为dp[1][m] for (int i = n; i \u003e= 1; i--){ for (int j = 0; j \u003c= m; j++) { dp[i][j] = dp[i + 1][j]; // 不选 if (j \u003e= v[i]) dp[i][j] = max(dp[i][j], dp[i + 1][j - v[i]] + w[i]); // 选，前提是空间够 } } 其实从第1件物品开始也是一样的 输出答案为dp[n][m] for (int i = 1; i \u003c= n; i++) { for (int j = 0; j \u003c= m; j++) { dp[i][j] = dp[i - 1][j]; if (j \u003e= v[i]) dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]); } } 上面这个代码比逆着来递推的好处就是可以边读边计算，剩下了一些空间 for (int i = 1; i \u003c= n; i++) { scanf(\"%d%d\", \u0026v, \u0026w); for (int j = 0; j \u003c= m; j++) { dp[i][j] = dp[i - 1][j]; if (j \u003e= v) dp[i][j] = max(dp[i][j], dp[i - 1][j - v] + w); } } 复杂度都是$O(nm)$ 空间优化1： 不难发现，当遍历到第$i$个物品时（顺着来递推），它利用到的状态只有上一个物品的状态，即第i - 1个物品的状态，则这个第一维完全可以用滚动数组来优化，即优化成$2 * Maxn$的数组 直接看代码 #include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; const int Maxn = 1010; int n, m, dp[2][Maxn] = {0}; int main() { scanf(\"%d%d\", \u0026n, \u0026m); int now = 1, pre = 0; // 一个本状态，一个上一个状态 for (int i = 1; i \u003c= n; i++) { int v, w; scanf(\"%d%d\", \u0026v, \u0026w); fill_n(dp[now], dp[now] + m + 1, 0); // 这句话就01背包而言可以不用加，但在其他动规问题时可能就必须初始化了 for (int j = 0; j \u003c= m; ++j) { dp[now][j] = dp[pre][j]; if (j \u003e= v) dp[now][j] = max(dp[now][j], dp[pre][j - v] + w); } swap(pre, now); // 滚动 } printf(\"%d\", dp[pre][m]); // 答案是推出循环后的pre维数组里的答案 return 0; } 这种写法的好处就是当我们在处理动规时发现他的只和上一个状态有关时就可以用这种优化，注意第19行的初始化有时候是必加的，例如在计数类dp中，我们就必须初始化当前计算的数组（即当前循环的now维数组）为0 下面两种优化个人感觉比本空间优化1要重要 空间优化2 根据空间优化1， 我们再来看他的第二维，它会利用到$j - v[i]$的状态，计算完成后$j - v[i]$的状态就没用了 综上，看图 所以完全可以将二维优化成一维的数组，为了保持$j - v[i]$是上一个物品的状态，第二层递推时要逆着过来递推 状态转移方程如下 $$ dp[j] = max(dp[j],\\ \\ dp[j - v] + w) $$ 上述的状态方程是对应边读边计算的 最终代码如下 #include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; const int Maxn = 1010; int n, m, dp[Maxn] = {0}; int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { int v, w; scanf(\"%d%d\", \u0026v, \u0026w); for (int j = m; j \u003e= v; j--) { dp[j] = max(dp[j], dp[j - v] + w); } } printf(\"%d\", dp[m]); return 0; } 说明：这里的二层循环是m到v，一来是因为j要大于等于v数组才有意义，二来是因为最开始是从c到0时，当$j \u003c v$时只有不选当前物品的选择，则状态就会继承自一个物品此时的容量的状态，而此时代码是m到v默认了$j \u003c v$时的状态时继承自上一个物品同容量的状态 本优化多用于分组背包中空间优化，树形背包（有依赖的背包），记住子问题是01背包时，一维空间优化必须逆着来（有基础的同学可以回忆一下树形背包中的转化 空间优化3 下面介绍个人认为最最有用的空间优化手段 先来说说第一种空间优化的好处：好理解，不必像第二种空间优化那样需要逆着过来更新状态（相信我，考虑循环的顺逆，在比赛时真的可以把自己搞晕） 然而第一种空间优化也是有缺陷的：维度依然没有变化，即本来是二维的还是二维（这样的坏处就是多维时比较折磨人，想想树形背包，我们之所以可以用在定义状态时只开二维，是因为利用到了01背包一维优化的思想，更新时是逆着更新的，若要顺着更新，则可能会退化到三维，哪怕你第三位用滚动数组优化（第一种优化）可能也会被pre和now维度下标弄晕） 而第二种空间优化的好处和缺陷正好是第一种空间优化的缺陷和好处 综上，接下来要推出一个能集合上面两种优化的好处的优化手段 先看代码，感觉看了代码就能秒懂了 #include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; const int Maxn = 1010; int n, m, dp[Maxn] = {0}, tmp[Maxn]; int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { int v, w; scanf(\"%d%d\", \u0026v, \u0026w); for (int j = 0; j \u003c= m; ++j) tmp[j] = dp[j]; // 用tmp数组存起上一次的状态 for (int j = 0; j \u003c= m; ++j) { dp[j] = tmp[j]; // 这句话可以不加，具体问题具体分析吧 if (j \u003e= v) dp[j] = max(dp[j], tmp[j - v] + w); } } printf(\"%d\", dp[m]); return 0; } 当然还有另一种写法 #include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; const int Maxn = 1010; int n, m, dp[Maxn] = {0}, tmp[Maxn]; int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { int v, w; scanf(\"%d%d\", \u0026v, \u0026w); for (int j = 0; j \u003c= m; ++j) tmp[j] = 0; // 用tmp数组来装本次要更新的状态，初始化具体问题具体分析，例如dp找到是最大值","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:1:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"完全背包 紫书是先说完全背包问题的，紫书是从完全背包来引入背包问题的，可能是因为完全背包和硬币模型十分相似，都是DAG模型的题，和硬币模型最明显不同的是硬币模型起点和终点都是固定的，而完全背包是起点固定，终点任意的题 直接看例题 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:2:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题1】AcWing 3. 完全背包问题 完全背包的裸题，题意就不再赘述了 分析方式1： 刚刚说了，完全背包和无限硬币模型（硬币无限个，问你能否组成特定的面值）相似，只不过呢和硬币模型DAG有两个不同的地方，一是硬币模型的起点是要求的面值和，终点是0，而完全背包的DAG的起点是要求的背包总容量，而终点是任意的；二是硬币模型的边权是1，而完全背包问题的边权是对应物品的价值，固之前硬币问题中的“+1”就要变成“+w[i]”了 回忆一下硬币模型的状态定义：dp[i]表示面值为i的最大（最小）凑的数量，转移方程是：$dp[i] = max \\lbrace dp[i - coin[j]] \\rbrace + 1, \\ \\ i \\ge coin[j]$，其中除dp[0]为0外，其余都初始化为$-∞$ 上面说过，硬币模型的DAG终点是0，但完全背包问题的终点是任意的，固完全背包应该对所有dp值都初始化为0（这个和01背包中的不超过容量m和恰好容量是m的道理是一样的），不难得出完全背包的转移方程 $$ dp[i] = max\\lbrace dp[i - v[j]]\\ \\ +\\ \\ w[j]\\rbrace ,\\ \\ i \\ge v[j] $$ 和硬币模型差不多其中dp[i]表示容量为i的背包能装的最大价值，输出答案为dp[m] 代码如下 memset(dp, 0, sizeof dp); for (int i = 0; i \u003c= m; i++) { // 面值 对应完全背包的背包容量 for (int j = 1; j \u003c= n; j++) { // 硬币 对应完全背包的物品 if (i \u003e= v[j]) dp[i] = max(dp[i], dp[i - v[j]] + w[j]); } } 以上代码是仿照凑硬币模型写的，第一层循环和第二层循环是完全可以对调的 memset(dp, 0, sizeof dp); for (int j = 1; j \u003c= n; j++) { for (int i = 0; i \u003c= m; i++) { if (i \u003e= v[j]) dp[i] = max(dp[i], dp[i - v[j]] + w[j]); } } 注意到，上面的代码第二层循环的起点完全可以改成从v[j]到m，然后if语句就可以删去了 至于最终答案也是dp[m] memset(dp, 0, sizeof dp); for (int j = 1; j \u003c= n; j++) { for (int i = v[j]; i \u003c= m; i++) { dp[i] = max(dp[i], dp[i - v[j]] + w[j]); } } 时间复杂度为O(mn) 对于并非第一次接触完全背包的同学，是不是觉得上面的代码很像最终学到的代码呢，没错，上面的代码就是即将进入的分析方式2的最终结论 此时比较乱的同学可能有疑惑，第二重循环能否逆着来呢，答案是不行，细心的同学可能发现了，如果逆着过来就是01背包了 那么为什么不行呢，其实很简单，回到最开始完全背包的代码甚至是硬币模型的代码，我们是从0开始一步一步递推到最终目标m的，这样能推出最终答案，仔细想想也是，怎么可能是先从目标c开始推呢？ 分析方式2： 对于完全背包，上面的分析1完全是够用的，但是就以背包问题而言，这样是不够的 考虑这么一个物品，其重量为v[i]，则它最多只能装m/v[i]个，这个很重要，这个结论意味着完全背包可以转换成01背包来做 将每个无限个的物品看成有限的m/v[i]个，然后当成01背包来做，设dp[i][j]表示对于第i件物品，容量为j转移方程如下 $$ dp[i][j] = max\\lbrace dp[i - 1][j],\\ \\ dp[i - 1][j - k \\times v[i]] + k \\times w[i]\\rbrace \\ \\ k = 1, 2, 3, 4 \\cdots $$ 其中k = 0时就是dp[i - 1][j]，这个转移方程之所以这么写是为了对应01背包的转移方程 相应的代码如下 memset(dp, 0, sizeof dp); for (int i = 1; i \u003c= n; i++) { for (int j = 0; j \u003c= m; j++) { dp[i][j] = dp[i - 1][j]; // 不选 for (int k = 1; k * v[i] \u003c= m; k++) { //选 if (j \u003e= k * v[i]) dp[i][j] = max(dp[i][j], dp[i - 1][j - k * v[i]] + k * w[i]); } } } 时间复杂度为O($m n\\times \\frac{m}{v[i]}$) 很遗憾TLE了，对转移方程做一下变换 $$ dp[i][j] = max\\lbrace dp[i - 1][j], dp[i][j - v[i]] + w[i]\\rbrace $$ 解释：将每种无限的物品看成一个一个的，当不选这种物品时，则决策为上一种物品容量相同时的状态，当选这一种物品的一个时，其由同种物品的$j - v[i]$的容量转移过来 换句话说：如果我选当前物品，则应该是当前物品背包容量还剩$j - v[i]$加上当前物品的价值，即我选了当前物品我还能继续考虑是否选当前物品 状态定义是不变的代码如下 for (int i = 1; i \u003c= n; i++) { for (int j = 0; j \u003c= m; j++) { dp[i][j] = dp[i - 1][j]; // 不选 if (j \u003e= v[i]) dp[i][j] = max(dp[i][j], dp[i][j - v[i]] + w[i]); //选 } } 时间复杂度为O(nm)，这回Ac了 但同样是转换成01背包，为什么这个转移方程复杂度就降得如此低呢？说起来有点绕，如果下面解释完了还没明白可以自己草稿模拟两个代码或者一层一层递推状态方程，找到区别 假设我们考虑到dp[i][j]时，对于复杂度为O(cn)的转移，dp[i][j]由两个状态转移而来 一是dp[i - 1][j]，表示不选当前物品，状态来自上一种物品的同容量状态 二是dp[i][j - v[i]] + w[i]，表示选当前物品，状态来自同种物品，小v[i]容量的状态而来 根据动态规划的原则，上一个状态一定是计算好并且是当前最优解的值 而对于复杂度为O($m n\\times \\frac{m}{v[i]}$)的话，dp[i][j]则由多个状态而来 基本都是由上一种物品对应$j - k \\times v[i]$容量的状态而来，即$dp[i - 1][j - k \\times v[i]] + k \\times w[i]$ 注意到在复杂度为O($m n\\times \\frac{m}{v[i]}$)中计算dp[i][j]时，用到了一个状态就是dp[i - 1][j - 2 $\\times$ v[i]]，而我们在计算dp[i][j - v[i]]时也用到了dp[i - 1][j - k $\\times$ v[i]]这个状态，假设dp[i][j-v[i]]的最终值就是来自于dp[i - 1][j - t $\\times$ v[i]]，则dp[i][j]就相当于也利用到了$dp[i][j - v[i]]$的值，固可以把众多的[i - 1]的状态归纳为[i]，其余的便可以反推归纳为dp[i - 1][j] 真相已经浮出水面了：在复杂度为O(mn)的算法里dp[i][j - v[i]]的值可能本来就包含了（装了）若干个值为v[i]的物品，这就避免了复杂度为O($m n\\times \\frac{m}{v[i]}$)算法中许多的max计算 再来说说完全背包的空间优化 和01背包一样，可以把二维优化成一维的，但值得注意的是：j - v[i]的第一维是i，和01背包的i - 1不同，固它用的不是上一层的数据，而是刚更新的同层的下标在j之前的数据，所以第二层于01背包不同，要顺着遍历，即从小到达遍历 代码与分析1中的最终代码是一样的 memset(dp, 0, sizeof dp); for (int j = 1; j \u003c= n; j++) { for (int i = v[j]; i \u003c= m; i++) { dp[i] = max(dp[i], dp[i - v[j]] + w[j]); } } 一个重要的优化 对于0(mn)的复杂度应该说是非常优秀的了，但是O($m n\\times \\frac{m}{v[i]}$)在不换转移方程的思路下还是有别的优化方式的，能优化到O($nmlog\\frac{m}{v[i]}$) 采用一种二进制的方式优化 考虑这么一个数10，现在要你拆分成几个数，使得能够用这些数自由组合能够组合成和为1~10的数。最简单的方式就是把10拆成10个1，就能将1~10都能凑出来了 但是如果只拆成10个1就没有优化的意义了，现在要你拆分成最少的数使得自由组合能凑成1~10的数，有一种比较优秀的拆分方式，拆分的结果为：1，2，4，3；怎么分的？观察到第一个数是$2^0$，后面除了最后一个数依次是$2^1、2^2$，最后一个数是$10 - 2^0 - 2^1 - 2^2 = 3$得到的 这样做的好处是，这4个数，每个数只有选和不选两种选择，一次对应4个位数的二进制的数，例如0101就是选了2，3，于是就凑成了5 原话是这么说的：“这是二进制的思想。因为，不管最优策略选几件第i 种物品，其件数写成二进制后，总可以表示成若干个","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:2:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"多重背包 和01背包不同，01背包是每个物品都只有一个，但多重背包的每个物品都有若干个 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:3:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题1】AcWing 4. 多重背包问题 I 题意不多讲，但是值得一提的是，多重背包被分为了三种等级，对应的数据范围不同，本题数据范围是三种之中最小的 分析： 当成完全背包里的分析方式2一开始介绍的思路来做，每个物品有$s_i$个，只需改一下第三重循环便可 下面的代码顺便把空间也优化了 #include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; const int Maxn = 110; int n, m, dp[Maxn]; int main () { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { int v, w, s; scanf(\"%d%d%d\", \u0026v, \u0026w, \u0026s); for (int j = m; j \u003e= v; j--) {//01背包逆着来 for (int k = 1; k \u003c= s \u0026\u0026 k * v \u003c= j; k++) { dp[j] = max(dp[j], dp[j - k * v] + k * w); } } } printf(\"%d\", dp[m]); return 0; } 时间复杂度为O(mns)，速度比较慢，对于本题物品个数不超过100个，足够跑了 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:3:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题2】AcWing 5. 多重背包问题 II 本题和【例题1】的题意是一样的，只不过数据范围直接大了一位数 分析： 再用刚刚的思想完全是不够用的了，直接TLE了 还记得完全背包的二进制优化吗吗，利用那个思想，就能优化成O($mnlogs$)的复杂度了 具体代码如下 #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; struct goods{ int v, w; goods(int v = 0, int w = 0) : v(v), w(w) {} }; const int M = 2010; int dp[M], m, n; int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { int v, w, s; scanf(\"%d%d%d\", \u0026v, \u0026w, \u0026s); vector\u003cgoods\u003e good; for (int j = 1; j \u003c= s; j \u003c\u003c= 1) {//二进制优化 s -= j; good.push_back(goods(j * v, j * w)); } if (s) good.push_back(goods(s * v, s * w)); for (auto g : good) {//01背包 for (int j = m; j \u003e= g.v; j--) { dp[j] = max(dp[j], dp[j - g.v] + g.w); } } } printf(\"%d\", dp[m]); return 0; } 总结：通过多次用到了01背包的思想可以看出01背包的重要性 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:3:2","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题3】6. 多重背包问题 III 题意和【例题1】也是一样，但这题的数据范围更大，达到了2e5 这题需要用到单调队列优化（单调队列是什么？自学吧） 仔细看下面我截取例题1时的代码的部分 for (int j = m; j \u003e= v; j--) {//01背包逆着来 for (int k = 1; k \u003c= s \u0026\u0026 k * v \u003c= j; k++) { dp[j] = max(dp[j], dp[j - k * v] + k * w); } } 不难发现$j$只会利用到$j - k \\times v$来转化，这就意味着$j$只会和与$j(mod \\ \\ v)$同余的$dp$容量来转移，例如$j = 9, v = 2$则他只可能会利用容量为$7,5,3,1$的$dp$来转移 同时注意到第二重循环的第一个循环条件$k \\le s$，这就意味着$j$利用到的与$j(mod \\ \\ v)$同余的容量的个数是有限的，不超过$s$个，例如$j = 9, v = 2, s = 2$时，则只可能会利用容量为$7,5$的$dp$来转移 综上，是不是觉得很像一个在固定窗口大小里面找一个最大值？ 直接先看代码，然后再解刨 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e using namespace std; const int M = 2e4 + 5, N = 1e3 + 5; int dp[M], tmp[M], q[M]; int main() { int n, m; scanf(\"%d %d\\n\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; ++i) { int v, w, s; scanf(\"%d %d %d\", \u0026v, \u0026w, \u0026s); for (int i = 0; i \u003c= m; ++i) tmp[i] = dp[i]; for (int j = 0; j \u003c v; ++j) { // 枚举余数 int l = 0, r = -1; // 单调队列的左右指针 for (int k = j; k \u003c= m; k += v) { // 枚举容量 if (l \u003c= r \u0026\u0026 q[l] \u003c k - s * v) ++l;// 窗口范围必须是[k - s * v, k - v] if (l \u003c= r) dp[k] = max(tmp[k], tmp[q[l]] + (k - q[l]) / v * w); while (l \u003c= r \u0026\u0026 tmp[q[r]] + (k - q[r]) / v * w \u003c= tmp[k]) --r; q[++r] = k; } } } printf(\"%d\\n\", dp[m]); return 0; } 下面对代码进行解刨 首先，由于我们之前说的$j$在只会利用到比他小的同余数，所以我们转移时必选顺着转移，不能再逆着来了，这时就要用到之前01背包说的第三种空间优化来达到顺着转移的目的了 目光移到第16行代码（枚举余数），把相同余数的容量同时一起转移，固第18行的循环中是k += v这样就保证了每次的余数都是j（当前解说的代码的j） 然后就是第18行循环的内部循环了，首先学过单调队列的同学都知道，我们为了方便处理队列，我们在队列内存的不是对应的值，而知下标（在这题下标就是容量）。前面说到我们窗口的大小是有限制的，不能超过s个，固对应下标的范围就是$[k - s\\times v,k - v]$，固若q[l] \u003c k - s * v则弹出队头元素 然后就是20行的简单易懂的更新操作，用上一个状态和当前选取(k - q[l])/v个当前物品的状态进行对比转移 21和22行都是单调队列的入队操作，队尾弹出的条件就是容量为q[l]的状态加上(k - q[r]) / v * w的价值都没有当前k容量的状态价值大（小于等于） ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:3:3","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"混合背包 混合背包就是有些物品只能选1次，有些物品最多只能选s次，有些物品无限次，分别对应01背包，多重背包，完全背包 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:4:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题】混合背包问题 解决方法很简单，全部转化为01背包就好了，对于本来就是01背包的不作处理，对于多重背包的物品可以用二进制优化变成01背包，完全背包同理可以转化为最多只能选$\\frac{m}{v}$次的多重背包后再用二进制优化 代码略 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:4:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"二维费用背包 就是一个多了体积限制的背包罢了 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:5:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题】二维费用的背包问题 很简单，多加一维体积的数组，转移时和01背包相同 直接看代码就好了 #include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; const int Maxn = 110; int n, V, M, dp[Maxn][Maxn]; int main () { scanf(\"%d%d%d\", \u0026n, \u0026V, \u0026M); for (int i = 1; i \u003c= n; ++i) { int v, m, w; scanf(\"%d%d%d\", \u0026v, \u0026m, \u0026w); for (int i = V; i \u003e= v; i--) for (int j = M; j \u003e= m; j--) dp[i][j] = max(dp[i][j], dp[i - v][j - m] + w); } printf(\"%d\", dp[V][M]); return 0; } ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:5:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"分组背包 分组背包就是有若干组物品，对于每组物品都有若干件物品，每组物品最多选一个物品，问你容量不超过c的能装的最大价值 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:6:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题】AcWing9. 分组背包问题 题意不多说，就是一个赤果果的分组背包问题 分析： 可以把每一组物品看成一个物品，然后当成01背包来做，不同的是对于每种容量的背包，都要考虑每组物品的每一个物品 也可以这么理解，对于每组物品，都假设只有一个物品，这一组物品就是一个物品了，然后不就是01背包了吗 #include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; const int Maxn = 105; int n, m, dp[Maxn]; int main () { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1 ; i \u003c= n; i++) { int v[105], w[105], s; scanf(\"%d\", \u0026s); for (int j = 0; j \u003c s; j++) { scanf(\"%d%d\", \u0026v[j], \u0026w[j]); } for (int j = m; j \u003e= 0; j--) { //01背包 for (int k = 0; k \u003c s; k++) { //假设当前组只有这一个物品 if (j \u003e= v[k]) dp[j] = max(dp[j], dp[j - v[k]] + w[k]); } } } printf(\"%d\", dp[m]); return 0; } 值得注意的是第18行和19行的代码是不可以互换的，因为一维01背包是从大到小遍历的，保持小的下标是之前的数据。若是调换过来就相当于把每件物品都看成了一件物品，而不是隶属于某一组的物品 还有一点很重要的就是分组背包的思想可以迁移到树形背包（有依赖的背包问题）的 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:6:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"有依赖的背包问题 就是一个树形背包，即如果要选一个结点，则其父亲节点必须要被选 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:7:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题】有依赖的背包问题 核心：把一个结点的每个孩子结点看做不同的组，即可以当成分组背包来自，那么组内的物品是什么呢，答案就是每组的一个决策就是一个物品（就这题而言就是每一个dp容量值就是一个物品），注意：这个思想很重要，他是所有（应该是所有）树形背包dp的共同特点 先看代码再解刨 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#define ll long long #define pb emplace_back using namespace std; const int M = 105, N = 1e3 + 5, inf = 1e9; vector\u003cint\u003e mp[M]; int root, n, m, dp[M][M], w[M], v[M], tmp[M]; int dfs(int u) { int sum = v[u]; // 记录本棵树的物品总重量 dp[u][v[u]] = w[u]; for (int\u0026 son : mp[u]) { int siz = dfs(son);// 计算孩子节点的决策，并获取他的物品总重量 for (int i = 0; i \u003c= min(m, sum + siz); ++i) tmp[i] = dp[u][i]; // 还记得01背包的空间优化3吗 for (int i = 0; i \u003c= siz; ++i) { // 这棵孩子子树选取i容量的物品 for (int j = v[u]; j \u003c= sum; ++j) { // 之前组选取的容量j if (i + j \u003e m) break; // 超过背包容量的不用转移 dp[u][i + j] = max(dp[u][i + j], tmp[j] + dp[son][i]); } } sum += siz; } return sum; //返回本树的总容量 } int main() { scanf(\"%d %d\\n\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; ++i) { int p; scanf(\"%d %d %d\\n\", \u0026v[i], \u0026w[i], \u0026p); if (p != -1) mp[p].pb(i);//存树 else root = i; } int ans = dfs(root); printf(\"%d\\n\", dp[root][min(ans, m)]); return 0; } 核心就是dfs内的函数，就直接解刨里面的吧 先来解释dp的含义dp[u][v]表示在u结点这颗子树中选取容量为v的最大价值 13行不解释，14行的话很显然，由于要选本结点的子结点则本结点必选，所以就有了14行的初始化 然后是17行，这是之前在01背包中第三种空间优化的一种手段，这样做的好处有：1、更新本结点的dp时可以顺着来更新（好理解），2、可以防止不必要的转移（具体看第21行dp的第二维转移方式）且保证了整个复杂度不高于$O(nm)$，既保证了每个（点）都只会在题目的LCA上计算一次，否则可能会使复杂度退化到O($nm^2$)，后面会解释 然后就是转移思想可以参考树形背包思考模型 接下来状态转移，先说说为什么这样转移，需要提前知道的是下面两个转移方程会导致复杂度不同 $$ dp[u][j] = max(dp[u][j], \\ \\ dp[son][i] + dp[u][j - i]) \\tag{1} $$ $$ dp[u][i + j] = max(dp[u][i + j],\\ \\ dp[son][i] + dp[u][j]) \\tag{2} $$ 有经验的小伙伴可能知道，式子(1)是填表法，式子(2)是刷表法。对于树形背包问题有个很玄学的优化就是利用刷表法来更新当前结点，这样就能保证复杂度是O($nm$)而不是O($nm^2$)，我的理解就是刷表法保证了本结点的合法性，并且使得所有结点都只会在他们的LCA上被算一次。反观填表法在有些题目上十分难以拿捏本结点的合法性 固以上就是我选择18行到23内部循环的方式的原因 没了 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:7:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"背包问题求方案数 题意就是让我们求01背包最优解的方案 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:8:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题】背包问题求方案数 多建立一个数组f[i][j]表示前i个物品选取容量为j的最优解方案数 注意初始化f[0][j]应当都初始化为1，因为是不超过m容量，所以这样初始化就保证了第一个物品转移有效 直接看代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ciostream\u003e#include \u003ccctype\u003e #define ll long long using namespace std; const int M = 1e3 + 5, N = 1e3 + 5, inf = 1e9, mod = 1e9 + 7; int n, m, dp[M][M]; ll f[M][M]; int main() { scanf(\"%d %d\\n\", \u0026n, \u0026m); for (int i = 0; i \u003c= m; ++i) f[0][i] = 1; for (int i = 1; i \u003c= n; ++i) { int v, w; scanf(\"%d %d\", \u0026v, \u0026w); for (int j = 0; j \u003c= m; ++j) { dp[i][j] = dp[i - 1][j]; // 不选 f[i][j] = f[i - 1][j]; //不选 if (j \u003e= v) { if (dp[i - 1][j - v] + w == dp[i][j]) f[i][j] = (f[i][j] + f[i - 1][j - v]) % mod; //如果相等就相加 if (dp[i - 1][j - v] + w \u003e dp[i][j]) { f[i][j] = f[i - 1][j - v]; // 否则更新值 dp[i][j] = dp[i - 1][j - v] + w; } } } } printf(\"%lld\\n\", f[n][m]); return 0; } 当然此题也可以空间优化 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:8:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"背包问题求具体方案 题意是让我们求01背包最优解的一个具体方案，并且输出字典序最小的那个 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:9:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题】背包问题求具体方案 求解具体方案如果只是随便找，则直接在转移结束后倒过来找就好了，但是题目要求的是字典序最小，那么我们要在转移顺序上做一些改动，即从最后一个物品到第一个物品转移，然后再贪心找字典序最小的方案就好了 一下递归找方案个人比较喜欢 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e #define pb emplace_back using namespace std; const int M = 1e3 + 5, N = 1e3 + 5, inf = 1e9, mod = 1e9 + 7; int n, m, dp[M][M], v[M], w[M]; vector\u003cint\u003e ans; //记录答案 void solve(int num, int m) { if (m == 0 || num == n + 1) { for (int\u0026 v : ans) printf(\"%d \", v); exit(0); //结束程序 } if (m \u003e= v[num] \u0026\u0026 dp[num][m] == dp[num + 1][m - v[num]] + w[num]) { // 如果符合转移 ans.pb(num);//记录答案 solve(num + 1, m - v[num]); ans.pop_back(); // 回溯 } solve(num + 1, m); } int main() { scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; ++i) scanf(\"%d %d\", v + i, w + i); for (int i = n; i; --i) { for (int j = 0; j \u003c= m; ++j) { dp[i][j] = dp[i + 1][j]; if (j \u003e= v[i]) dp[i][j] = max(dp[i][j], dp[i + 1][j - v[i]] + w[i]); } } solve(1, m); return 0; } 注意，这题不能空间优化了 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:9:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"结语 写了好久好久，早就有把acwing上的背包总结博客写好的念头了，结果从开始计划到现在过了两三个月参完工，我太懒了。 这篇博客严格上来说其实并不是所有的背包问题的总结，还有其他背包中比较深究的问题，比如说求解背包问题求解次优解，第k优解等等比较深入的问题，太菜了没学。 就这样告一段落吧 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:10:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"主席树 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:0:0","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"简介 主席树是用来求区间第k大的一个可持续化数据结构 主要思想就是权值线段树+前缀和思想 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:1:0","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"几个问题 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:2:0","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"1. 用权值线段树+前缀和的原因 首先、如果我们要求一个固定区间的第k大，其中一个可以使用数据结构就是权值线段树 由于题目要我们求的是不定区间的区间第k大，我们可以用前缀和的思想建立和区间同长个数的权值线段树，这样当我们要求$[l, r]$的第k大的时候，我们就可以用第$r$个权值线段树 减去 第$l - 1$个权值线段树得到的权值线段树来求第k大 为了节省空间，我们可以使第$i$个和第$i - 1$个 权值线段树公用一些结点 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:2:1","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"2. 内存池 这个有点像链式前向星的思路，每次要添加新的边就++cnt，并让对应的边的下标为cnt 同理，我们可以在每次新加一个结点时，就++cnt，并让对应的结点的下标为cnt 可以把这里的cnt想象成我们在为新的指针申请地址时的地址号 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:2:2","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"3. 不同版本的权值线段树的存储 显然，我们要找一颗树，只需要找他的根结点就可以了 固我们可以记录每个版本（不同时间线）的权值线段树的根结点的内存池下标 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:2:3","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"4. 离散化 因为我们要建立的是权值线段树，固需要对数据进行离散化，本文的离散化做了预处理打表 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:2:4","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"结构体存放树的结点 利用结构体存放结点的好处就是访问方便，代码好写 const int N = 2e5 + 5; struct nodes{ int l, r, sum; // 左孩子的内存池编号、 右孩子内存池编号、 线段树的结点权值 nodes() : sum(0) {} }hjt[N \u003c\u003c 5]; // 开多点，一边都是32倍管够 int root[N], cnt; // 记录每个根结点的内存池编号， 内存池 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:3:0","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"建树 看AgOH的视频里面并没有加这个建树的操作，但是我觉得还是挺有必要加的，因为后面的一些可持续化数据结构能够用得上 初始建树其实可以想象成我们前缀和的第0项 int build(int l, int r) { int now = ++cnt; // 内存申请 if (l \u003c r) { int mid = (l + r) \u003e\u003e 1; hjt[now].l = build(l, mid); // hjt[now].r = build(mid + 1, r); // } return now; // 返回当前节点的内存池编号 } ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:4:0","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"插入新的权值 插入新的权值即新建一颗权值线段树 但注意，由于要复用之前的一些结点，固有些东西的写法和普通的权值线段树是不一样的，具体看代码 // 插入新节点的操作 int update(int pre, int l, int r, int x) { // 插入一个新的权值为x int now = ++cnt; // 内存申请 hjt[now] = hjt[pre], ++hjt[now].sum; // 继承上一个版本的结点，即复用，因为新加了一个值，所以结点权值+1 if (l \u003c r) { // 寻找拼接点 int mid = (l + r) \u003e\u003e 1; if (x \u003c= mid) hjt[now].l = update(hjt[now].l, l, mid, x); // 如果x在左边，则让当前新节点的左孩子接继承后的左孩子 else hjt[now].r = update(hjt[now].r, mid + 1, r, x); // 否则同理 } return now; } 代码的第4行的第一语句就像是图中一个8号新节点用两个红色的边与连向1号结点的两个孩子 代码的第8行就像是图中将8号结点的右孩子边**“剪掉”**再用一个新的绿色边和下一个新结点相连 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:5:0","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"询问 查询是最后的操作了，具体做法主要的思想就是前缀和的思想 计算左孩子的$l, r$版本权值和的差，然后再对比 每次查询可以想象成只有一颗线段树上查找第k大 // 返回第qr版本的主席树 - 第ql版本的主席树， 注意返回的是离散化后的值 int get(int ql, int qr, int l, int r, int k) { if (l == r) return l; // 返回权值点上的权值 int mid = (l + r) \u003e\u003e 1; int dif = hjt[hjt[qr].l].sum - hjt[hjt[ql].l].sum; // 计算左孩子的版本权值和的差 if (k \u003c= dif) return get(hjt[ql].l, hjt[qr].l, l, mid, k); // 答案在左孩子上 return get(hjt[ql].r, hjt[qr].r, mid + 1, r, k - dif); // 答案在右孩子上，记得这时是找第k - dif的 } ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:6:0","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"完整代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } using namespace std; /*************************************离散化********************************************/ // vt存放可用于查询原本的数（用离散化值），打表后用于查询离散化表（用下标） vector\u003cint\u003e vt; inline int get_id(const int \u0026x) { return lower_bound(vt.begin(), vt.end(), x) - vt.begin() + 1; } inline void erase_vt() { sort(vt.begin(), vt.end()); vt.erase(unique(vt.begin(), vt.end()), vt.end()); } // 打表, 注意，原数组下标要从1开始，返回离散化后的表大小 inline int id_table(int n, int *a, vector\u003cint\u003e \u0026res) { res.emplace_back(0); for (int i = 1; i \u003c= n; ++i) res.emplace_back(get_id(a[i])); return vt.size(); } /*************************************主席树********************************************/ const int N = 2e5 + 5; struct nodes{ int l, r, sum; nodes() : sum(0) {} }hjt[N \u003c\u003c 5]; int root[N], cnt; // 记录每个根结点的内存池编号， 内存池 int build(int l, int r) { int now = ++cnt; // 内存申请 if (l \u003c r) { int mid = (l + r) \u003e\u003e 1; hjt[now].l = build(l, mid); hjt[now].r = build(mid + 1, r); } return now; } // 插入新节点的操作 int update(int pre, int l, int r, int x) { int now = ++cnt; // 内存申请 hjt[now] = hjt[pre], ++hjt[now].sum; // 继承 if (l \u003c r) { // 寻找拼接点 int mid = (l + r) \u003e\u003e 1; if (x \u003c= mid) hjt[now].l = update(hjt[now].l, l, mid, x); // 如果x在左边，则让当前新节点的左孩子接继承后的左孩子 else hjt[now].r = update(hjt[now].r, mid + 1, r, x); // 否则同理 } return now; } // 返回第qr版本的主席树 - 第ql版本的主席树， 注意返回的是离散化后的值 int get(int ql, int qr, int l, int r, int k) { if (l == r) return l; int mid = (l + r) \u003e\u003e 1; int dif = hjt[hjt[qr].l].sum - hjt[hjt[ql].l].sum; if (k \u003c= dif) return get(hjt[ql].l, hjt[qr].l, l, mid, k); // 左孩子上 return get(hjt[ql].r, hjt[qr].r, mid + 1, r, k - dif); // 右孩子上 } /*************************************主函数********************************************/ int a[N]; int main() { int n = IO(), m = IO(); for (int i = 1; i \u003c= n; ++i) a[i] = IO(), vt.emplace_back(a[i]); erase_vt(); vector\u003cint\u003e id; int siz = id_table(n, a, id); root[0] = build(1, siz); for (int i = 1; i \u003c= n; ++i) root[i] = update(root[i - 1], 1, siz, id[i]); while (m--) { int l = IO(), r = IO(), k = IO(); printf(\"%d\\n\", vt[get(root[l - 1], root[r], 1, siz, k) - 1]); } return 0; } ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:7:0","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"前言 终于开始刷贪心了，感觉cf很多题都喜欢出贪心，所以决定也练练 贪心貌似也有挺系统的分类和一些经典例题，把这些刷了应该就有提升了把 ","date":"2021-03-23","objectID":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:1:0","tags":["贪心"],"title":"贪心刷题总结","uri":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"总结 贪心是指将问题通过当前最优解来求解得到最终的最优解，即局部最优解可以推出总体最优解。 给我的感觉就是一种思维题，通过一定技巧把题目旁敲侧击地解决了，但是如果没接触过或者想不出来，基本就很难了，但是贪心的代码实现并不长，所以说贪心即使很基础的算法也是很难的算法。 总得来说贪心算法难就难在每道题的贪心策略都不同，是否能贪心也很难看出来。 一般在解决贪心题的时候可以把他放到生活中的例子来，想想如果是生活中碰到这题，你会怎么解决让自己最舒服。 ","date":"2021-03-23","objectID":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:2:0","tags":["贪心"],"title":"贪心刷题总结","uri":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"普通贪心 例题1：HDU 2111 Saving HDU 题意：你有可以装k个宝贝容量的包，现在给你一些宝贝，每个宝贝价值p，有m个，问你最多可以装多少价值的宝贝 思路：将价值排序，先选大的，选到v = 0为止 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003cutility\u003e#include \u003cvector\u003eusing namespace std; int n, v; int main() { while (scanf(\"%d\", \u0026v), v) { scanf(\"%d\", \u0026n); vector\u003cpair\u003cint, int\u003e\u003e q; for (int i = 0; i \u003c n; i++) { int p, m; scanf(\"%d%d\", \u0026p, \u0026m); q.push_back(make_pair(p, m)); } sort(q.begin(), q.end()); int i = n - 1, ans = 0; while (i \u003e= 0 \u0026\u0026 v) { if (q[i].second \u003c v) { ans += q[i].first * q[i].second; v -= q[i].second; } else { ans += q[i].first * v; v = 0; } i--; } printf(\"%d\\n\", ans); } } 例题2：HDU 3348 题意：你有1、5、10、50、100的钞票，给你各个钞票的张数，问你要凑齐某价格最多和最少需要多少张，如果凑不出来输出-1 思路：最少的话就从大面值的钞票开始贪心，如果最后剩余需要凑的钱不为0，则凑不齐，至于最多的话，贪心可以这样想：要凑用得最多，那言外之意就是我剩余得最少，所以可以凑最少的贪心策略去凑所有钞票的总价格 - 需要凑的价格，最后剩下的钞票数就是需要凑的价格，固剩下的钞票数量就是最多的答案 总结：这道题的寻找最多的那个答案，一开始死活想不出来，后来看了大佬的思路恍然大悟，所以有所感悟：有时候一个问题顺着想可能很难，那不妨试试逆着来想，所谓正难则反 代码如下 #include \u003cbits/stdc++.h\u003e using namespace std; int corn[] = {1, 5, 10, 50, 100}, t, n, nums[6] = {0}; int main() { scanf(\"%d\", \u0026t); while (t--) { int tmp = n, indx = 4, Max = 0, Min = 0, sum = 0, csum = 0; scanf(\"%d\", \u0026n); for (int i = 0; i \u003c 5; i++) { scanf(\"%d\", nums + i); sum += nums[i] * corn[i]; csum += nums[i]; } while (tmp \u0026\u0026 indx \u003e= 0) { int num = tmp / corn[indx]; if (num \u003e nums[indx]) { num = nums[indx]; } tmp -= num * corn[indx]; Min += num; indx--; } if (tmp != 0) { printf(\"-1 -1\\n\"); continue; } //需要凑的最大数目 tmp = sum - n, indx = 4; while (tmp \u0026\u0026 indx \u003e= 0) { int num = tmp / corn[indx]; if (num \u003e nums[indx]) { num = nums[indx]; } tmp -= num * corn[indx]; Max += num; indx--; } printf(\"%d %d\\n\", Min, csum - Max); } return 0; } 例题3：cf 230A Dragons 题意：打龙了， 你目前要打n条龙，你的力量是s，你打一个龙的话你的力量必须比龙大，如果你打死一条龙你也可以获得相应的力量，问你是否能把所有的龙都打完 思路：一道很简单的贪心，先从力量小的龙开始打，看看能不能打完就好了 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003cutility\u003e#include \u003cvector\u003e#define all(x) x.begin(), x.end() using namespace std; vector\u003cpair\u003cint, int\u003e\u003e dr; int n, s; int main() { scanf(\"%d%d\", \u0026s, \u0026n); for (int i = 0; i \u003c n; i++) { int x, y; scanf(\"%d%d\", \u0026x, \u0026y); dr.push_back(make_pair(x, y)); } bool win = true; sort(all(dr)); for (int i = 0; i \u003c n; i++) { if (s \u003e dr[i].first) { s += dr[i].second; } else { win = false; puts(\"NO\"); break; } } if (win) puts(\"YES\"); return 0; } 例题4：51Nod - 1117 聪明的木匠 题意：一个木段，现要锯成$L_1, L_2, L_3 …… L_n$的长度，但是据一段木段需要消耗相应的体力，例如要把长为8的木段锯成 3 和 5 的话需要消耗3 + 5 = 8的体力，现在问你最少要消耗多少体力锯好 错误的思路：一开始想不出来，单纯的觉得是一个简短的排序不等式的的贪心题，只要先据出最大的目标值，然后一直据下去就是最优解，但这是不对的，最多也就过个他给的样例。 正确的思路①：仔细想想，如果是没按要求切成题目要求目标长度切，那样的话当然是希望一切下去可以让后面的体力没这么多，比如要分成2 2 3 3，这样的话应该是先 5 5 再 2 3 5 最后就 2 3 2 3这样就是最小的，消耗为20， 如果是按照先前的想法就是21，所以先前的思路显然是不对的。那这个思路怎么实现呢，dfs？显然很难实现 正确的思路②：回忆上上题的总结，正难则反，反过来想，现在把问题改成拼成一个完整的木段，消耗最小，这样的话就是拼当前最小的两小木段，最终的答案就是最小的 代码如下(注释的部分是一开始错误的思路，交上去才发现思路不对) #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cqueue\u003e using namespace std; using ll = long long; int n, arr[50010], sum[50010]; priority_queue\u003cint\u003e heap; int main() { scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; i++) { // scanf(\"%d\", \u0026arr[i]); int x; scanf(\"%d\", \u0026x); heap.push(-x); } int ans = 0; while (heap.size()) { int x = -heap.top(); heap.pop(); int y = -heap.top(); heap.pop(); ans += x + y; if (heap.size()) heap.push(-(x + y)); } printf(\"%d\", ans); /* sort(arr, arr + n); for (int i = 0; i \u003c n; i++) { sum[i + 1] = sum[i] + arr[i]; } ll ans = 0; for (int i = n - 1; i \u003e= 1; i--) { ans = ans + arr[i] + sum[i] - sum[0]; } printf(\"%lld\\n\", ans); */ return 0; } 例题5：HDU 6709 Fishing Master 题意：钓鱼家有一个锅和一个鱼竿，他有 n 条鱼要钓，钓一条鱼需要 k 时间，他的任务就是把这些鱼都钓上来，并且把它们都煮了，第i条鱼的煮熟所需要的时间为$t_i$，他钓鱼的时候不能往锅里放鱼并且要等他掉好k时间才可做下一件事，他可以在煮鱼的时候钓鱼，他可以同时拥有很多鱼，即他钓好后可以放在身边，因为锅一次只能煮一条鱼。现在问你他至少要花多少时间煮好n条鱼。 思路： 一开始看错题，wa了一下午，英语太差的锅。回归正题，显然第一条鱼是钓的时间是不可避免的，全部煮鱼的时间也是不可避免的。可以优化的就只有钓鱼多出来的时间了。 注意到只要我煮的鱼时间足够长，那么我就可以在煮鱼的这个空档里面钓足够多的鱼，即可以钓$t_i / k$条，如果鱼快煮好了，即再过$x(x \u003c k)$的时间就煮好鱼了，不难发现这里的$x = t_i % k$，那么这时候是继续钓鱼呢，还是选择去等鱼煮好然后放下一条（前提是你手上有钓好的鱼） 如果你选择继续钓鱼，那时间就会多花$k - t_i % k$的时间 如果你选择去等待的话，那你手上就必须要有鱼，没鱼怎么办，那只能选择上个选择，即继续钓鱼 画图出来可能比较直观 对于这个配图，即便是$t_i \u003c k$公式依旧成立 显然，根据图，","date":"2021-03-23","objectID":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:3:0","tags":["贪心"],"title":"贪心刷题总结","uri":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"区间贪心 例题1：HDU 2037 今年暑假不AC 题意：给你一些区间，让你选出尽量多的不相交的区间 思路：把所有区间（x, y）根据y来从小到大排序，然后从第一区间开始，排除和他相交的区间，即对比前一个选定的区间的y和当前要对比的区间的x，如果x \u003c y则不选，否则回到上一步 看代码容易懂 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003cutility\u003e#include \u003cvector\u003e using namespace std; int n; int main() { while (scanf(\"%d\", \u0026n), n) { vector\u003cpair\u003cint, int\u003e\u003e coo; int x, y; for (int i = 0; i \u003c n; i++) { scanf(\"%d%d\", \u0026x, \u0026y); coo.push_back(make_pair(y, x)); } sort(coo.begin(), coo.end()); int num = 0, last = -0x3f3f3f3f; for (int i = 0; i \u003c n; i++) { if (last \u003c= coo[i].second) { num++; last = coo[i].first; } } printf(\"%d\\n\", num); } } ","date":"2021-03-23","objectID":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:4:0","tags":["贪心"],"title":"贪心刷题总结","uri":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"领项交换法 例题1：LOJ 加工生产调度 题意：一个物品必须要现在A车间加工，才能在B区间加工个，问你n个物品最短的加工结束时间是多少 思路：一道Johnso不等式的题，不知道也没关系，只要你会邻项交换法就能写 首先假设只有两个产品要加工，其中一种最优解，两个下标分别为$i,j$，则其最终加工的时间为 $$ max(a_i + b_i, a_i + a_j) + b_j $$ 假设调换$i,j$，则最终的加工时间为 $$ max(a_j + b_j, a_j + a_i) + b_i $$ 此时我当然是希望以下等式成立 $$ max(a_i + b_i, a_i + a_j) + b_j \u003c max(a_j + b_j, a_j + a_i) + b_i $$ 固我们直接这样排序就可以了(这就是邻项交换法)，当然网上还有对上式继续化简后的不等式，据说是Johnson不等式（我也不是很懂这个不等式，总之挺有意思的） $$ max(a_i + b_i, a_i + a_j) + b_j \u003c max(a_j + b_j, a_j + a_i) + b_i $$ $$ \\Rightarrow max(b_i,a_j) + a_i + b_j \u003c max(b_j, a_i) + a_j + b_i $$ $$ \\Rightarrow max(b_i,a_j) - a_j - b_i \u003c max(b_j, a_i) - a_i - b_j $$ $$ \\Rightarrow max(-a_j,-b_i) \u003c max(-a_i, -b_j) $$ $$ \\Rightarrow min(a_j, b_i) \u003e min(a_i, b_j) $$ 以上式子均可以放到sort中作为排序的依据 ac代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; #include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } const int M = 1e5 + 5, N = 1000 + 5, inf = 0x3f3f3f3f; int n, m; #define ll long long struct pairs { int i, a, b; }p[N]; int main() { n = IO(); for (int i = 0; i \u003c n; ++i) { p[i].i = i, p[i].a = IO(); } for (int i = 0; i \u003c n; ++i) p[i].b = IO(); sort(p, p + n, [] (pairs \u0026i, pairs \u0026j) { return max(i.b, j.a) + i.a + j.b \u003c max(j.b, i.a) + j.a + i.b; // return min(j.a, i.b) \u003e min(i.a, j.b);//这个也可以 }); int ans = 0, a = 0, b = 0; for (int i = 0; i \u003c n; ++i) { a += p[i].a; b = max(a, b) + p[i].b; } ans = b; printf(\"%d\\n\", ans); for (int i = 0; i \u003c n; ++i) { printf(\"%d\", p[i].i + 1); if (i != n - 1) putchar(' '); } return 0; } ","date":"2021-03-23","objectID":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:5:0","tags":["贪心"],"title":"贪心刷题总结","uri":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"ddl贪心 例题1：智力大冲浪 一种简单型的$ddl$贪心问题，每个任务都是单位时间就能完成 贪心方案：先讲扣的分数降序排序，再从其$ddl$时间开始往前找时间给他完成（因为要尽量空出前面的时间给后面的任务，换句话说就是让当前任务尽可能是接近$ddl$的时间之前完成），若找不到这个时间则扣这个扣款数 ac代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; #include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } const int M = 1e5 + 5, N = 1000 + 5, inf = 0x3f3f3f3f; // int a[M], sum[M]; int n, m; #define ll long long struct pairs { int t, w; }p[N]; bool day[N]; int main() { #ifndef ONLINE_JUDGE freopen(\"D:/MYCODE/vsCode-c/test.in\", \"r\", stdin); freopen(\"D:/MYCODE/vsCode-c/test.out\", \"w\", stdout); #endif m = IO(), n = IO(); int sum = 0; for (int i = 1; i \u003c= n; ++i) p[i].t = IO(); for (int i = 1; i \u003c= n; ++i) sum += p[i].w = IO(); sort(p + 1, p + 1 + n, [](pairs\u0026 i, pairs\u0026 j) { return i.w \u003e j.w; }); for (int i = 1; i \u003c= n; ++i) { for (int j = p[i].t; j; --j) { if (day[j]) continue; day[j] = true; sum -= p[i].w; break; } } printf(\"%d\", m - sum); return 0; } 例题2：家庭作业 这题是一道进阶版的ddl贪心问题，和智力大冲浪一样，只是数据范围大了很多 首先思路和智力大冲浪是一样的，先做了分高的，时间从这个分高的$ddl$后往前遍历，看看有没有时间能做，能就加上这个分，不能就跳过 但是由于这个$ddl$的是长度太长了，两重循环一定会超时的，所以，就要优化一下 优化方案一（线段树） 不难发现，我们上面的思路的第二重循环目的就是为了找从$1$到$ddl$时间里面最靠后的时间是多少 所以可以用一个线段树优化，即查找区间最大值 代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; #include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } const int M = 1e6 + 5, N = 7e5 + 5, inf = 0x3f3f3f3f; int n, m; struct pairs { int t, c; }p[M]; int seg[N \u003c\u003c 2]; void build(int l, int r, int node = 1) { if (l == r) { seg[node] = l; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, node \u003c\u003c 1), build(mid + 1, r, node \u003c\u003c 1 | 1); seg[node] = max(seg[node \u003c\u003c 1], seg[node \u003c\u003c 1 | 1]); } void update(int index, int l, int r, int node = 1) { if (l == r) { seg[node] = 0; return; } int mid = (l + r) \u003e\u003e 1; if (index \u003c= mid) update(index, l, mid, node \u003c\u003c 1); else update(index, mid + 1, r, node \u003c\u003c 1 | 1); seg[node] = max(seg[node \u003c\u003c 1], seg[node \u003c\u003c 1 | 1]); } int get(int index, int l, int r, int node = 1) { if (r \u003c= index) return seg[node]; int mid = (l + r) \u003e\u003e 1; int res = get(index, l, mid, node \u003c\u003c 1); if (index \u003e mid) res = max(res, get(index, mid + 1, r, node \u003c\u003c 1 | 1)); return res; } int main() { n = IO(); int ans = 0, d = 0; for (int i = 0; i \u003c n; ++i) p[i].t = IO(), p[i].c = IO(), d = max(d, p[i].t); sort(p, p + n, [] (pairs\u0026 i, pairs\u0026 j) { return i.c \u003e j.c; }); build(1, d); for (int i = 0; i \u003c n; ++i) { int maxv = get(p[i].t, 1, d); if (maxv) { ans += p[i].c; update(maxv, 1, d); } } printf(\"%d\", ans); return 0; } 优化方案二 （并查集） 上面用线段树无非就是为了找从$1$到$ddl$的最大值 这个过程其实可以用并查集来做，即初始化从$1$到$ddl$的时间里面最大值都是他们自己，当这个时间被用了之后，就让其父亲指向前一个时间 代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; #include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } const int M = 1e6 + 5, N = 7e5 + 5, inf = 0x3f3f3f3f; int n, m; struct pairs { int t, c; }p[M]; int fa[N]; int findset(int x) { return x == fa[x] ? x : fa[x] = findset(fa[x]); } int main() { n = IO(); int ans = 0, d = 0; for (int i = 0; i \u003c n; ++i) p[i].t = IO(), p[i].c = IO(), d = max(d, p[i].t); sort(p, p + n, [] (pairs\u0026 i, pairs\u0026 j) { return i.c \u003e j.c; }); for (int i = 0; i \u003c= d; ++i) fa[i] = i; for (int i = 0; i \u003c n; ++i) { int maxv = findset(p[i].t); if (maxv) { ans += p[i].c; fa[maxv] = maxv - 1; } } printf(\"%d\", ans); return 0; } 优化方案三（优先队列） 这个优化方案在$loj$不开O2优化依然超时 而且这个优化方案其实不是对上面超时的思路进行优化，但是挺好的，只是被$loj$卡了罢了 ","date":"2021-03-23","objectID":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:6:0","tags":["贪心"],"title":"贪心刷题总结","uri":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"二分图 ","date":"2021-03-15","objectID":"/2021/03/%E4%BA%8C%E5%88%86%E5%9B%BE/:0:0","tags":["图论"],"title":"二分图","uri":"/2021/03/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["总结"],"content":"判图 利用染色法判 // 未试过 bool dfs(int u, int c) { col[u] = c; for (int \u0026v : gp[u]) { if (!col[v]) dfs(v, 3 - c); else if (col[v] == c) return false; } return true; } for (int i = 1; i \u003c= n; ++i){ if (col[i] == 0) dfs(i, 1); } ","date":"2021-03-15","objectID":"/2021/03/%E4%BA%8C%E5%88%86%E5%9B%BE/:1:0","tags":["图论"],"title":"二分图","uri":"/2021/03/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["总结"],"content":"最大匹配 ","date":"2021-03-15","objectID":"/2021/03/%E4%BA%8C%E5%88%86%E5%9B%BE/:2:0","tags":["图论"],"title":"二分图","uri":"/2021/03/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["总结"],"content":"匈牙利算法 int match[M]; bool vis[M]; bool dfs(int u) { for (int \u0026v : gp[u]) { if (vis[v]) continue; vis[v] = true; if (!match[v] || dfs(match[v])) { match[u] = v, match[v] = u; return true; } } return false; } // 主函数里 fill_n(match, n + 1, 0); // n是点的个数 for (int i = 1; i \u003c= n; ++i) { if (match[i]) continue; fill_n(vis, n + 1, false); dfs(i); } ","date":"2021-03-15","objectID":"/2021/03/%E4%BA%8C%E5%88%86%E5%9B%BE/:2:1","tags":["图论"],"title":"二分图","uri":"/2021/03/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["总结"],"content":"FHQ Treap ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:0:0","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"简介 fhq treap主要有两个操作：分裂、合并 作为平衡树，他所有的平衡树操作都是基于这两个操作实现的 ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:1:0","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"关于结点的存储与生成新的结点 由于一个结点要维护挺多信息的，所以用结构体来存储一个结点会比较好 如代码，存放的有：结点的权值、左孩子、右孩子、子树的大小、关键值（用随机函数赋值）,其中左右孩子值为0代表是叶子，即无内存池编号 const int N = 4e5 + 10; struct treap{ int val, l, r, size, key; }fhq[N]; 而生成一个新的结点和主席树的动态开点是有点像的，看代码就能懂了 int root, cnt; // 因为只有一棵树，所以只要一个root记录树的根节点就行了，cnt为内存池 mt19937 rnd(233); // 随机函数，头文件 random int new_node(int val) { fhq[++cnt] = {.val = val, .l = 0, .r = 0, .size = 1, .key = rnd()}; return cnt; } 注意，由于我们多维护了一个树的大小，固我们还要写一个更新结点的函数 inline void update(int now) { // 左孩子的大小 + 右孩子的大小 + 1 fhq[now].size = fhq[fhq[now].l].size + fhq[fhq[now].r].size + 1; } ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:2:0","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"分裂 分裂操作有两种 第一种是按照权值分裂，一边分裂成小于等于某个值的，另一边分裂成大于某个值的 具体细节看代码 void split(int now, int val, int \u0026x, int \u0026y) { // 分裂成x y两棵treap树 if (!now) { x = y = 0; return; } // 如果当前结点为空，则不作分裂 // 如果当前结点的值小于等于分裂要求的值，则让x树接上当前结点，并递归下去找当前结点的右孩子和y树应该拼接哪个结点 if (fhq[now].val \u003c= val) x = now, split(fhq[now].r, val, fhq[now].r, y); else y = now, split(fhq[now].l, val, x, fhq[now].l); // 否则同理 update(now); // 因为分裂了，记得更新 } 第二种就是按照数的大小分裂 待补…… ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:3:0","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"合并 合并的话也不难 显然刚刚分裂时分裂出来的x和y，x树上的所有权值都小于y树上的权值 具体细节看代码（以大根堆为例） int merge(int x, int y) { if (!x || !y) return x | y; // 大根堆 if (fhq[x].key \u003e fhq[y].key) { //如果x的key值大于y的key值，则根据堆和平衡树的性质 fhq[x].r = merge(fhq[x].r, y), update(x); // 让x的右子树为（x的右子树和y合并的结果的根）， 记得更新结点 return x; // 返回合并后的根结点的内存池的编号 } // 否则同理 fhq[y].l = merge(x, fhq[y].l), update(y); return y; // 返回合并后的根 } ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:4:0","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"平衡树的基本操作 ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:5:0","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"1、插入 首先先将整棵平衡树分裂成$\\le val$的x子Treap树和$\u003eval$的y子treap树 然后再新建一个权值为$val$的结点 让x和新结点合并，再和y合并 inline void insert(int val) { int x, y; split(root, val, x, y); root = merge(merge(x, new_node(val)), y); } ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:5:1","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"2、按值删除 将整棵树分裂成x、y、z，分别为$\u003cval$、$=val$、$\u003eval$ 然后将y的根结点删除 最后再合并回去 inline void del(int val) { int x, y, z; split(root, val, x, z); // 分裂1 split(x, val - 1, x, y); //分裂2 y = merge(fhq[y].l, fhq[y].r); // 删除y的根结点 root = merge(merge(x, y), z); // 最后合并回去 } ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:5:2","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"3、按值获取排名 将整棵树分裂成x（$\u003c val$）和y（$\\ge val$） $val$的排名就是x的数的大小+1 inline int getrank(int val) { int x, y, ans; split(root, val - 1, x, y); // 分裂 ans = fhq[x].size + 1; // 记录答案 root = merge(x, y); // 合并回去 return ans; } ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:5:3","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"4、按排名获取值 获取一个排名其实就是找一棵子树的左子树大小 + 1为rank 从根结点一直往下找就可以了 inline int getval(int rank) { int now = root; while (now) { if (fhq[fhq[now].l].size + 1 == rank) break; // 找到了 else if (fhq[fhq[now].l].size \u003e= rank) now = fhq[now].l; // 在左子树上 else rank -= fhq[fhq[now].l].size + 1, now = fhq[now].r; // 寻找右子树记得改动排名 } return fhq[now].val;//最后的答案 } ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:5:4","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"5、求一个数的前驱或后继 找$val$的前驱只需要将整棵树分裂成x（$\u003c val$）和y（$\\ge val$） 然后x树中的最大值就是$val$的前驱，一直往右子树找就可以了 后继的找法同理 // 求前驱 inline int pre(int val) { int x, y; split(root, val - 1, x, y); int now = x; while (fhq[now].r) now = fhq[now].r; root = merge(x, y); return fhq[now].val; } // 求后继 inline int nxt(int val) { int x, y; split(root, val, x, y); int now = y; while (fhq[now].l) now = fhq[now].l; root = merge(x, y); return fhq[now].val; } ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:5:5","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"完整代码 // 洛谷板子题 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003crandom\u003e#include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } using namespace std; const int N = 4e5 + 10; mt19937 rnd(233); struct treap{ int val, l, r, size, key; }fhq[N]; int root, cnt; inline void update(int now) { fhq[now].size = fhq[fhq[now].l].size + fhq[fhq[now].r].size + 1; } int new_node(int val) { fhq[++cnt] = {.val = val, .l = 0, .r = 0, .size = 1, .key = rnd()}; return cnt; } void split(int now, int val, int \u0026x, int \u0026y) { if (!now) { x = y = 0; return; } if (fhq[now].val \u003c= val) x = now, split(fhq[now].r, val, fhq[now].r, y); else y = now, split(fhq[now].l, val, x, fhq[now].l); update(now); } int merge(int x, int y) { if (!x || !y) return x | y; // 大根堆 if (fhq[x].key \u003e fhq[y].key) { //右下角 fhq[x].r = merge(fhq[x].r, y), update(x); return x; } // 左下角 fhq[y].l = merge(x, fhq[y].l), update(y); return y; } // 插入 inline void insert(int val) { int x, y; split(root, val, x, y); root = merge(merge(x, new_node(val)), y); } // 按值删除 inline void del(int val) { int x, y, z; split(root, val, x, z); split(x, val - 1, x, y); y = merge(fhq[y].l, fhq[y].r); root = merge(merge(x, y), z); } // 按值获取排名 inline int getrank(int val) { int x, y, ans; split(root, val - 1, x, y); ans = fhq[x].size + 1; root = merge(x, y); return ans; } // 按排名获取值 inline int getval(int rank) { int now = root; while (now) { if (fhq[fhq[now].l].size + 1 == rank) break; else if (fhq[fhq[now].l].size \u003e= rank) now = fhq[now].l; else rank -= fhq[fhq[now].l].size + 1, now = fhq[now].r; } return fhq[now].val; } // 求前驱 inline int pre(int val) { int x, y; split(root, val - 1, x, y); int now = x; while (fhq[now].r) now = fhq[now].r; root = merge(x, y); return fhq[now].val; } // 求后继 inline int nxt(int val) { int x, y; split(root, val, x, y); int now = y; while (fhq[now].l) now = fhq[now].l; root = merge(x, y); return fhq[now].val; } int main() { int t = IO(); while (t--) { int q = IO(), val = IO(); if (q == 1) insert(val); else if (q == 2) del(val); else if (q == 3) printf(\"%d\\n\", getrank(val)); else if (q == 4) printf(\"%d\\n\", getval(val)); else if (q == 5) printf(\"%d\\n\", pre(val)); else printf(\"%d\\n\", nxt(val)); } return 0; } ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:6:0","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"寒假cf刷题 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:0:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf478B Random Teams(*1300) 求参赛员的朋友数 贪心就好，最少的情况就是均分，最多的情况就是其余m-1队都只有1人的情况 总结：找找规律，大胆猜测：最大和最小一定是两个极端。做的时候读不懂题目，后来靠样例猜出的题目的意思。 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:1:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1463B Find The Array(*1400) 给定一个长度为n的数组a，总和为s，求一个同长的数组b，使其和给定的数组每个对应的数的绝对值即$a_i - b_i$的二倍小于等于s，并且对于每一对相邻的数$b_i$和$b_{i+1}$要么$b_i % b_{i+1} == 0$要么$b_{i+1} % b_i == 0$ 我的思路：不难发现目的就是为了使得$a_i - b_i$尽可能的小，那就很容易想到可以使其直接为0，然后又要满足相邻的可以被除的条件，则可是在奇数（或者偶数）下标取$a_i$，在偶数（或者奇数）下标取1，这样的话只需要求出给定数组的奇数下标的和与偶数下标的和，对比大小来决定到底是奇数放1还是偶数放1了 大佬的思路：对于b数组让每个数都是2的k次幂即$2^k,k\\ge0$，并且保证$2^k \\le a_i$ 总结：回归本质，思考题目设置的限制条件的意义，从那里出发思考，同时可以自己举例子 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:2:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1453B Suffix Operations(*1400) 给一个数组，有操作：选取一个下标i，将i（包括i）之后的所有数加一或者减一，你有一次可以把任何数变换的机会，问你将所有数变成一样的最小操作数（不包括变换的那个操作） 去除那个变换的机会，（大胆猜测）不难发现如果要将所有数变成一样的，所需要的操作顺序是任意的，其最小的操作次数就是相邻两个数的差值的绝对值之和。对于那个把任意数变换的一次机会我们可以将一个数变成其前面的数或者后面的数以减小差值绝对值。做法求一下差值的绝对值的和，之后再暴力遍历每一个数，要么变成前面的数，要么变成后面的数，最后取一个最小值就行了 总结：将问题分解一步一步地找到解决问题的方法，还可以大胆猜想出一个结论出来，证明无误后，利用这个结论来解题 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:3:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1408B Arrays Sum(*1400) 给一个单调不减且数组a，求一个数组组，数组组中的每个数组的也要是单调不减且不同数的个数不超过k，并且数组的下标i的总和正好为$a_i$，输出最小的数组组的大小，无解输出-1 纸上模拟，反向推演找数组组，不难发现若要个数不超过k，除了第一次，之后的每次最多能使k - 1个数变为0，而第一次能使k个数变为0（包括本来的0）。所以最终得到的公式就是$k + (k - 1) * num \\ge dif$，其中dif为a数组不同数的个数，num为答案。不难发现若$dif \u003e k$则无解 总结：想清楚题目要我干嘛，寻找规律，大胆猜想，纸上推演，理清思路，排除不必要的干扰，防止思维混乱。 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:4:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1393B Applejack and Storages(*1400) 起初你有n根木棍，有q询问，每次询问都添加一根或者去除一根，同时你要回答每次添加或者去除后能否组成一个正方形和一个长方形（正方形也是长方形） 正难则反，不难发现要一个正方形必须要4根同长的木棍，一个长方形要1对2根同长的木棍;我的做法：用三个set分别存放个数为1，个数为2和3的，个数为不低于4的，剩下的就是模拟了。大佬的做法：用两个变量记录个数是2的倍数的two，和个数为4的倍数的four，无论是询问还是原本有的木棍，假设成一根一根添加，一旦添加到为2的倍数则two自增，一旦添加到为4的倍数则four自增，最终答案就是$four \\ge 2$或者$four \\ge 1 \u0026\u0026 two \\ge 3$就能达到目的 总结：我的思路是比较贴近现实生活中遇到此问题时我们会怎么解决来思考的，大佬的做法是在此基础上加上更加妙的实现做法 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:5:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1365C Rotation Matching(*1400) 给你两个长度相等为n的排列数组a和b，问题经过平移后最多有多少个相等的数下标能对应上 仔细思考不难发现：假设平移b数组，并且只能向一个方向平移，若$a_i$和$b_j$相等，要使其位置对应，则平移的位置就是$(i - j + n) % n$，最终就是求相同平移量的个数最大值 总结：从本质出发，不用考虑太多算法，就是纯思维 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:6:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1144D Equalize Them All(*1400) 给你一个数组，你能选择相邻的两个数$a_i$和$a_{i+1}$进行操作:$a_i = a_i + |a_i - a_{i+1}|$或者$a_i = a_i - |a_i - a_{i+1}|$，问你最小的操作数使得数组所有数都相等，输出方案 贪心就好，首先纸上推演，题中给的操作能够实现将一个数变成另一个数，然后就是大胆贪心，最小的操作次数一定是数组中所有的数最终变成原本数组的众数，利用发现的规律来使得所有数都变成那个数便可以了 总结：大胆猜想，然后验证，目前主要障碍就是读题，还有码代码时候优先选择思路清晰的码代码方式，基本内存可能很大，wa了之后人肉跑一遍代码检查，还是查不出就举反例 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:7:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1355D Game With Array(*1400) 请你求一个长度为n的数组，其总和为s，输出一个k，使得你求的数组没有一个子数组的总和为k，若无解输出NO，否则输出YES和数组和k 仔细思考一下，贪心，最极端的就是n-1个1，设剩下一个就是x = s - (n - 1)，不难啊发现x到s范围的都可以组合出来，若$n - 1 \\ge x - 1$，则说明1到n-1都能组合出来，即无解，否则有解 大佬思路：让所有数都大于等于2，最后k = 1，便可。至于无解情况就是$s \u003c n * 2$ 总结：大胆猜想，贪心，从极端情况考虑 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:8:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1348B Phoenix and Beauty(*1400) 给你一个长度为n的数组a，求一个数组b，数组a是数组b的子序列，数组b的所有长度为k的连续子序列的和总是一样，有解输出数组b，无解输出-1 不难发现，要让b数组的长度为k的连续子数组和总是相等，其实只要让其一直循环长度为k的数组就好了，对于数组a是数组b的子序列也不难处理，显然若要有解就是a数组中的不同个数不得超过k 总结：这题不是很难，但是要注意细节，有些时候检查代码人肉跑一次是非常必要的，在一定不会超时的前提下怎么方便怎么来，stl放心用 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:9:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1316B String Modification(*1400) 给你一个字符串，你可以操作：从左到右遍历，每k个就进行翻转。让你计算一个最小的k，操作后字典序最小 观察不难这样的操作，其实就是把从下标为k - 1开始到最后的子串平移到最前面，然后就是将0到k-2下标的补到后面，若k-1之后的个数为奇数，则需要将0到k-2的子串进行翻转再补到后面 总结：这题不难，但是字符串的处理有点麻烦，同上题一样，不超时放心用stl的东西 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:10:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1270C Make Good(*1400) 给你一个数组a，让你添加不超过3个数，使得$a_1 + a_2 … a_n = 2\\times(a_1 \\bigoplus a_2 … \\bigoplus a_n)$ 纸上推演，利用异或的特性可以推出第一次异或本来的异或和使等式右边为0，再来就是异或左边加上刚刚的异或值的和，便是答案，可见这个方法只要加两个数便可以了 总结：本题不难，思考问题从位运算的特性中思考，还有就是注意此题会爆int ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:11:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1266C Diverse Matrix 你需要求出以个$r\\times c$的矩阵，并且对于矩阵的每一行每一列的最大公因数都不一样，让你求最小化这个矩阵中行列的最大公因数的矩阵 此题有点偏数学，在纸上推理，不难发现：最小的最大公因数一定是r + c，然后就是反向推演，不难发现对列和行从1到r+c编号，然后对于矩阵上的一个数要满足题意只需要求出对应编号的最小公倍数即可，但需要注意的是编号优先从行数和列数中小的开始，例如行数比列数少，则编号需要从行开始 总结：纸上推演，大胆猜想，然后简单验证和人肉debug ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:12:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"1. 写在前面的话 之前写了一篇不像总结的动态规划总结，感觉更像是一个成长历程，所以就打算重写一篇。 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:1:0","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"2. 对DP简单的总结 dp的题目特点： 求最大或者最小值（如背包：价值最大、凑硬币：数量最少……） 计数（如：爬楼梯：计算上到n台阶的方法数） 求存在性或者胜负（如：能否胜利……） dp的使用条件 拥有子问题，子问题最优解（即拥有最优子结构），对于一个原问题解最优，其子问题必定也是最优，同时原问题的最优解依赖于其子问题的最优解 子问题重复性，一个子问题可能会影响多个不同的下一阶段的原问题 无后效性，即此时的之前状态无法直接影响未来的决策，换句话说就是之前的每个状态如何得来并不影响未来对此时（当前）状态的利用或者查找，因为我们最后对此时（当前）状态的利用只考虑结果不考虑过程。 dp的思考方式及注意事项 若问题有dp的味道，应当优先从主问题出发来思考，即从末尾（结果）开始思考（例如爬楼梯问题） 接下来，对于一个主问题，应当思考此问题的结果由什么得来（由什么决定、怎么决策等）和有什么因素影响 或者思考此问题类似什么DP题（如:背包、LIS……） 实在想不出可以思考如果是用dfs（或普通递归），应当如何解决问题（个人觉得有时候道理是相同的，记得吗：递归 + 记忆化 = 递推） 注意1：在思考一个状态的得来时，目光应当只集中在此时的状态（无后效性），而不要多想之前的状态变化和未来的状态影响 注意2：状态的定义很重要，要结合题目需求和状态影响因素来定义 关于dp三步走 1.状态定义 → 2.列状态转移方程 → 3.验证方程 对于第一步和第二步主要可以利用上述的思考方式或者是闫氏DP分析法来解决 第三步虽然不难，但是很重要，因为第三步包括：验证状态推理是否合理或者是否是答案最优，并且思考状态是否满足题目条件需求，前者均没问题后再思考边界是什么。对于一般验证发现有问题通常的解决办法有：1、修改状态定义；2、给状态增加维度；3、优化转移方程 补充的话 读了紫书上的动规篇才开始补这篇博客的坑 学到了很多东西，包括用记忆化搜索的优势、刷表法、DAG模型等等 所以有些代码写的不是递推的方式是为了练习记忆化式的递归 阅读了紫书动规篇后彻底抛弃了递推就一定比记忆化递归还快的观念，也使我再一次对自己当年总结的dp思考方式（递推 = 递归 + 记忆化）感到肯定 先来说说记忆化的优势： ①便于思考，有时完全都不用所谓的状态转移方程，只需要考虑当选状态下如何选择下一步的策略来进行码代码，在比赛的时候这个优势是非常大的 ②有些题无法用递推的方式来写，甚至状态都可能是无限的，这时候记忆化的优势将会进一步地放大 ③用记忆化不一定就比递推慢，仔细思考一下，有时候有些状态是不用计算的，而记忆化在这方面会比全部计算出来的递推要好，固速度不必递推差 记忆化的技巧 多开一个数组来做记忆化的操作比将状态数组定义成特殊值来判定是否又有算过好一些，不仅能够增强可读性，还更方便调试操作 如果状态做记忆化用另开数组的方式还是麻烦，不妨试试用map来存被算过的状态 用引用来调用状态数组可以简化代码 刷表法 和刷表法相对的是填表法，所谓填表法我的理解就是传统的利用之前选好的状态来计算当前的状态，书中是这么说的“对于每个状态i，计算f(i)，这需要对于每个状态i都找到f(i)的依赖的所有状态” 正如书中的一句话“在某些时候并不方便”，即找f(i)的所有依赖状态不好找，于是就诞生了刷表法 所谓刷表法，我的理解就是用计算好的状态更新它所影响到的状态，书中原话“对于每个状态i，更新f(i)所影响到的状态，但需要注意的是，只有当每个状态所依赖的状态对它的影响相互独立时才能用刷表法”，后半句话我也不是很理解，以后遇到了能理解的对应的题再说 DAG模型 动态规划能够概括出DAG模型是紫书动态规划篇给我最大的惊喜，巧妙地把我之前总结的那繁多的模型分类大大地再次概括了一遍 DAG模型有点像刷搜索题时一般，将题目抽象成一个有向无环图，然后求解最大距离或者是最小距离 个人感觉由于有时太过抽象，所有很难把它的图给抽象出来 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:2:0","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"3. 几个重要的模型 上图中有很多模型都可以归类为DAG模型（习得紫书后才了解到的），但是有些是完全可以单拿出来作为经典模型的 借用陈峰老师的一句话：子结构状态形成的如果是一棵树，不就是搜索了吗，如果是一个图，不就是动态规划了吗 原话是这个意思，感触很深，确实，有些题遇到了把他抽象出来如果是一颗树，基本应该优先考虑dfs、bfs等搜索操作，如果是一个图，即有重复的子结构，就可以考虑动规了 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:3:0","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"数塔模型 这个模型是许多人动规入门的题，变种不多，但是却很经典 【例题】HDU 2084 数塔 题意：有一个树形的塔，每个节点都有权值，让你求出从根节点到最后一层叶子节点的的最大权值和 简单的分析 这题是不能贪心的，即不能只选出当前最大的叶子权值 假设已经算好了第2层的节点的最大权值和，则第1层的节点（根节点）的最大权值就为第二层的两个节点的最大权值和加上第一层的权值 其余节点也可假设成第一层和第二层来思考 所以设$dp[ i][ j]$为第i层的第j个节点的最大权值和，边界条件就是最后一层的最大权值和就是其本身 状态转移方程如下 $$ dp[i][j] = max(dp[i - 1][j],\\ \\ dp[i - 1][j + 1]) + tree[i][j] $$ 发现空间还是可以优化的，因为当前层数的dp值利用的只有下一层的dp值，而数组的的第二维计算时利用的是后面的（j + 1）的值，所以第二维是下标小的先更新，下标大的后更新，所以完全可以把第一维抛弃掉，但这样的话dp下标循环起来必须是从小到大循环 状态转移方程如下 $$ dp[j] = max(dp[j], dp[j + 1]) + tree[i][j] $$ 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003cvector\u003e using namespace std; int c, n; int main() { scanf(\"%d\", \u0026c); while (c--) { scanf(\"%d\", \u0026n); int tree[110][110] = {0}; for (int i = 0; i \u003c n; i++) for (int j = 0; j \u003c= i; j++) scanf(\"%d\", \u0026tree[i][j]); int *dp = new int[n]; for (int i = 0; i \u003c n; i++) { dp[i] = tree[n - 1][i]; } for (int i = n - 2; i \u003e= 0; i--) for (int j = 0; j \u003c= i; j++) dp[j] = max(dp[j], dp[j + 1]) + tree[i][j]; printf(\"%d\\n\", dp[0]); } return 0; } ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:3:1","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"凑硬币模型 凑硬币模型是一个经典的模型，题目大概就是给你一个目标，你有许多不同的结构，你要用这些结构来组成这个目标，让你求最大组成量、最小组成量或者是组成方法数（组成方法数可以说是爬楼梯模型） 【例题1】leetcode 322 零钱兑换 大致题意：给你不同面额的硬币，让你输出凑成价值n的最小使用数量，若无法凑成则返回-1 这题就是一个凑硬币的板子题 简单分析： 假如你有1 2 5的硬币，假设你已经求出$x$的最小使用数量$y$，则就能算出 $x + 1$ 、$x + 2$ 、$x + 5$ 的最小使用数量，即都为 $y + 1$ 设 $dp[ x]$ 表示价值为x的最小凑的数量，边界的话显然，$x = 0$ 时最小要凑的数量为 $0$，所以边界就是 $dp[ 0] = 0$ 所以不难得出状态转移方程 $$ dp[ x] = min \\lbrace dp[ x - coins[ i]] + 1 \\rbrace ,\\ \\ x \\ge coins[ i],\\ \\ i = 0, 1, 2 \\cdots $$ 代码如下 class Solution { public: int coinChange(vector\u003cint\u003e\u0026 coins, int amount) { vector\u003cint\u003e dp(amount + 1, 0x3f3f3f3f); dp[0] = 0; for (int i = 0; i \u003c= amount; i++) { for (auto c : coins) { if (i \u003e= c) dp[i] = min(dp[i - c] + 1, dp[i]); } } if (dp[amount] == 0x3f3f3f3f) return -1; return dp[amount]; } }; 【例题2】leetcode 279 完全平方数 大致题意：平方数{1, 4, 9, 16 ……}，给你一个数n，让你用平方数组成该数，求最小组成数量 简单的分析： 把平方数看成硬币，然后就是硬币题了 状态转移方程一样的，直接上代码 class Solution { public: int numSquares(int n) { vector\u003cint\u003e dp(n + 1, 0); dp[0] = 0; for (int i = 1; i \u003c= n; i++) { dp[i] = dp[i - 1] + 1; for (int j = 2; i - j * j \u003e= 0; j++) { dp[i] = dp[i] \u003e (dp[i - j * j] + 1) ? dp[i - j * j] + 1 : dp[i]; } } return dp[n]; } }; ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:3:2","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"LIS模型 LIS就是所谓的最长不下降子序列问题，变种不多，但很经典，所以直接看例题 【例题1】leetcode 300 最长上升子序列 题意：给定一个无序的整数数组，找到其中最长上升子序列的长度，注意严格上升 简单的分析： 分享一下一开始我学动规的时候LIS定义的状态是dp[i]表示下标为i的数组之前的最长上升子序列（即可以不选$nums[i]$），但是这样来定义我发现很难进一步地对状态进行转移，后来还是妥协了书中的状态定义方式 这件事现在看来也是有点感慨，因为现在的我明白：状态定义的不同，转移的方式可能也会完全不一样，所以有时候不同的状态定义会影响转移的难易程度，在思考一道动规题时，如果发现状态难以转移，不妨试试换个状态定义 设dp[i]表示选择下标为i的数为结尾的最长子序列，这样做的好处就是方便后面的转移，方便利用当前下标数和之前算好的dp状态的下标数进行对比大小，可以想象成当前状态是和之前算好的状态进行拼接 则转移方程为 $$ dp[i] = max\\lbrace 1,\\ \\ dp[j] + 1 \\ \\ | \\ \\ 0 \\le j \u003c i, nums[j] \u003c nums[i] \\rbrace $$ 不难发现，状态转移需要利用到下标为j的原数组的数，所以这个说明了状态定义就很重要了 最终的答案就是取其中的最大值 这种做法的时间复杂度是O($n^2$)，当然还有更快的速度可以达到O($nlogn$)，这里不再赘述了 dp代码如下 class Solution { public: int lengthOfLIS(vector\u003cint\u003e\u0026 nums) { int len = nums.size(), Max = 0; vector\u003cint\u003e dp(len, 1); for (int i = 0; i \u003c len; i++) { for (int j = 0; j \u003c i; j++) { if (dp[i] \u003c dp[j] + 1 \u0026\u0026 nums[j] \u003c nums[i]) dp[i] = dp[j] + 1; } Max = max(Max, dp[i]); } return Max; } }; ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:3:3","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"LCS模型 LCS就是最长公共子序列，也很经典 【例题1】AcWing 897. 最长公共子序列 题意：给你两个长度分别为n、m的字符串，让你求最长的公共子序列有多长 简单的分析： 设a序列的字符分别为$a_1, a_2,a_3……a_n$，b序列的字符分别为$b_1, b_2, b_3……b_m$ 假如序列a为ab，b为a，则他们的LCS就是1，注意到，如果b序列后面加个b变为ab，则LCS就是2，但如果加的是c变为ac，则LCS则还是1 设$dp[i][j]$表示a序列长度为i，b序列长度为j时的LCS，假设已经求出了之前的状态，则当$a_i = b_j$时，则$dp[i][j] = dp[i - 1][j - 1] + 1$，即LCS长度加一，但如果不相等，则$dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])$，不难看出这个转移方程的意义，下面上一个图更好理解 其中红色是a序列的各个字符，橙黄色是b序列的各个字符，表格中的数字是相对应的LCS 代码如下 #include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; int n, m, dp[1010][1010]; char a[1010], b[1010]; int main() { scanf(\"%d%d%s%s\", \u0026n, \u0026m, \u0026a[1], \u0026b[1]); for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { if (a[i] == b[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } printf(\"%d\", dp[n][m]); return 0; } ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:3:4","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"背包模型 背包问题是经典的一类动规问题 篇幅过长已搬出（传送门） ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:3:5","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"DAG模型 DAG模型是一个概括非常广的模型，它包括凑硬币模型、背包模型等等，但还是要写写，因为我觉得DAG更多的是一种思想，把DP问题抽象成一个DAG的图，便于思考 【例题1】UVA 1025 A Spy in the Metro 大致题意：一个线性的地铁，有$n(2 \\le n \\le 50)$个站，目标是在$T(0 \\le T \\le 200)$时刻从1号站到n号站，注是规定刚好T时刻，不是在T时刻之前也不是在T时刻之后，从1号点出发，可以在途中转乘，问你最少的中途等车时间 第i站到第i + 1站需要花的时间为$t_i$ 有$M1(M1 \\le 50)$个车从1号站出发，出发时间分别为$d_1, d_2, d_3……, d_{M1}\\ \\ (d_i \u003c d_{i + 1}, d_i \\le 250)$，同样有M2个车从n号站出发，时间格式同上 其余细节看题 简单分析： 就看当先的状态，假设现在的时间是tim，正在第p个站有三种策略 等1分钟，剩下的下一分钟再说 如果有向1号站行的车，乘坐上去 如果有向n号站行的车，乘坐上去 那么这个是怎么建立DAG图的呢，对于每个点，定义它包括的属性有时间和站点，如果当前时间当前站点有开往下个一或者上一个站的车，则将到站的时间和对应的站点连一条有向的边，例如当前时间是15，站点是3，并且有开向第2站点的车，10单位的时间后到达，但没有向下一个站开的车，则在属性为（15，3）的节点连一条有向边到（25，2）的节点， 当然千万别忘了一点就是下1单位时间的同一站点也有一条边，即（15，3）到（16，3）也有一条有向边 然后就可以利用这个DAG图的节点属性来定义状态了，即设dp[p][tim]为在p站点tim时刻的状态，既然是求最小路，则状态就是到当前节点的最短路 对应三种策略的状态转移方式 当前的状态等于下一单位时间的状态加1的等待时间 当前状态等于到站后的时间和站点的状态 同上 最后取一个最小值 边界条件就是如果在T时刻和n站点刚好到达，则返回0，因为不用等了，如果超过了T时间，则说明是从某个站点到另一个站点后时间过了，则返回无穷大表示不用等了，如果刚好到T时刻且没到达n站点，则说明后面再怎么坐车时间也过了，也返回无穷大 说了这么多，却没写状态转移方程是因为打算使用记忆化来做，所有不用转移方程，直接考虑当前递归的来自哪些结果就好了 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e using namespace std; const int INF = 0x3f3f3f3f; int n, T, t[100], kase = 0, dp[110][210]; bool has_train[110][210][2], vis[110][210]; bool read() { int m, x; scanf(\"%d\", \u0026n); if(!n) return false; scanf(\"%d\", \u0026T); for (int i = 1; i \u003c n; i++) scanf(\"%d\", t + i); memset(has_train, 0, sizeof has_train); memset(vis, 0, sizeof vis); scanf(\"%d\", \u0026m); for (int i = 0; i \u003c m; i++) { scanf(\"%d\", \u0026x); has_train[1][x][0] = true; for (int j = 2; j \u003c= n; j++) { has_train[j][x + t[j - 1]][0] = true; x += t[j - 1]; } } scanf(\"%d\", \u0026m); for (int i = 0; i \u003c m; i++) { scanf(\"%d\", \u0026x); has_train[n][x][1] = true; for (int j = n - 1; j \u003e= 1; j--) { has_train[j][x + t[j]][1] = true; x += t[j]; } } return true; } int DP(int p, int tim) { int \u0026d = dp[p][tim]; if (tim \u003e T) return INF; if (tim == T) return p == n ? 0 : INF; if (vis[p][tim]) return d; vis[p][tim] = true, d = INF; d = DP(p, tim + 1) + 1; if (p \u003c n \u0026\u0026 has_train[p][tim][0]) d = min(d, DP(p + 1, tim + t[p])); if (p \u003e 1 \u0026\u0026 has_train[p][tim][1]) d = min(d, DP(p - 1, tim + t[p - 1])); return d; } int main() { while (read()) { int ans = DP(1, 0); if (ans \u003e= INF) printf(\"Case Number %d: impossible\\n\", ++kase); else printf(\"Case Number %d: %d\\n\", ++kase, ans); } return 0; } 【例子2】UVA 437 The Tower of Babylon 题意：给你n种有无数个的立方体，现在让你用这些立方体堆一个塔，每个立方体的底面长宽都要严格小于下面立方体的底面长宽，问你最高能堆多高 简单的分析 能看得出来是一个矩形嵌套的变种问题，用DAG模型建立来做会非常好码代码 一种立方体有三种摆放方式，假设一个立方体的长宽高为a、b、c，则三种摆放方式分别是以a、b、c为高的摆放方式，固一种立方体可以看成三个立方体 下面就是建立DAG了，如果一个立方体的底面长宽严格大于另一个底面长宽的立方体则连一条有向边过去 最后就DP就是求从某个节点出发的最大距离就是答案 注意到，无论是思考还是码代码都不需要再去想状态方程来，直接当成一个图求最远距离来做，为了加速，我用了邻接表来建立图 下面是代码 #include \u003ccstring\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; int n, kase = 0, head[100], cnt = 0, dp[500], vis[500]; struct rect{ int a, b, c; rect(){} rect(int a, int b, int c) : a(a), b(b), c(c) {} }r[100]; struct edges{ int to, next; edges(int to = 0, int next = -1) : to(to), next(next) {} }edge[10010]; bool ok(const rect\u0026 x, const rect\u0026 y) { return (x.a \u003e y.a \u0026\u0026 x.b \u003e y.b) || (x.b \u003e y.a \u0026\u0026 x.a \u003e y.b); } void add_edge(int u, int v) { edge[++cnt] = edges(v, head[u]); head[u] = cnt; } bool read() { scanf(\"%d\", \u0026n); if (!n) return false; int x[3]; for (int i = 0; i \u003c 3 * n;) { for (auto \u0026j : x) scanf(\"%d\", \u0026j); r[i++] = rect(x[0], x[1], x[2]); r[i++] = rect(x[0], x[2], x[1]); r[i++] = rect(x[1], x[2], x[0]); } memset(head, -1, sizeof head); memset(edge, 0, sizeof edge); memset(dp, 0, sizeof dp); memset(vis, 0, sizeof vis); cnt = 0; for (int u = 0; u \u003c 3 * n; u++) { for (int v = 0; v \u003c 3 * n; v++) { if (u == v) continue; if (!ok(r[u], r[v])) continue; add_edge(u, v);//邻接表建图 } } return true; } int DP(int u) { if (u \u003e= 3 * n) return 0; if (vis[u]) return dp[u]; int \u0026res = dp[u], Max = 0; res = r[u].c, vis[u] = true; for (int v = head[u]; ~v; v = edge[v].next) {//它的下一个节点 Max = max(Max, DP(edge[v].to)); } return res += Max; } int main() { while (read()) { int ans = 0; for (int i = 0; i \u003c 3 * n; i++) ans = max(ans, DP(i)); printf(\"C","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:3:6","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"4. 分类 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:4:0","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"① 线性DP ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:4:1","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"② 区间DP 区间dp一般是将状态定义成某某区间内的某个解 一般遍历方式 for(int len = 1; i \u003c= n; ++i) { // 先枚举区间长度 for (int i = 1, j = i + len - 1; j \u003c= n; ++j, ++i) { // 再枚举起始节点 // } } for(int i = n; i \u003e= 1; --i) { // 先枚举左端点 for (int j = i; i \u003c= n; ++j) { // 再枚举右端点 // } } ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:4:2","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"③ 树型DP 来自2021.3.22的更新，回来看了一下，以前的写博客也太蠢了吧，不想改了，直接看下面几篇博客[放博客链接] 所谓树状DP（树形DP）就是说一个动态规划的问题他的数据（或者子问题）之间是建立在树的基础上提问的，即父节点的最优是由其子节点的最优来推出来的（大部分是这样）。 【例题1】HDU 1520 Anniversary party 大致题意：一棵树，一共有n个节点，父节点和子节点不能同时选，每个节点都有权值，问怎么选权值总和最大 显然是要用到树DP了废话，给我的感觉有点像是一个变种的01背包问题不清楚 简单的分析： 对于一个节点有两种可能，选或者不选。那么我们就这样定义状态：dp[i][j], $1 \\le i \\le n$、 $0 \\le j \\le 1$，表示i节点的权值总和最大，$j = 0$表示不选择当前节点时的权值总和最大，$j = 1$表示选择当前节点时的权值总和最大 当一个节点选了之后，那么它的所有子节点都不能选（当然它的父节点也不能选，但是考虑到我们这题用dp来解，为了不扰乱思维，我们只看它和它的子节点），看图： 黄色为选，灰色为不选，父亲节点选了后，它下面的2、3、4、5、6……都不能选了（清楚明了），喂喂喂，你可别再想1号节点的父亲的事了，我们正在dp呢，它父亲节点以后它爷爷节点会搞定的，别再多想了，不然会扰乱思维。那么很容易得到这部分的转移方程(son[i]表示i的子节点, w[i]表示当前节点的权值)： $$ dp[i][1] = w[i] + \\sum dp[son[i]][0] $$ 如果这个节点不选呢？不说话，先看图： 还是一样：黄色为选，灰色为不选。可能有人很奇怪：“哎呀，为什么儿子还有不选的情况，既然父亲都不选了，那么他的儿子全选不就总和最大了吗”。别急，且听我慢慢道来，如果这个是一条链，那么你这种想法可能就是对的，但这个是一棵树，之所以会有这个疑惑是因为我的图没上画完呢。 说明：方形内的数字是节点的权值。显然如果要总和最大，那么5号节点就不能选，因为它的5号几点的子节点（8号节点）的权值更大（清楚明了😁）。所以又可以得到相应的转移方程： $$ dp[i][0] = \\sum max(dp[son[i]][1], dp[son[i]][0]) $$ 最后我这题采用的是自顶向下的递归来求的，最后根节点是通过回溯得来，当然如果喜欢自底向上的童鞋可以采用栈来遍历也可以哦。而我们的状态转移方程总结为 $$ dp[i][1] = w[i] + \\sum dp[son[i]][0]，\\ \\ (选择i节点) $$ $$ dp[i][0] = \\sum max(dp[son[i]][1], dp[son[i]][0]) \\ \\ (不选择i节点) $$ 那么最后的答案就是根节点的选和不选两状态的最大值,即 max(dp[root][1], dp[root][0])，（其余细节看注释）。 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cvector\u003e#define debug(n) printf(\"(%d)\", n); using namespace std; const int N = 6e3 + 10; int n, l, k, w[N], dp[N][2]; vector\u003cint\u003e son[N]; void dfs(int r) { dp[r][0] = 0, dp[r][1] = w[r]; //初始化，方便转移时的求和 for (auto s : son[r]) { //遍历所有子节点 dfs(s); //先求子节点的最优 //↓然后回溯↓ dp[r][1] += dp[s][0]; //当前节点选 dp[r][0] += max(dp[s][0], dp[s][1]); //当前节点不选 } } int main() { while (scanf(\"%d\", \u0026n) != EOF) { //不定组输入，输入节点数 vector\u003cint\u003e fa[N]; //记录节点的父亲，用来寻找根节点 for (int i = 1; i \u003c= n; i++) scanf(\"%d\", w + i); //输入节点权值 while (scanf(\"%d%d\", \u0026l, \u0026k) != EOF) { //输入节点之间的关系 if (l == 0 \u0026\u0026 k == 0) break; //结束输入 son[k].push_back(l); fa[l].push_back(k); } //寻找根节点 int root = 1; for (int i = 1; i \u003c= n; i++) { root = fa[i].size() == 0 ? i : root; } //开始转移 dfs(root); int ans = dp[root][1] \u003e dp[root][0] ? dp[root][1] : dp[root][0]; printf(\"%d\\n\", ans); //输出答案 //下面全是清空数组的代码，忽略就好 memset(dp, 0, sizeof dp); memset(w, 0, sizeof w); for (int i = 1; i \u003c= n; i++) { for (auto it = son[i].begin(); it != son[i].end();) it = son[i].erase(it); } } return 0; } 平均时间复杂度应该是O($n$) 空间复杂度是O(n)，，应该不是O($ n ^ 2$),因为用的是vector。 【例题2】HDU 2196 Computer 大致题意：给你一个棵无向树，每个相连的节点之间都有个距离，即边有权，让你求出每个节点距离该节点的最远节点的距离。 又是一道树状DP都放树状DP里了，怎么可能不是呢😂，但是这题是无向的，恰恰是因为这样给了一丝丝方便。 简单的分析 首先既然是无向，为了方便我们把他看作有向的，就设1号节点（1号电脑）是根节点，任性图方便。 每个节点，他只有两种状态（除根节点，和叶子节点），一、要么是从它的子节点过来的距离；二、要么不是从它的子节点过来。如图不画了，自己脑补😂。 那么我们就这样定义状态：dp[i][j], i表示的是节点编号（$1 \\le i \\le n$），而 j（$0 \\le j \\le 1$）的话就是，当 $j = 0$ 时表示 i 节点到其最远从属于它的叶子节点 （即他的子节点过来）的距离， $j = 1$ 时表示不是从它子节点过来的最远距离。 对于从子节点到来本节点的距离，只需要对比大小便可，为了方便思考，我把题目的例子改了一下，如图（这回有图啊！！） 说明：方形里的数字代表距离（边权）。不难看出从2号节点的子节点（7号节点、6号节点、3号节点）到2号节点的最大距离就是子节点到来的最大值（老规矩，别想他的父节点），有点拗口，看方程（son[i]表示 i 节点的子节点, len(son[i])则表示它的子节点到他它自己的距离）： $$ dp[i][0] = max\\lbrace dp[son[i]][0] + len(son[i])\\rbrace $$ 简单吧，下面就来看看比较难的：不是从他的子节点到来的最大距离。先上图（画的好累）： 清楚吧，不用解释了吧，好吧好吧，我们把目光放到3号节点上，如果计算不是从它子节点过来的距离的话，只有两种可能，其中最简单的一条路就是从它的爷爷节点来再到他的父亲节点来的距离（黄色箭头路线），为什么只有一条？因为它肯定只有一个爷爷和父亲，不可能有两个，不可能！！！这个世界还是很美好滴；第二种可能就是从它的兄弟节点来，这个比较多路（蓝色和绿色箭头路线），因为它可以有很多兄弟，也可以没有兄弟（独生子😁）。这样理解的话方程就能出来了（fa[i]表示 i 节点父节点，所以son[fa[i]]就代表 i 节点 的兄弟节点，len的含义和上面一样）： $$ dp[i][1] = max\\lbrace dp[fa[i]][1]+ len(i), dp[son[fa[i]]][0] + len(son[fa[i]]\\rbrace+ len(i)) $$ 化简一下 $$ dp[i][1] = max\\lbrace dp[fa[i]][1], dp[son[fa[i]]][0] + len(son[fa[i]])\\rbrace + len(i) $$ 解释：max内部的前者是上述的第一种可能，后者是第二种可能，是不是简单明了😁，但是对于这个状态还利用到来我们第一个讲的（$j = 0$）状态。所以我们在计算时要先把所有 $j = 0$ 的状态先计算，即做两遍dfs（当然你也可以把他们的dfs放到一起，都一样的，为了方便我不会😂我选择做两遍dfs），注意：这个状态方程的状态，即 $j = 1$ 时的状态一定要自顶向下计算，因为方程中还用到了它父亲的第二（$j = 1$）状态。所以最终的状态转移方程总结为： $$ dp[i][0] = max\\lbrace dp[son[i]][0] + len(son[i])\\rbrace， \\ \\ （第一种状态） $$ $$ dp[i][1] = max\\lbrace dp[fa[i]][1], dp[son[fa[i]]][0] + len(son[fa[i]])\\rbrace + len(i) \\ \\ （第二种状态） $$ 那么最后的答案是什么呢？显然就是每个节点的 $j = 0$ 和 $j = ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:4:3","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"④ 状态压缩DP 状态压缩更像是一种思想，而不是一种方法。当有些问题很可能不存在有效的(多项式级的)算法时，利用状态压缩是可以使得题目简单些。一般情况下状态压缩是把状态压缩成二进制的形式来表示（也有三进制的）一个集合，通过压缩可以把不必要的信息给去掉，从而减少冗余。 常见的二进制使用 都是最基础的：与、或、非、异或 在c++中分别是 \u0026（与）、|（或）、!（非）、^（异或） 左右移：« （左移），例如 5（00000101）« 1 = 10（00001010）； »（右移）,例如 5 （00000101）» 1 = 2 (00000010)。 取反：~（1 变 0，0 变 1），例如 ~ 00000101 = 11111010 查看是否有相邻的 1（状压用得多，多用来去掉不合法的状态）：x \u0026 (x » 1) == 0或者x \u0026 (x « 1) == 0：语句判断为真则没有相邻的1，否则有相邻的 1。例如 88（01011000）\u0026 44 (00101100) = 8 (00001000) $\\ne$ 所以有相邻的 1。（不懂就自己多举几个例子） 检查 a 是否是 b 的子集（状压也用得多）：a \u0026 b == a：语句判断真为是其子集，否则不是。例如 88 是 16 的子集，因为88（01011000）\u0026 16（00010000）= 16（00010000） 判断 a 和 b 是否有相同位的 1：a \u0026 b == 0：语句判断真为没有，否则有，很简单不解释 取末尾的 1：x \u0026 (-x)，例如 88（01011000）^ (-88)（10101000）= 8（00001000）——多用于树状数组 【例题 1】HDU 方格取数（1） 大致题意：给你一个方格，里面有数字，你可以在这些方格里面取数，但是不能取拥有公共边的方格，问你取出来的最大值为多少 一道挺标准的状压dp板子题，一开始用普通dp没做出来，后来发现用状压真的简单一些 简单的分析 对于每个格子只有两种状态：选或者不选，我们定义选中了则在相应的二进制位数为 1，否则为 0。例如5 （000101）表示一行中第一个数和第三个数被选中 对于一行有 n 个格子的总共的选择方式个数为 $2^n$ 既然都说了状压，那直接开压：把列压缩（对于这题行和列相同，压列是个人喜欢，更多情况下是压缩数据范围小的那个，你当然希望$2^n$越小越好啦） 下一步在输入之前把不合法的状态预处理了，只留下合法的，就是本题所说的不能选取拥有公共边的格子，即对于每一行状态不能有相邻的 1 然后是转移方程（很简单，并且不难想） $$ dp[i][now] = max\\lbrace dp[i - 1][pre] + w[now]]\\rbrace $$ 解释：i 表示第 i 行，now 表示当前行的二进制状态，pre 表示上一行的所有不与 now 具有相同位 1 的状态，可以用相与（\u0026）是否等于 0 来判断，若等于 0 则没有相同我位的 1，否则有；w[now]表示当前状态的选取方格的总值 那么最后的答案就是最后一行中的最大值 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; const int maxn = 25; unsigned int nums[maxn][maxn];//用无符型是因为HDU的尿性，不这样可能会超内存 vector\u003cunsigned int\u003e v;//用来存储合法的状态 int n; int val(int r, int v) {//求当前行状态的总价值 int res = 0, i = n; while (v != 0) { if (v \u0026 1) { res += nums[r][i]; } v \u003e\u003e= 1; i--; } return res; } int main() { while (scanf(\"%d\", \u0026n) != EOF) { v.clear(); //清空v数组 int choice = (1 \u003c\u003c n); //最大的状态数 for (int i = 0; i \u003c choice; i++) { if ((i \u0026 (i \u003c\u003c 1)) == 0) v.push_back(i);//预处理，选取合法的状态 } int len = v.size(); vector\u003cvector\u003cunsigned int\u003e\u003e dp(n + 1, vector\u003cunsigned int\u003e(len));//动态开辟数组，防止超内存 for (int i = 1; i \u003c= n; i++) {//输入 for (int j = 1; j \u003c= n; j++) { scanf(\"%d\", \u0026nums[i][j]); } } unsigned int Max = 0; for (int i = 1; i \u003c= n; i++) { for (int now = 0; now \u003c len; now++) { int w = val(i, v[now]); for (int pre = 0; pre \u003c len; pre++) {//枚举上一行的状态值 if ((v[now] \u0026 v[pre]) == 0) dp[i][now] = max(dp[i][now], dp[i - 1][pre] + w);//状态转移 } } } for (int i = 0; i \u003c len; i++) {//最后的结果 Max = max(Max, dp[n][i]); } printf(\"%d\\n\", Max); } return 0; } 表面上时间复杂度：O($n2^n2^n$),先别急，经过预处理，实际比这个小得多得多，每个$2^n$估计会被压到最大也就4000左右，据大佬测试 n 最大是17，不会有n = 20得样例；这下子复杂度就妥妥地能过了 空间复杂度：和时间复杂度同理，最大也就开个约为17 * 4000的数组 【例题2】洛谷 P1879 Corn Fields G 题目大意：给你一个M * N的方格土地，1 表示可以种玉米，0 表示不可以种玉米。拥有公共边的格子不能同时种上玉米，问你有多少种种的方式，什么都不种也算一种，答案对 1e8 取模 一道状压dp计数题，也是一个很好的板子题 简单的分析 M 和 N 的数据范围都很小，所以我还是采用了压缩列来做 要做的准备有：预处理本不合法的状态、把方格土地的01状态转换成十进制的表示，用个数组cor[i]来储存，方便后面判断是否能种、先把第一行合法的状态算了，把能种的且合法的都初始化为 1； 先看状态转移方程 $$ dp[i][now] += dp[i - 1][pre] $$ 解释：i 表示第 i 行，now 和 pre 分别表示当前行的状态和上一行的状态，当然 now 的前提是可以在当前行上种下来，即 now 是 cor[i] 的子集，而 pre 和 now 必须没有同位的 1 例如第 n 行，什么都不种（now = 0）的方法数就是上一行合法状态的和（其实所有和都可算，因为不合法的一定是0），而第 n 行状态 q 的种法的方法数就是上一行与他没有同位 1 状态的和（这里可以多一个判断，判断pre是否能在上一行上种起来，这样可以循环，当然不判断也行，因为不合法的一定为0） 最后的答案就是最后一行的dp和(稍微换了一下码风，可能会舒服点，因为循环和判断有点多) #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; const int M = 15, mod = 1e8; int m, n, nums[M], cor[M]; vector\u003cint\u003e v;//存储合法的状态 int main() { scanf(\"%d%d\", \u0026m, \u0026n); int choice = 1 \u003c\u003c n; for (int i = 0; i \u003c choice; i++) { if ((i \u0026 (i \u003c\u003c 1)) == 0) v.push_back(i); } int len = v.size(); vector\u003cvector\u003cint\u003e\u003e dp(m + 1, vector\u003cint\u003e(len, 0)); for (int i = 1; i \u003c= m; i++) { for (int j = 1; j \u003c= n; j++) { scanf(\"%d\", \u0026nums[j]); if (!nums[j]) continue; cor[i] |= (1 \u003c\u003c (j - 1));//把每一行的方块状态转换成对应的十进制 } } int ans = 0; for (int i = 0; i \u003c len; i++) { //先处理第一行，方便后面计算 if ((v[i] \u0026 cor[1]) != v[i]) continue; dp[1][i] = 1; } for (int i = 2; i \u003c= m; i++) { for (int j = 0; j \u003c len; j++) { if ((v[j] \u0026 cor[i]) != v[j]) continue; for (int k = 0; k \u003c len; k++) { if ((v[j] \u0026 v[k]) != 0) continue; if ((v[k] \u0026 cor[i - 1]) != v[k]) ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:4:4","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"⑤ 数位DP 篇幅过长已搬出，见数位dp ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:4:5","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"5. 优化dp的手段 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:5:0","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"① 矩阵优化 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:5:1","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"② 数据结构优化 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:5:2","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"③ 单调队列优化 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:5:3","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"④ 决策单调性优化 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:5:4","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"⑤ 二进制优化 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:5:5","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"⑥ 斜率优化 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:5:6","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"⑦ 四边形不等式优化 未完待续（以后有空补充）…… ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:5:7","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["紫书刷题录-ch6"],"content":"Trees on the level 二叉树的建立 #include \u003cbits/stdc++.h\u003e using namespace std; const int M = 1e5 + 10; int lson[M], rson[M], cnt, node[M]; bool ok, in[M] = {false};//in记录节点是否存在 vector\u003cint\u003e ans; int newnode() {//申请新的地址 int u = ++cnt; lson[u] = rson[u] = 0; return u; } void newtree() {//建新树 lson[1] = rson[1] = 0; in[1] = false; cnt = 1; } void build(int v, char *s) { int indx = 0, u = 1; while (s[indx] != ')') { if (s[indx] == 'L') { if (!lson[u]) lson[u] = newnode(); u = lson[u]; } else { if (!rson[u]) rson[u] = newnode(); u = rson[u]; } indx++; } if (in[u]) ok = true; node[u] = v; in[u] = true; } void init() { memset(lson, 0, sizeof lson); memset(rson, 0, sizeof rson); memset(in, 0, sizeof in); memset(node, 0, sizeof node); } bool read() { char str[100]; init(); newtree(); while (scanf(\"%s\", str) != EOF) { if (strcmp(\"()\", str) == 0) return true; int node; sscanf(\u0026str[1], \"%d\", \u0026node); build(node, strchr(str, ',') + 1); } return false; } void dfs() { queue\u003cint\u003e q; q.push(1); while (q.size()) { int u = q.front(); q.pop(); if (!in[u]) { ok = true; return; } ans.push_back(node[u]); if (lson[u] != 0) q.push(lson[u]); if (rson[u] != 0) q.push(rson[u]); } } int main() { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif while (read()) { dfs(); if (ok) puts(\"not complete\"); else { bool f = true; for (auto i : ans) { if (f) f = false; else printf(\" \"); printf(\"%d\", i); } puts(\"\"); } ans.clear(); ok = false; } return 0; } 总结（收获）：在一般情况下利用指针建树和新建节点的原理就是申请新的地址内存（指针），但是如果这样的话在释放内存的时候会很不方便。所以这里我利用了变量模拟地址，即代码中的cnt，cnt = x代表申请了一个地址是x的内存（模拟的），这样的好处就是方便建树和建立新的节点，也没有因为难以释放指针内存的后顾之忧了。 ","date":"2020-07-31","objectID":"/2020/07/uva122/:1:0","tags":["题解","树"],"title":"UVA122","uri":"/2020/07/uva122/"},{"categories":["cf刷题计划"],"content":"传送门 题意：给你两个同长数组代表n个人两场比赛的成绩，再给你一个x，某两个数组的和$a_i + b_j \\ge x$，问你两数组组合成满足式子的排名最高和最低是多少。具体看样例就懂了。 思路：此题对于最高排名一定是1，即第一名，而最低排名的话，一开始知道是一个双指针的贪心，但是就是不知道怎么贪，后来看到大佬的想法豁然开朗：只要找到组合后大于等于x的个数有多少就好了。 具体找法：一个数组a大到小排序，一个数组b小到大排序，然后只要从a从头开始一个一个遍历，从b数组中从头找能与a数组的数加起来大于等于x的数就好了，然后记录个数，就是答案 心得：贪心题目是难想，想到之后就很简单，代码量也不大，还有一个比较考验的就是模拟的功力了（从人的思维去想想如果这不是一道编程题，而是一个生活的益智题，你会怎么做？然后再用代码实现,说的简单，感觉还是要多刷题） 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e using namespace std; const int M = 1e5 + 5; int n, x, a[M], b[M]; int main() { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif scanf(\"%d%d\", \u0026n, \u0026x); for (int i = 0; i \u003c n; i++) { scanf(\"%d\", a + i); } for (int i = 0; i \u003c n; i++) { scanf(\"%d\", b + i); } printf(\"1 \"); sort(a, a + n); sort(b, b + n); reverse(a, a + n); //a从大到小排序 int j = 0, ans = 0; for (int i = 0; i \u003c n; i++) { while (j \u003c n \u0026\u0026 b[j] + a[i] \u003c x) { j++; } if (j \u003e= n) break; ans++; j++; } printf(\"%d\", ans); return 0; } ","date":"2020-07-24","objectID":"/2020/07/olympiad/:1:0","tags":["模拟","题解","思维","贪心"],"title":"Olympiad","uri":"/2020/07/olympiad/"},{"categories":["cf刷题计划"],"content":"传送门 题意：给你一个矩阵，每次进行与行之间的交换，或者是列与列之间的交换，或者查询(x, y)点的值 思路：一开始想着是不是直接就纯模拟算了，后来想想，直接用数组把行和列也记录下来不就好了吗 代码如下 #include \u003ccstdio\u003e using namespace std; const int M = 1e3 + 10; int r[M], c[M], g[M][M], n, m, k; int main() { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif scanf(\"%d%d%d\", \u0026n, \u0026m, \u0026k); for (int i = 1; i \u003c= n; i++) r[i] = i; for (int i = 1; i \u003c= m; i++) c[i] = i; for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { scanf(\"%d\", \u0026g[i][j]); } } while (k--) { char a; int x, y; scanf(\"\\n%c %d %d\", \u0026a, \u0026x, \u0026y); if (a == 'r') {//交换操作 r[x] ^= r[y], r[y] ^= r[x], r[x] ^= r[y]; } else if (a == 'c') { c[x] ^= c[y], c[y] ^= c[x], c[x] ^= c[y]; } else { printf(\"%d\\n\", g[r[x]][c[y]]); } } return 0; } ","date":"2020-07-24","objectID":"/2020/07/cosmic_tables/:1:0","tags":["模拟","题解","思维"],"title":"Cosmic_Tables","uri":"/2020/07/cosmic_tables/"},{"categories":["cf刷题计划"],"content":"传送门 什么鬼，div2也出水题？还是我变强了？😂 题意：给你一个长为n的序列，再给你一个k，你每次都必须要这样做：选择第k个数，把他复制到序列的最后，再把序列的第一个数给删了，问你要操作多少次可以使得序列数组的数全部相同，如果根本不可能通过上述操作使得序列数组的数全部相同，则输出-1 思路：不难发现，如果一开始第k个数及后面的数有出现不同的数的话，是不可能通过上述操作使得整个数组完全相同，如果可能的话，就往k前找，即往左找，找到第一个与第k个数不同的数，输出他的下标就好了（因为要一直删到那个不同的数），模拟一下就好了。 代码如下 #include \u003ccstdio\u003e using namespace std; const int M = 1e5 + 10; int n, k, arr[M]; int main() { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif scanf(\"%d%d\", \u0026n, \u0026k); for (int i = 0; i \u003c n; i++) { scanf(\"%d\", arr + i); } int tmp = arr[k - 1]; for (int i = k; i \u003c n; i++) { if (arr[i] != tmp) { printf(\"-1\"); return 0; } } for (int i = k - 2; i \u003e= 0; i--) { if (arr[i] != tmp) { printf(\"%d\", i + 1); return 0; } } printf(\"0\"); return 0; } ","date":"2020-07-24","objectID":"/2020/07/shooshuns_and_sequence/:1:0","tags":["模拟","题解","思维"],"title":"Shooshuns_and_Sequence","uri":"/2020/07/shooshuns_and_sequence/"},{"categories":["cf刷题计划"],"content":"传送门 题意：旅行者每天都会记录自己的海拔高度，他每天规定走海拔相差不超过1的路线，有一天他的记录丢失了，只剩下几天的，问你他之前有可能到达的最高海拔是多少，如果数据出现矛盾，输出\"IMPOSSIBLE\" 思路：用两个数组记录天数和当天的海拔高度，如果相隔的海拔差比相隔的天数差还大的话就是矛盾，否则就这样计算相隔天数中可能的最大海拔高度：$MaxHight = ( day[i] + hight[i] - (day[i - 1] - hight[i - 1]) ) / 2$，最后取众多MaxHight的最大值 注意：第一天和最后一天的数据可能没给，所以我们要自己造一个可能的最大高度，例如只给你第3天的海拔高度为5，总共旅行的天数为4，那么我们就自己造一个第一天的高度为7$(5 + 3 - 1)$，第4天的高度为6$(5 + (4 - 3))$，就是一开始没想到这个，wa了2发/(ㄒoㄒ)/~~ 代码如下： #include \u003calgorithm\u003e#include \u003ccmath\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e using namespace std; const int M = 1e5 + 10; int n, m, d[M], h[M]; bool ok = true; int main() { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= m; i++) { scanf(\"%d%d\", d + i, h + i); if (i != 1 \u0026\u0026 d[i] - d[i - 1] \u003c abs(h[i] - h[i - 1])) { ok = false; } } if (ok) { h[0] = h[1] + d[1] - 1, h[m + 1] = h[m] + (n - d[m]); d[0] = 1, d[m + 1] = n; int Max = h[0]; for (int i = 1; i \u003c= m + 1; i++) { int tmp = (d[i] + h[i] - (d[i - 1] - h[i - 1])) \u003e\u003e 1; Max = max(Max, tmp); } printf(\"%d\\n\", Max); } else { printf(\"IMPOSSIBLE\\n\"); } return 0; } ","date":"2020-07-24","objectID":"/2020/07/tourists_notes/:1:0","tags":["模拟","题解"],"title":"Tourist's_Notes","uri":"/2020/07/tourists_notes/"},{"categories":["cf刷题计划"],"content":"传送门 题意：一个只由1和0组成的十进制数叫做Quasi Binary，例如11（十一）就是，现在给你一个n，让你求出他可能有哪些Quasi Binary的和组成，输出最少的Quasi Binary个数并将他们输出 思路：模拟，用个二维数组记录所有的结果位数结果，然后相加输出。例如32就是记录10、10、10、1、1，然后分别将不同位数的相加得到11（10 + 1），11（10 + 1），10（10 + 0） 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e using namespace std; int main() { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif int n; scanf(\"%d\", \u0026n); int t = n, sum = 0; while (t) { sum = max(t % 10, sum); t /= 10; } printf(\"%d\\n\", sum); int tmp, x = 0, y = 0, numset[7][10] = {0}, w = 1; while (n) { tmp = n % 10, y = 0; while (tmp) { numset[x][y++] = w; tmp--; } n /= 10, x++, w *= 10; } for (int i = 0; i \u003c sum; i++) { int res = 0; for (int j = 0; j \u003c 7; j++) { res += numset[j][i]; } printf(\"%d \", res); } return 0; } ","date":"2020-07-23","objectID":"/2020/07/quasi_binary/:1:0","tags":["模拟","题解"],"title":"Quasi_Binary","uri":"/2020/07/quasi_binary/"},{"categories":["cf刷题计划"],"content":"传送门 题意：给你个字符串，减去一段子串，是否能将剩下的不改变顺序拼成\"CODEFORCES\"，能则输出\"YES\"，否则输出\"NO\" 思路：直接枚举减去的长度，然后暴力 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cstring\u003e#include \u003cvector\u003e using namespace std; char aim[] = \"CODEFORCES\", str[200], tmp[200]; int main() { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif scanf(\"%s\", str); if (strcmp(str, aim) == 0) { puts(\"YES\"); return 0; } int len = strlen(str); for (int i = 1; i \u003c= len; i++) { for (int j = 0; j + i - 1 \u003c len; j++) { int ind = 0; for (int k = 0; k \u003c len; k++) { if (k \u003c j || k \u003e j + i - 1) { tmp[ind++] = str[k]; } } tmp[ind] = '\\0'; if (strcmp(tmp, aim) == 0) { puts(\"YES\"); return 0; } } } puts(\"NO\"); return 0; } ","date":"2020-07-23","objectID":"/2020/07/cutting_banner/:1:0","tags":["暴力","题解"],"title":"Cutting_Banner","uri":"/2020/07/cutting_banner/"},{"categories":["总结"],"content":"前言 起因是一次力扣周赛时被一道最短论的题给整蒙了，决定这几天恶补图论，正好POJ的刷题题单刷到了图 打算学习图论从零开始，目前刷的题不多 ","date":"2020-07-21","objectID":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:1:0","tags":["图论"],"title":"图论刷题总结","uri":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"总结 关于存图 不同的存图方式可以使得不同的算法更加方便，例如：邻接表可以使Dijkstra算法在堆优化中方便不少，而邻接矩阵可以使Floyd算法更加方便 关于建图 有一些题目在描述的时候给的数据不好建图，这需要经验的积累 而有一些题目并没有直接说明是图，换句话说能否看出是使用图论的知识来解题也需要经验的累积 关于计算 题目中的要求并不是一成不变的，有时候最短路径并不是仅仅指的是值最短，有时候也有可能题目让你求最大值，但最短路依然可以解 ","date":"2020-07-21","objectID":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:2:0","tags":["图论"],"title":"图论刷题总结","uri":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"最短路 先从最短路开始刷，刷到后面发现有些题三个算法（Dijkstra、Bellman-Ford、Floyd）都是可以解的 ","date":"2020-07-21","objectID":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:3:0","tags":["图论"],"title":"图论刷题总结","uri":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"Dijkstra [例题] 洛谷P4779 【模板】单源最短路径（标准版） 题意：最短路板子题，不解释 思路：直接用Dijkstra的堆优化做，因为没有负环 直接上代码 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003clocale\u003e#include \u003cqueue\u003e#include \u003cutility\u003e#include \u003cvector\u003e using namespace std; typedef long long ll; typedef pair\u003cint, int\u003e pii; const int M = 2e5 + 10; const ll INF = 0x3f3f3f3f; int n, m, s, cnt = 0; struct edges { int w, to, next; edges(int a = 0, int b = 0, int c = -1) : w(b), to(a), next(c) {} }; vector\u003cint\u003e head, dis; vector\u003cedges\u003e edge; inline void add(int u, int v, int w) { edge[++cnt] = edges(v, w, head[u]); head[u] = cnt; } void dij() { vector\u003cbool\u003e vis(n + 1, false); dis = vector\u003cint\u003e(n + 1, INF); priority_queue\u003cpii, vector\u003cpii\u003e, greater\u003cpii\u003e \u003e heap; dis[s] = 0; heap.push(make_pair(0, s)); while (heap.size()) { int u = heap.top().second; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to, w = edge[i].w; if (dis[v] \u003e dis[u] + w) { dis[v] = dis[u] + w; heap.push(make_pair(dis[v], v)); } } } } int main() { scanf(\"%d%d%d\", \u0026n, \u0026m, \u0026s); head = vector\u003cint\u003e(n + 1, -1); edge = vector\u003cedges\u003e(m + 1); for (int i = 0; i \u003c m; i++) { int u, v, w; scanf(\"%d%d%d\", \u0026u, \u0026v, \u0026w); add(u, v, w); } dij(); for (int i = 1; i \u003c= n; i++) { printf(\"%d \", dis[i]); } puts(\"\"); return 0; } 洛谷P1629 邮递员送信 题意：一个邮递员从一号顶点出发送东西，一次只能送一个，送完就要回到1号节点，求送完后的最短路(注意：有向图的往返) 思路：两次Dijkstra就可以了 代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cqueue\u003e#include \u003cutility\u003e#define mk(a, b) make_pair(a, b) using namespace std; typedef pair\u003cint, int\u003e pii; const int INF = 0x3f3f3f3f; int n, m, cnt = 0; vector\u003cint\u003e dis, ddis, head, head2; struct edges { int to, w, next; edges(int a = 0, int b = 0, int c = -1) : to(a), w(b), next(c) {} }; vector\u003cedges\u003e edge, bk; void init() { head = vector\u003cint\u003e(n + 1, -1); head2 = vector\u003cint\u003e(n + 1, -1); dis = vector\u003cint\u003e(n + 1, INF); ddis = vector\u003cint\u003e(n + 1, INF); edge = vector\u003cedges\u003e(m + 1); bk = vector\u003cedges\u003e(m + 1); } void add(int u, int v, int w) { edge[++cnt] = edges(v, w, head[u]); bk[cnt] = edges(u, w, head2[v]); head[u] = cnt; head2[v] = cnt; } void dij() { priority_queue\u003cpii\u003e heap; vector\u003cbool\u003e vis(n + 1, false); heap.push(mk(0, 1)); while (heap.size()) { int u = heap.top().second; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to, w = edge[i].w; if (dis[v] \u003e dis[u] + w) { dis[v] = dis[u] + w; heap.push(mk(-dis[v], v)); } } } } void dij2() { priority_queue\u003cpii\u003e heap; vector\u003cbool\u003e vis(n + 1, false); heap.push(mk(0, 1)); while (heap.size()) { int u = heap.top().second; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head2[u]; ~i; i = bk[i].next) { int v = bk[i].to, w = bk[i].w; if (ddis[v] \u003e ddis[u] + w) { ddis[v] = ddis[u] + w; heap.push(mk(-ddis[v], v)); } } } } int main() { scanf(\"%d%d\", \u0026n, \u0026m); init(); for (int i = 0; i \u003c m; i++) { int u, v, w; scanf(\"%d%d%d\", \u0026u, \u0026v, \u0026w); add(u, v, w); } dis[1] = ddis[1] = 0; dij(); dij2(); int ans = 0; for (int i = 1; i \u003c= n; i++) { ans += dis[i] + ddis[i]; } printf(\"%d\", ans); return 0; } 洛谷P1144 最短路计数 题意：无向图，每条边的权值都为 1， 求从一号顶点出发到其他顶点的最短路的个数 思路：用个$ans$数组储存最短路的个数，Dijkstra内加个计数条件，如果有松弛操作则$ans$继承上一个节点最短路的个数，如果没用松弛操作，就直接让$ans$加上一节点的$ans$（注：ans[1]初始化为1， 其余都初始化为0） 代码如下 #include \u003cbits/stdc++.h\u003e using namespace std; typedef pair\u003cint, int\u003e pii; const int M = 1e6 + 5; int n, m, dis[M], head[M], ans[M], cnt = 0; struct es { int to, next; es(int a = 0, int b = -1) : to(a), next(b) {} } e[M \u003c\u003c 2]; void add(int a, int b) { e[++cnt] = es(b, head[a]); head[a] = cnt; } void dij() { for (int i = 2; i \u003c= n; i++) { dis[i] = 0x3f3f3f3f; } ans[1] = 1; vector\u003cbool\u003e vis(n + 1, false); priority_queue\u003cpii\u003e heap; heap.push(make_pair(0, 1)); while (heap.size()) { int u = heap.top().second; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (dis[v] \u003e dis[u] + 1) {//松弛操作 dis[v] = dis[u] + 1; ans[v] = ans[u]; heap.push(make_pair(-dis[v], v)); } else if (dis[u] + 1 == dis[v]","date":"2020-07-21","objectID":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:3:1","tags":["图论"],"title":"图论刷题总结","uri":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"Bellman-Ford 这个算法更多的不是用来计算最短路，而是用来计算是否有负环或者正环（负环dis初始化为INF，正环dis初始化为0） 【例题】 EOlymp - 1453 Ford-Bellman 题意：给你一个有向图，有负权边，保证没有负环，求1号顶点到各个点的最短距离，如果无法到达顶点，距离输出30000 思路：就是一个很纯正的Bellman - Ford的板子题 直接上代码 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; const int INF = 0x3f3f3f3f; int n, m; vector\u003cint\u003e dis; struct edges { int u, v, w; edges(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) {} }; vector\u003cedges\u003e e; int add(int a, int b) { //无穷大加任何数还是无穷大 if (a == INF || b == INF) return a; return a + b; } void bf() { bool flag; while (true) { flag = true; for (int j = 0; j \u003c m; j++) { if (dis[e[j].v] \u003e add(dis[e[j].u], e[j].w)) { dis[e[j].v] = dis[e[j].u] + e[j].w; flag = false; } } if (flag) return; } } int main() { scanf(\"%d%d\", \u0026n, \u0026m); dis = vector\u003cint\u003e(n + 1, INF); for (int i = 0; i \u003c m; i++) { int u, v, w; scanf(\"%d%d%d\", \u0026u, \u0026v, \u0026w); e.push_back(edges(u, v, w)); } dis[1] = 0; bf(); for (int i = 1; i \u003c= n; i++) { if (dis[i] == INF) dis[i] = 30000; printf(\"%d \", dis[i]); } puts(\"\"); return 0; } POJ 2240 Arbitrage 题意：给你一个有向图，判断是否有正环 思路：把字符串的顶点用hash来代替，然后就是标准的Bellman - Ford模板题了,正环判断dis初始化为0 代码如下 #include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cmap\u003e#include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int n, m, test = 0; double dis[100]; string str; struct es { int u, v; double w; es(int a = 0, int b = 0, double c = 0) : u(a), v(b), w(c) {} }; vector\u003ces\u003e e; bool bf() { for (int i = 1; i \u003c= n - 1; i++) { for (int j = 0; j \u003c m; j++) { if (dis[e[j].v] \u003c dis[e[j].u] * e[j].w) { dis[e[j].v] = dis[e[j].u] * e[j].w; } } } for (int i = 0; i \u003c m; i++) { if (dis[e[i].v] \u003c dis[e[i].u] * e[i].w) { return true; } } return false; } int main() { map\u003cstring, int\u003e hsh; while (cin \u003e\u003e n, n) { for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e str; hsh[str] = i; } cin \u003e\u003e m; e = vector\u003ces\u003e(m); for (int i = 0; i \u003c m; i++) { string a, b; double w; cin \u003e\u003e a \u003e\u003e w \u003e\u003e b; e[i] = es(hsh[a], hsh[b], w); } memset(dis, 0, sizeof dis); dis[1] = 1; if (bf()) { cout \u003c\u003c \"Case \" \u003c\u003c ++test \u003c\u003c \": Yes\" \u003c\u003c endl; } else { cout \u003c\u003c \"Case \" \u003c\u003c ++test \u003c\u003c \": No\" \u003c\u003c endl; } } return 0; } POJ 3259 Wormholes 题意：有两种边，一种是双向边，一种是单线负权边，问你是否有负环 思路：双向边和负权边都用邻接表存起来，然后就是普通的Bellman - Ford了 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; const int M = 3e3; int n, m, ww, f, dis[510]; struct es { int u, v, w; es(int a = 0, int b = 0, int c = 0) : u(a), v(b), w(c) {} }; vector\u003ces\u003e e; bool bf() { for (int i = 1; i \u003c= n; i++) { bool flag = true; for (int j = 0; j \u003c m + m + ww; j++) { if (dis[e[j].v] \u003e dis[e[j].u] + e[j].w) { dis[e[j].v] = dis[e[j].u] + e[j].w; flag = false; } } if (flag) break; if (i == n) return true;//有负环，因为松弛了 n 次 } return false; } int main() { scanf(\"%d\", \u0026f); while (f--) { scanf(\"%d%d%d\", \u0026n, \u0026m, \u0026ww); int u, v, w; for (int i = 0; i \u003c m; i++) { scanf(\"%d%d%d\", \u0026u, \u0026v, \u0026w); e.push_back(es(u, v, w)); e.push_back(es(v, u, w)); } for (int i = 0; i \u003c ww; i++) { scanf(\"%d%d%d\", \u0026u, \u0026v, \u0026w); e.push_back(es(u, v, -w)); } memset(dis, 0x3f, sizeof dis); dis[1] = 0; if (bf()) puts(\"YES\"); else puts(\"NO\"); e.clear(); } return 0; } POJ 1860 Currency Exchange 题意：给你一个有向图，你手中有v元的a货币，每个顶点都是一个货币兑换点，每个兑换点都有自己的兑换费用和兑换比例，并且兑换是双向的，例如 a → b, b → a，但兑换比率和兑换费用不一定一样，由测试样例给，问你从某点出发，回到该点时，即兑换会原本的货币种类，他手中的钱能否变多 思路：判断正环，唯一要注意的就是初始化 $ dis[s] = V $，其余初始化为0 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003eusing namespace std; const int M = 300; int n, m, s; double vv, dis[M] = {0}; //vv是一开始手中的钱的数量 struct es { int u, v; double r, c; es(int a = 0, int b = 0, double c = 0, double d = 0) : u(a), v(b), r(c), c(d) {} } e[M]; bool bf() { for (int i = 1; i \u003c= n - 1; i++) { for (int j = 0; j \u003c m + m; j++) { if (dis[e[j].v] \u003c (dis[e[j].u] - e[j].c) * e[j].r) { dis[e[j].v] = (dis[e[j].u] - e[j].c) * e[j].r; } } } for (int j = 0; j \u003c m + m; j++) { if (dis[e[j].v] \u003c (dis[e[j].u] - e[j].c) * e[j].r) { return true; //手中的钱变多了 } } return false;//手中的钱没变或者少了 } int main() { scanf(\"%d%d%d%lf\", \u0026n, \u0026m, \u0026s, \u0026vv); for (int i = 0; i \u003c m; i++)","date":"2020-07-21","objectID":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:3:2","tags":["图论"],"title":"图论刷题总结","uri":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"Floyd POJ 2253 Frogger 题意：一直青蛙想通过石头跳到另一只青蛙那里，但是他的跳跃能力是有封顶的，即他的能力是有限的，最多能跳1米的话，绝对跳不到1.1米远的石头上，给你石头的坐标，和两只青蛙的坐标，问你青蛙的最远能跳的封顶距离的最小值是多少 思路：一个最短路的变形题，用Floyd比较好想（其他方法也可），转换成人话就是让你求从 a 点到 b 点的路径中，最小边权的最大值是多少，有点绕，自己草稿纸画个图就明白了 代码如下 #include \u003calgorithm\u003e#include \u003ccmath\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; const int M = 2e2 + 10; int n, x[M], y[M], test = 0; double dis[M][M]; void Floyd() { for (int k = 1; k \u003c= n; k++) { for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= n; j++) { if (dis[i][j] \u003e max(dis[i][k], dis[k][j])) { dis[i][j] = max(dis[i][k], dis[k][j]); } // dis[i][j] = min(dis[i][j], max(dis[i][k], dis[k][j]));//更清晰的代码 } } } } int main() { while (scanf(\"%d\", \u0026n), n) { scanf(\"%d%d%d%d\", \u0026x[1], \u0026y[1], \u0026x[2], \u0026y[2]); double a = x[2] - x[1], b = y[2] - y[1]; dis[1][2] = sqrt(a * a + b * b); for (int i = 3; i \u003c= n; i++) { scanf(\"%d%d\", \u0026x[i], \u0026y[i]); for (int j = 1; j \u003c i; j++) { a = x[i] - x[j], b = y[i] - y[j]; dis[i][j] = sqrt(a * a + b * b); dis[j][i] = dis[i][j]; } } Floyd(); printf(\"Scenario #%d\\nFrog Distance = %.3f\\n\\n\", ++test, dis[1][2]); memset(dis, 0, sizeof dis); } return 0; } POJ 1125 Stockbroker Grapevine 题意：给你一个有向图，问你是否能从一点出发到达所有其他顶点，如果有输出该点编号并输出到达这些顶点的最短路中的最大值，否则输出\"disjoint\" 思路：显然Floyd算法，在Floyd完了之后遍历每个最短路，看看取最短路的最大值和其起点，如果这个最大值是无穷大则说明没有一个顶点可以到达其他顶点 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; const int M = 110; int n, tm[M][M], dis[M][M]; void floyd() { for (int k = 1; k \u003c= n; k++) { for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= n; j++) { dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); } } } } int main() { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif while (scanf(\"%d\", \u0026n), n) { memset(dis, 0x3f, sizeof dis); memset(tm, 0x3f, sizeof tm); for (int i = 1; i \u003c= n; i++) { int m; scanf(\"%d\", \u0026m); for (int j = 0; j \u003c m; j++) { int x, y; scanf(\"%d%d\", \u0026x, \u0026y); dis[i][x] = y; } } floyd(); int ans = -1, Min = 0x3f3f3f3f; for (int i = 1; i \u003c= n; i++) { int Max = 0; for (int j = 1; j \u003c= n; j++) { if (i != j \u0026\u0026 dis[i][j] \u003e Max) { Max = dis[i][j]; } } if (Max \u003c Min) { ans = i; Min = Max; } } if (Min == 0x3f3f3f3f) { puts(\"disjoint\"); continue; } printf(\"%d %d\\n\", ans, Min); } return 0; } ","date":"2020-07-21","objectID":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:3:3","tags":["图论"],"title":"图论刷题总结","uri":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"Spfa 一种速度极快的最短路算法，但是听说被一位大佬卡死了，但是在一些题目上还是能用的，下面利用这个算法来解决上面的一些题 存图的方式最好是邻接表法，这样比较方便松弛 其实道理都差不多，题目的不同，主要修改的就是松弛操作部分的代码 【例题】 POJ 3259 Wormholes 上面的Bellman - Ford算法的例题，除了存图的方式不同，松弛的操作还是不变 直接上代码 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cqueue\u003e#include \u003cvector\u003e using namespace std; const int M = 2e4; int n, m, ww, f, dis[510], head[510], cnt = 0; struct es { int to, w, next; es(int a = 0, int b = 0, int c = -1) : to(a), w(b), next(c) {} }; vector\u003ces\u003e e; void add(int u, int v, int w) { e[++cnt] = es(v, w, head[u]); head[u] = cnt; } bool spfa() { queue\u003cint\u003e q; vector\u003cbool\u003e inq(n + 1); vector\u003cint\u003e nums(n + 1, 0); q.push(1); inq[1] = true; nums[1]++; while (q.size()) { int u = q.front(); q.pop(); inq[u] = false; for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to, w = e[i].w; if (dis[v] \u003e dis[u] + w) { dis[v] = dis[u] + w; if (!inq[v]) { q.push(v); inq[v] = true; nums[v]++; if (nums[v] \u003e= n) return true; } } } } return false; } int main() { scanf(\"%d\", \u0026f); while (f--) { cnt = 0; memset(head, -1, sizeof head); scanf(\"%d%d%d\", \u0026n, \u0026m, \u0026ww); e = vector\u003ces\u003e(m + m + ww + 1); int u, v, w; for (int i = 0; i \u003c m; i++) { scanf(\"%d%d%d\", \u0026u, \u0026v, \u0026w); add(u, v, w); add(v, u, w); } for (int i = 0; i \u003c ww; i++) { scanf(\"%d%d%d\", \u0026u, \u0026v, \u0026w); add(u, v, -w); } memset(dis, 0x3f, sizeof dis); dis[1] = 0; if (spfa()) puts(\"YES\"); else puts(\"NO\"); e.clear(); } return 0; } ","date":"2020-07-21","objectID":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:3:4","tags":["图论"],"title":"图论刷题总结","uri":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"未完待续 ","date":"2020-07-21","objectID":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:4:0","tags":["图论"],"title":"图论刷题总结","uri":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["cf补题"],"content":"description.","date":"2020-07-06","objectID":"/2020/07/654div2problemc/","tags":["数学","思维","模拟","题解"],"title":"C. A Cookie for You题解","uri":"/2020/07/654div2problemc/"},{"categories":["cf补题"],"content":"传送门 ","date":"2020-07-06","objectID":"/2020/07/654div2problemc/:0:0","tags":["数学","思维","模拟","题解"],"title":"C. A Cookie for You题解","uri":"/2020/07/654div2problemc/"},{"categories":["cf补题"],"content":"题意 有 a 个 饼干，和 b 个巧克力 有 n 个 第一类人，有 m 个第二类人 对于第一类人， if (a \u003e b)吃一个饼干，else 吃一个巧克力 对于第二类人， if (a \u003e b)吃一个巧克力，else 吃一个饼干 问你是否有一种方法能让第一类和第二类人都有东西吃，有输出Yes，否则输出No ","date":"2020-07-06","objectID":"/2020/07/654div2problemc/:1:0","tags":["数学","思维","模拟","题解"],"title":"C. A Cookie for You题解","uri":"/2020/07/654div2problemc/"},{"categories":["cf补题"],"content":"思考 很显然第一类人优先吃多的（一样多就吃巧克力），第二类人优先吃少的（一样多就吃饼干） 有两种思路，一个是我自己比赛时想到的，一个是x大佬讲的 方法一 一来就判断饼干和巧克力的总数够不够第一类和第二类人吃，如果不够，直接No，如果够如下 先让第二类人吃，方便我们思考，因为东西只会被越吃越少嘛，不可能越吃越多，所以他自始至终都会不会换别的吃 然后就是判断最少的是否够第二类人吃。先讨论最简单的——够，显然如果够的话则第一类人一定够吃，为什么，因为第一类人是优先吃最多的，而我们先判断的是总数都够吃，所以无论怎么吃，不管最多的东西怎么变化，都是够吃的,所以是Yes； 但是如果不够吃呢，直接就是No，为什么，解释起来有点麻烦（比赛时候我就是这里没有想好，一直往别的地方想，自己扰乱了自己的思维）。先这样想，如果不够吃，那么最小的永远都是那一个（饼干或者巧克力一开始最少的）：因为不够吃，所以那一个就会被吃完（即等于0），但是呢第二类人还有没吃到的，他们只会吃最少的那一个，而最少的那一个个数是0了，所以无论如何都吃不了了。 比赛的时候我往别的地方想了（相信不止我会这样想歪，现在想通了，解释一下，可能会有点啰嗦）：就是如果最少的不够第二类人吃的话那就一开始先让第一类人吃，或者中途到了某个关系后交替来吃。但是这样只会让自己陷入窘境，其实这种情况下，无论是让第一类人先吃，还是交替吃，都不会改变第二类人没得吃的结果。因为第一类人的插入只会让最多数量的那个东西变少，一直吃到饼干和巧克力个数一样时，最少的个数依然是最少，即便最少的种类可能会变，但是第二类人能吃的个数不会变。换句话说就是，即便它最少或最多的种类转移了，第二类依然会吃最少的，他不可能可以多吃一个多的那一个（即便饼干和巧克力相等） 详细见代码solve()函数 方法二 第一步和方法一相同，总数不够就No，否则如下 利用一个小规律：先让第二类人吃一次，再让第一类人吃一次，这样的话无论两者大小，饼干数和巧克力数都会各自减一。利用这个特点把人和东西给简化。 第一种可能，东西（饼干或者巧克力）优先有一方优先减到0，而两类人都还有，那么一定是No，因为第二类人只吃最少的，而最少的为0了 第二种可能就是，人优先有一方减到了0，这时候如果是第二类人减到了0，显然就是Yes（道理和方法一中最少数量的东西够第一类人吃是一样的）。如果是第一类人减到了0，那么也就是说只剩下第二类人，因为第二类人只吃最少的，所以只要判断最少的那个东西够不够第二类人吃就行了，够就Yes，不够就No 详细见代码solve2()函数 代码如下 #include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef vector\u003cint\u003e vi; typedef vector\u003clong long\u003e vll; typedef pair\u003cint, int\u003e pii; typedef pair\u003clong long, long long\u003e pll; #define debug printf(\"(hao)\") #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i \u003c (b); i++) #define clr(a, v) memset(a, v, sizeof(a)) void solve() {//方法一 // int n; ll a, b, n, m; scanf(\"%lld%lld%lld%lld\", \u0026a, \u0026b, \u0026n, \u0026m); if (a + b \u003c n + m) printf(\"No\\n\"); //判断总数够不够吃，不够吃就No else { ll Min = min(a, b); //寻找最小的一堆食物 if (Min \u003e= m) printf(\"Yes\\n\"); // 最少的够第二类人吃 else printf(\"No\\n\"); //最少的不够第二类人吃 } } void solve2() {//方法二 // int n; ll a, b, n, m; scanf(\"%lld%lld%lld%lld\", \u0026a, \u0026b, \u0026n, \u0026m); if (a + b \u003c n + m) printf(\"No\\n\"); else { ll temp = min(n, m), tmin = min(a, b); if (tmin \u003e= temp) { //如果人先出现0，即第二种可能 a -= temp, b -= temp, n -= temp, m -= temp;//全部均掉简化 if (m == 0) printf(\"Yes\\n\");//第二类人为0 else { //还有第二类人剩下 if (min(a, b) \u003e= m) printf(\"Yes\\n\"); else printf(\"No\\n\"); } } else printf(\"No\\n\"); //食物先出现0，即上述第一种可能 } } // #define LOCAL int main() { std::ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif int T; scanf(\"%d\", \u0026T); while (T--) { solve(); // solve2(); } return 0; } ","date":"2020-07-06","objectID":"/2020/07/654div2problemc/:2:0","tags":["数学","思维","模拟","题解"],"title":"C. A Cookie for You题解","uri":"/2020/07/654div2problemc/"},{"categories":["cf补题"],"content":"反思 在比赛的时候想到了方法一，但是没有认真用代码实现，并且在往深处思考的时候反而被别个可能性干扰了，也没能及时想出方法反驳自己，而是冒出让第一类人先吃的想法解决自己的矛盾，并没有想到就算第一类人吃了耶挽回不了第二类人的命运（没得吃） 感觉自己当时思维会混乱极有可能就是比赛的状态，打得少，做得少 想到方法就往一处想，尽量不要再想别的，或者想到别的发现想不下去就回到之前的状态重新换方向想 ","date":"2020-07-06","objectID":"/2020/07/654div2problemc/:3:0","tags":["数学","思维","模拟","题解"],"title":"C. A Cookie for You题解","uri":"/2020/07/654div2problemc/"},{"categories":["cf补题"],"content":"总结 模拟就是要看题量如何 思维的严谨和正确性都是题量堆积出来的，经验的多少决定（十分影响）了思维的快慢和正误 所以做刷题，多打比赛，多总结 ","date":"2020-07-06","objectID":"/2020/07/654div2problemc/:4:0","tags":["数学","思维","模拟","题解"],"title":"C. A Cookie for You题解","uri":"/2020/07/654div2problemc/"},{"categories":["cf补题"],"content":"description.","date":"2020-07-06","objectID":"/2020/07/653div3probleme1/","tags":["贪心","思维","排序","题解"],"title":"E1. Reading Books (easy version)题解","uri":"/2020/07/653div3probleme1/"},{"categories":["cf补题"],"content":"传送门 ","date":"2020-07-06","objectID":"/2020/07/653div3probleme1/:0:0","tags":["贪心","思维","排序","题解"],"title":"E1. Reading Books (easy version)题解","uri":"/2020/07/653div3probleme1/"},{"categories":["cf补题"],"content":"题意 小A和小B要读书，现在共又 n 本书，对于每本书都有三个参数，$t_i$：阅读的时间、$a_i$：小A喜欢读的书、$b_i$：小B喜欢读的书 现在小A和小B都要读 k 本书，但是他俩只读自己喜欢的书 问你小A和小B最少要读多久可以读到 k 本书，（对于都喜欢的书，时间是可以只算一次的） 如果他俩有一个没读到 k 本书就输出 -1 ","date":"2020-07-06","objectID":"/2020/07/653div3probleme1/:1:0","tags":["贪心","思维","排序","题解"],"title":"E1. Reading Books (easy version)题解","uri":"/2020/07/653div3probleme1/"},{"categories":["cf补题"],"content":"思路 一道思维贪心题cf好狠呀，网上有很多的解法，大多数都是模拟+贪心，但是我看到了一位大佬的贪心思路，醍醐灌顶，下面就用它的思路了 对于每个书本可以分为以下四类 小A和小B都喜欢的书 只有小A喜欢的书 只有小B喜欢的书 他俩都不喜欢的书 显然最后一类可以不管不要呀，看书长知识，目前只考虑第二三类的书，可以分别用数组$a_n$和$b_n$记录这些书的阅读时间，然后从小到大排序，精彩的来了，把$a_i 和 b_i$合成一本书当作是第一类的书（妙呀,我怎么没想到，太笨了，太菜了，刷题少），然后放入第一类，再来对第一类的书的阅读时间排序，选前 k 个书，记录阅读时间就是最终答案 代码如下 #include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef vector\u003cint\u003e vi; typedef vector\u003clong long\u003e vll; typedef pair\u003cint, int\u003e pii; typedef pair\u003clong long, long long\u003e pll; #define debug printf(\"(hao)\") #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i \u003c (b); i++) #define clr(a, v) memset(a, v, sizeof(a)) const int M = 2e5 + 10; vi a, b, t; void solve() { int n, k; scanf(\"%d%d\", \u0026n, \u0026k); rep(i, 0, n) { int _t, _a, _b; scanf(\"%d%d%d\", \u0026_t, \u0026_a, \u0026_b); if (_a \u0026\u0026 _b) t.push_back(_t); // 第一类 else if (_a) a.push_back(_t); // 第二类 else if (_b) b.push_back(_t); //第三类 } sort(all(a)); sort(all(b)); rep(i, 0, (int)min(a.size(), b.size())) t.push_back(a[i] + b[i]);//精辟之处 if ((int)t.size() \u003c k) {//如果不够 k 本，就输出 -1 printf(\"-1\\n\"); return; } sort(all(t)); int res = 0; rep(i, 0, k) res += t[i]; printf(\"%d\\n\", res); } // #define LOCAL int main() { std::ios::sync_with_stdio(false); #ifdef LOCAL freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif // int T; // scanf(\"%d\", \u0026T); // while (T--) solve(); return 0; } ","date":"2020-07-06","objectID":"/2020/07/653div3probleme1/:2:0","tags":["贪心","思维","排序","题解"],"title":"E1. Reading Books (easy version)题解","uri":"/2020/07/653div3probleme1/"},{"categories":["cf补题"],"content":"反思 比赛的时候没做到这题，一个字：菜 一开始用结构体来分析每一本书，后来才学到了把书本分类，然后贪心 贪心渐渐地不会了 以后cf前几题看看和贪心有没有关系 ","date":"2020-07-06","objectID":"/2020/07/653div3probleme1/:3:0","tags":["贪心","思维","排序","题解"],"title":"E1. Reading Books (easy version)题解","uri":"/2020/07/653div3probleme1/"},{"categories":["cf补题"],"content":"总结 这个结构题的题很巧妙地把他拆开，从而没有用到结构题，好处就是排序压力小 这场比赛很喜欢思维题和贪心 当有两个（或多个）共同影响时，要考虑把他们拆开来计算 …… ","date":"2020-07-06","objectID":"/2020/07/653div3probleme1/:4:0","tags":["贪心","思维","排序","题解"],"title":"E1. Reading Books (easy version)题解","uri":"/2020/07/653div3probleme1/"},{"categories":["cf补题"],"content":"description.","date":"2020-07-06","objectID":"/2020/07/653div3problemd/","tags":["数学","思维","数组","排序","题解"],"title":"D. Zero Remainder Array题解","uri":"/2020/07/653div3problemd/"},{"categories":["cf补题"],"content":"传送门 ","date":"2020-07-06","objectID":"/2020/07/653div3problemd/:0:0","tags":["数学","思维","数组","排序","题解"],"title":"D. Zero Remainder Array题解","uri":"/2020/07/653div3problemd/"},{"categories":["cf补题"],"content":"题意 给你一个长度为 n 的数组$a_n$，和一个 k，你有一个 x（一开始为0），你有以下两种操作 给 x 加上 1，即$x = x + 1$ 选择一个任意一个$a_i$($0 \\le i \u003c n$)加上 x，然后 x 加上 1 每个元素最多只能被执行一次上诉操作 问你执行上述操作，x 最小为多少可以使得数组所有元素都能整除 k ","date":"2020-07-06","objectID":"/2020/07/653div3problemd/:1:0","tags":["数学","思维","数组","排序","题解"],"title":"D. Zero Remainder Array题解","uri":"/2020/07/653div3problemd/"},{"categories":["cf补题"],"content":"思路 记录数组的每一个数至少要加多少才可以被 k 整除 寻找上述数中的最大的众数，计算 x 加到多少才可以使得这些数都能被 k 整除。 例如 对于一个数组 {1，1，1，2，3}，k = 6 则其至少要加的数为 {5，5，5，4，3} 显然最大的众数是 5，其个数是 3，那么对于第一个 5 则需要把 x 加到 5 就行了，对于第二个 5 ，就需要再等到下一个能模 6 为 5 的数，显然就是11($5 + 6 = 11$), 而第三个 5 也是同理就是 17，但这个还不是最终答案，因为题目的第二个操作是先给数组加上 x，再让 $x + 1$,所以最终答案就是 18 为什么这样就是对的呢？很简单，如果想要执行题中把所有数都弄成可以整除 k 并且每个数只能执行一次，对于两个相同且不能被 k 整除的数 y，想要把这两个 y 都弄成能被 k 整除，第二个数 y 一定要等到下一次有一个数 x 加上这个 y 使得它能整除 k。 所以我们要求出每个数最少加多少才可以被 k 整除，然后求一个最大的众数，计算最后一个众数需要的最小x（因为最后的 x 一定是停在了能使这些最大众数的最后一个数被 k 整除的结果），记得最后的答案要再加一才是最终答案。 那么其余的非最大众数呢？别担心，这些数在为最大众数服务的时候就能有一个 x 使得他们的一些能被 k 整除。例如上面的例子，我们在把 x 走到 5 的之前就有个4，可以使得数组中的 2 加上这个 4 能被 6 整除 还想不明白就想想模数具有周期性，例如将0 ~ n中的数都摸上 3 ，就会有这么一个规律 ：0 1 2 0 1 2 0 1 2 0 1 2····· 代码如下（求众数有点滑稽，因为我不会利用简单代码的求众数的方法） #include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef vector\u003cint\u003e vi; typedef vector\u003clong long\u003e vll; typedef pair\u003cint, int\u003e pii; typedef pair\u003clong long, long long\u003e pll; #define debug printf(\"(hao)\") #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i \u003c (b); i++) #define clr(a, v) memset(a, v, sizeof(a)) void solve() { long long n, k; scanf(\"%lld%lld\", \u0026n, \u0026k); vll arr; rep(i, 0, n) { long long tmp; scanf(\"%lld\", \u0026tmp); if (tmp % k != 0) //如果这个数不能被 k 整除 arr.push_back(k - tmp % k); //对于每个数把最少加多少能被 k 整除的数放到数组里 } if (arr.empty()) {//如果数组的数都能被 k 整除，操作次数就使 0 printf(\"0\\n\"); return; } sort(all(arr)); long long Max = 1, w = arr[0]; int len = arr.size(); for (int i = 1; i \u003c len;) { //求最大众数，方法比较蠢 int sen = 1; //计算出现个数 if (arr[i] == arr[i - 1]) { while (arr[i] == arr[i - 1] \u0026\u0026 i \u003c len) { sen++; i++; } } else { i++; } if (Max \u003c= sen) Max = sen, w = arr[i - 1];//如果出现次数比之前算的要多 } printf(\"%lld\\n\", w + k * (Max - 1) + 1); } // #define LOCAL int main() { std::ios::sync_with_stdio(false); #ifdef LOCAL freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif int T; scanf(\"%d\", \u0026T); while (T--) solve(); return 0; } ","date":"2020-07-06","objectID":"/2020/07/653div3problemd/:2:0","tags":["数学","思维","数组","排序","题解"],"title":"D. Zero Remainder Array题解","uri":"/2020/07/653div3problemd/"},{"categories":["cf补题"],"content":"反思 找规律的能力不强 面对模没有想到他的一个周期性 ","date":"2020-07-06","objectID":"/2020/07/653div3problemd/:3:0","tags":["数学","思维","数组","排序","题解"],"title":"D. Zero Remainder Array题解","uri":"/2020/07/653div3problemd/"},{"categories":["cf补题"],"content":"总结 对连续的数模具有一定周期性 众数的求法不熟练 这题在真正计算的时候用的不是原数组 ","date":"2020-07-06","objectID":"/2020/07/653div3problemd/:4:0","tags":["数学","思维","数组","排序","题解"],"title":"D. Zero Remainder Array题解","uri":"/2020/07/653div3problemd/"},{"categories":["cf补题"],"content":"description.","date":"2020-07-06","objectID":"/2020/07/653div3problemc/","tags":["贪心","思维","字符串","栈","题解"],"title":"C. Move Brackets题解","uri":"/2020/07/653div3problemc/"},{"categories":["cf补题"],"content":"传送门 ","date":"2020-07-06","objectID":"/2020/07/653div3problemc/:0:0","tags":["贪心","思维","字符串","栈","题解"],"title":"C. Move Brackets题解","uri":"/2020/07/653div3problemc/"},{"categories":["cf补题"],"content":"题意 给你一串字符串，只有\"(\" h和\")“组成，你每次都能选择一个字符把它移到最左边或者最右边，问你最少移动几次可以使得字符串的括号合法 ","date":"2020-07-06","objectID":"/2020/07/653div3problemc/:1:0","tags":["贪心","思维","字符串","栈","题解"],"title":"C. Move Brackets题解","uri":"/2020/07/653div3problemc/"},{"categories":["cf补题"],"content":"思路 一道贪心题（比赛的时候没看出来，太菜了😭） 只要计算出合法的括号对，然后用总长度减去合法的括号对的个数，即剩余的不合法长度除以 2 就是最少的步数 例如 ： “()))))((((()”, 去掉合法的后就是”))))((((\", 那么移动的长度就是$8 \\div 2 = 4$就是答案 这题我一开始想复杂了，对于上一个样例，我以为必须要把下标为2 ~ 5（从0开始）的先一道最左边，再把（原本的）6 ~ 9移到最左边，变成这样：\"(((())))()()\",总次数是8，所以就很搞了，然而正确答案是把6 ~ 9 移到最左边就合法了，就是这样：\"((((()))))()\",总次数就是 4 所以最终的思路就是判断合法的有多少对：在博客中遇到了两种方法，一种是用栈，一种是不用栈（根据括号合法的特性一定要左括号先出现， 即从头到尾遍历，用一个变量来储存左括号出现次数，一旦遇到右括号变量值就自减） 代码如下（用栈）： #include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef vector\u003cint\u003e vi; #define debug printf(\"(hao)\") #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i \u003c (b); i++) #define clr(a, v) memset(a, v, sizeof(a)) void solve() { int n; char bra[55]; stack\u003cchar\u003e res; scanf(\"%d\", \u0026n); scanf(\"%s\", bra); for (int i = 0; i \u003c n; i++) { if (res.empty()) res.push(bra[i]); //栈为空，就无论什么括号都放进去 else if (bra[i] == ')') //如果是右括号 if (res.top() == '(') res.pop();//栈顶是左括号，就弹出 else res.push(bra[i]); //否则把右括号入栈 else res.push(bra[i]); //如果是左括号，就直接入栈 } printf(\"%d\\n\", (int)res.size() \u003e\u003e 1); } // #define LOCAL int main() { std::ios::sync_with_stdio(false); #ifdef LOCAL freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif int T; scanf(\"%d\", \u0026T); while (T--) solve(); return 0; } ","date":"2020-07-06","objectID":"/2020/07/653div3problemc/:2:0","tags":["贪心","思维","字符串","栈","题解"],"title":"C. Move Brackets题解","uri":"/2020/07/653div3problemc/"},{"categories":["cf补题"],"content":"反思 这题我最开始是误会了求最小移动步数，后来发现是操作次数，还是没看出要贪心 遇到括号就直接想想括号的一些小性质（例如：合法的括号长度一定是偶数、括号的合法一定是左括号在前等等） 有括号优先考虑是否要用到栈来辅助 ","date":"2020-07-06","objectID":"/2020/07/653div3problemc/:3:0","tags":["贪心","思维","字符串","栈","题解"],"title":"C. Move Brackets题解","uri":"/2020/07/653div3problemc/"},{"categories":["cf补题"],"content":"总结 cf的前几题不是思维就是贪心，代码不难，但是找规律难 多刷这种题，我觉得这也是解决一些困难题目的基础 ","date":"2020-07-06","objectID":"/2020/07/653div3problemc/:4:0","tags":["贪心","思维","字符串","栈","题解"],"title":"C. Move Brackets题解","uri":"/2020/07/653div3problemc/"},{"categories":["cf补题"],"content":"传送门 ","date":"2020-07-06","objectID":"/2020/07/653div3problemb/:0:0","tags":["思维","数学","题解","模拟"],"title":"B. Multiply by 2, divide by 6题解","uri":"/2020/07/653div3problemb/"},{"categories":["cf补题"],"content":"题意 给一个数 n,问你只进行以下两种操作，要操作最少多少次能够使得 n 为 1： 把 n 除以 6 （前提是可以整除） 把 n 乘 2 输出最少的操作次数，如果无论如何都没办法得到 1，则输出 -1 ","date":"2020-07-06","objectID":"/2020/07/653div3problemb/:1:0","tags":["思维","数学","题解","模拟"],"title":"B. Multiply by 2, divide by 6题解","uri":"/2020/07/653div3problemb/"},{"categories":["cf补题"],"content":"思路 首先要知道的是，如果对一个数同时进行两个操作就相当于对 n 除以 3 思考一个极端的例子就是：n 的质因子只有 3，那么它一定可以最终得到 1。为什么呢？因为我们可以让每个 3 都乘 2， 这样他就有了因子 6， 便可以做第一个操作了，并且最终得到 1 如果这个数既有 2 又有 3 怎么办？ 很简单，只需要把一对 2 和 3 看成 6，最终剩下的因子如果是 2（因为已经无望再去除以 6 了），则不可能得到 1，如果是 3， 则当成只有因子 3 的数看待（即上述的极端情况） 最后一种情况就是 n 的质因子除了 3 和 2 还有其他的质因子的话，一定最终无法得到 1 所以最终的想法就是：计算出质因子 2 的个数a，和计算出质因子 3 的个数 b, 如果 $a \u003e b$ 则无法得到 1，否则要操作的次数最少为 $(b - a) \\times 2 + a$ 代码如下 #include \u003cbits/stdc++.h\u003eusing namespace std; typedef long long ll; typedef vector\u003cint\u003e vi; #define debug printf(\"(hao)\") #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i \u003c (b); i++) #define clr(a, v) memset(a, v, sizeof(a)) //主代码函数 void solve() { int n, a = 0, b = 0; scanf(\"%d\", \u0026n); while (n % 2 == 0) n /= 2, a++; //计算质因子 2 的个数 while (n % 3 == 0) n /= 3, b++; //计算质因子 3 的个数 if (n != 1) printf(\"-1\\n\"); //如果质因子有其他 else if (a \u003e b) printf(\"-1\\n\"); //如果 2 个数比三多，则无法得到 1 else printf(\"%d\\n\", (b - a) * 2 + a); } // #define LOCAL int main() { std::ios::sync_with_stdio(false); #ifdef LOCAL freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif int T; scanf(\"%d\", \u0026T); while (T--) solve(); return 0; } ","date":"2020-07-06","objectID":"/2020/07/653div3problemb/:2:0","tags":["思维","数学","题解","模拟"],"title":"B. Multiply by 2, divide by 6题解","uri":"/2020/07/653div3problemb/"},{"categories":["cf补题"],"content":"反思 第一次没做出来是使用了模拟的暴力解法，理论上是过了，第一次提交过了，重判之后又错在了第11个test，后来看了才发现是爆int了一定是因为我第一次打cf比赛的原因 看到int范围就要优先考虑使用long long不然这题我也不会错 最知道思考的是本文的解法，思维题嘛，锻炼自己思维，毕竟不是每道思维题都可以直接模拟 ","date":"2020-07-06","objectID":"/2020/07/653div3problemb/:3:0","tags":["思维","数学","题解","模拟"],"title":"B. Multiply by 2, divide by 6题解","uri":"/2020/07/653div3problemb/"},{"categories":["cf补题"],"content":"总结 遇到这种题尝试思考因子的问题 在草稿纸上找找规律，毕竟cf就喜欢考这些思维题 ","date":"2020-07-06","objectID":"/2020/07/653div3problemb/:4:0","tags":["思维","数学","题解","模拟"],"title":"B. Multiply by 2, divide by 6题解","uri":"/2020/07/653div3problemb/"},{"categories":["成长心得"],"content":"1、写在前面 这几天疯狂刷leetcode的dp题，刷到我都想吐了，看到一个题就先往dp想，感觉中毒不浅，话不多说，赶紧开始总结一下我的成长历程心得。 ","date":"2020-06-27","objectID":"/2020/06/dynamicprogramming/:1:0","tags":["动态规划"],"title":"动态规划刷题总结","uri":"/2020/06/dynamicprogramming/"},{"categories":["成长心得"],"content":"2、我对dp的看法和理解 首先引入《算法笔记》里的一句话: 动态规划是一种非常精妙的算法思想，他没有固定的写法、极其灵活，常常需要具体问题具体分析。 没错正式这种具体问题具体分析的设定让我刷到吐了 平时在思考动态规划的往往是利用一个小小的公式：递推 = 递归 + 记忆化（下面会赘述我是怎么利用这个公式思考的） 虽然他是这么说，但是我还是觉得dp的是有套路可循的，例如给dp分类 （背包dp、树形dp、区间dp……），经典题的记忆 （爬楼梯、树塔问题、LIS……） 一般来说，我思考dp都是从结果往前想的（即从末尾开始想） dp的基本使用条件： 1. 拥有重叠子问题、 2. 最优子结构、3.无后效性 dp思考三步走： 1. 状态定义 → 2.列状态转移方程 → 3.验证方程 我觉得的动规成长路线：小白 → 利用小公式辅助建立dp → 正常dp三步走思维思考 → 大佬 （我还没触及 将来一定达到( ఠൠఠ )ﾉ） ","date":"2020-06-27","objectID":"/2020/06/dynamicprogramming/:2:0","tags":["动态规划"],"title":"动态规划刷题总结","uri":"/2020/06/dynamicprogramming/"},{"categories":["成长心得"],"content":"3、典型例题 ","date":"2020-06-27","objectID":"/2020/06/dynamicprogramming/:3:0","tags":["动态规划"],"title":"动态规划刷题总结","uri":"/2020/06/dynamicprogramming/"},{"categories":["成长心得"],"content":"①爬楼梯（leetcode #70） 题意 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1、 1 阶 + 1 阶 2、 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1、 1 阶 + 1 阶 + 1 阶 2、 1 阶 + 2 阶 3、 2 阶 + 1 阶 分析 （抛开动规，假设我们是小白）我的思考过程，利用上述提到的小小公式（递推 = 递归 + 记忆化 首先：从末尾结果开始想，如果我们要走到最后一个台阶,那么我们就有两种走到这个台阶的方法：一是从这一个台阶的前一个台阶上来、二是从这个台阶的前第二个台阶上来。如图： 这样我们就很容易想到到达最后一个台阶的方法数为到前一个台阶的方法数加上到前第二个台阶的方法数，可能很拗口。看下面的公式就懂了。 设 dp(n) 为到台阶n的总方法数，这样很容易就能写出这个方法数的公式为： $$ dp(n) = dp(n - 1) + dp(n - 2) $$ 不难写出递归代码 int dp(int n){ if(n == 1 || n == 0) return 1; return dp(n - 1) + dp(n - 2); } 仔细分析一下这个代码，时间复杂度不难发现式O(2^n)，例如假设我们求的是dp(5) 不难发现有很多重复计算(黄色部分)，这里采取了一个比较好的优化方法–记忆化递归（是不是觉得很接近那个小公式了？别急看代码） const int Max = 50; int memor[Max] = {0}; int dp(int n) { if (n == 1 || n == 0) return 1; if (memor[n] != 0) return memor[n]; memor[n] = dp(n - 1) + dp(n - 2); return memor[n]; } 时间复杂度降到了O(n),就是变成这样 两者时间对比： 普通递归计算dp(45) : 3464 ms 记忆化递归计算dp(45) : 1 ms 天壤之别！！！ 回过头来看这题，这题是一个典型的动规问题，那么我是怎么利用那个小公式来思考这个题的状态方程的呢，很简单就是按照刚刚的思路走一遍。 不难发现我们按照那个思路走，其实已经写出了转移状态方程，就是下面这个，并且这个方程的含义就是我们递归时的含义，这就相当于一下完成了dp三步走的前两步。 $$ dp(n) = dp(n - 1) + dp(n - 2) $$ 接下来的一步就是检查（验证）方程，首先我们要思考这道题适不适合用动规的方法来写，这就需要我们验证这个题是否满足1.有重叠子问题，2.有最优子结构。重叠子问题的话，刚刚分析递归的时候已经发现了，并且优化后不会出现重复计算子问题；最优子结构就是分析没有个状态（即dp(n)）是否是最优的解，在一开始分析题目时不难发现每一个台阶的步数只取决于他前两个台阶的步数。 验证方程的最后一步，设定状态边界（我们总不可能让他一直计算下去吧），其实这道题的边界就是我们一开始的递归边界。 到了这里dp的代码就不难了,递归式自顶向下地计算，而我们动规就是自顶向下地思考，自底向上地计算，多说无益，上代码 const int Max = 50; int dp[Max], n; int main() { scanf(\"%d\", \u0026n); dp[0] = 1, dp[1] = 1; for (int i = 2; i \u003c= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } printf(\"%d\", dp[n]); return 0; } 时间复杂度同样是O(n),虽然还有更快O(logn)的方式解这题，但我们现在是小白呀，下次再聊。 小结 通过这道题我们从小白晋级到了会用小公式来思考dp。 1、首先从末尾结果开始思考 2、思考怎么递归 3、再来就是写出递归的的方程 4、分析递归，去除重叠问题 5、转换成dp思想，直接走dp三步走的第三步，检查是否状态方程，若不满足，回到1看看有没有另一种更好的办法（一般不会出现这种情况),当然还有另一种方法就是在原有的基础上再次优化（这些都是后话）；若满足直接dp走你。 写不动了未完待续…… ","date":"2020-06-27","objectID":"/2020/06/dynamicprogramming/:3:1","tags":["动态规划"],"title":"动态规划刷题总结","uri":"/2020/06/dynamicprogramming/"}]