[{"categories":["刷题"],"content":" 狂补dp Atcoder Educational DP Contest(全) ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:0:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"注意 为了减少篇幅，本博客代码部分只放主代码部分，其余省略快读、快输、头文件等代码，即把代码看做伪代码更佳 ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:0:1","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"A - Frog 1 幼儿级别的dp，直接dp便可 void problem() { int n = IO(); for (int i = 0; i \u003c n; ++i) num[i] = IO(); for (int i = 1; i \u003c n; ++i) { dp[i] = dp[i - 1] + abs(num[i] - num[i - 1]); if (i \u003e= 2) dp[i] = min(dp[i], dp[i - 2] + abs(num[i] - num[i - 2])); } print(dp[n - 1]); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:1:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"B - Frog 2 还是幼儿级别，比A题多了一重循环 void problem() { int n = IO(), k = IO(); for (int i = 0; i \u003c n; ++i) num[i] = IO(); for (int i = 1; i \u003c n; ++i) { dp[i] = dp[i - 1] + abs(num[i] - num[i - 1]); for (int j = 2; j \u003c= min(k, i); ++j) { if (i \u003e= j) dp[i] = min(dp[i], dp[i - j] + abs(num[i] - num[i - j])); } } print(dp[n - 1]); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:2:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"C - Vacation 根据题意定义一个二维dp，第二维表示当前选的是哪个，然后转移就很简单了 void problem() { int n = IO(); for (int i = 1; i \u003c= n; ++i) a[i] = IO(), b[i] = IO(), c[i] = IO(); for (int i = 1; i \u003c= n; ++i) { dp[i][0] = max(dp[i - 1][1], dp[i - 1][2]) + a[i]; dp[i][1] = max(dp[i - 1][0], dp[i - 1][2]) + b[i]; dp[i][2] = max(dp[i - 1][1], dp[i - 1][0]) + c[i]; } print(max({dp[n][0], dp[n][1], dp[n][2]})); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:3:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"D - Knapsack 1 01背包问题 void problem() { int n = IO(), m = IO(); for (int i = 1; i \u003c= n; ++i) w[i] = IO(), v[i] = IO(); for (int i = 1; i \u003c= n; ++i) { for (int j = m; j \u003e= w[i]; --j) dp[j] = max(dp[j], dp[j - w[i]] + v[i]); } print(dp[m]); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:4:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"E - Knapsack 2 01背包+换意dp 原本定义 dp[i] 表示容量不超过 i 能装的最大价值 由于背包容量过大，但我们不难发现物品的价值不大，可以对状态定义进行换意 即定义 dp[i] 表示装价值为 i 物品所花费的最小容量 void problem() { int n = IO(), m = IO(); for (int i = 1; i \u003c= n; ++i) w[i] = IO(), v[i] = IO(); fill_n(dp, N, INF); dp[0] = 0; for (int i = 1; i \u003c= n; ++i) { for (int j = 100000; j \u003e= v[i]; --j) { dp[j] = min(dp[j], dp[j - v[i]] + w[i]); } } for (int i = 100000; i \u003e= 0; --i) { if (dp[i] \u003c= m) { print(i); break; } } } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:5:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"F - LCS LCS+dp求具体方案 dp求具体方案我还是喜欢递归找，复杂度O($n$) void solve(int n, int m) { if (n == 0 || m == 0) { reverse(all(ans)); for (char\u0026 c : ans) putchar(c); exit(0); return; } if (dp[n][m] == dp[n - 1][m]) solve(n - 1, m); else if (dp[n][m] == dp[n][m - 1]) solve(n, m - 1); else { ans.push_back(a[n]); solve(n - 1, m - 1); } } void problem() { scanf(\"%s\\n%s\", a + 1, b + 1); int n = strlen(a + 1), m = strlen(b + 1); for (int i = 1; i \u003c= n; ++i) { for (int j = 1; j \u003c= m; ++j) { if (a[i] == b[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]); } } solve(n, m); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:6:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"G - Longest Path 拓扑dp 可以bfs转移，但我是dfs转移的 值得注意的是，状态定义为 dp[i] 表示从 i 点出发能走的最远距离好转移一些 int dfs(int u) { if (dp[u] != -1) return dp[u]; int\u0026 res = dp[u] = 0; for (int\u0026 v : mp[u]) { res = max(res, dfs(v) + 1); } return res; } void problem() { int n = IO(), m = IO(); for (int i = 0; i \u003c m; ++i) { int u = IO(), v = IO(); mp[u].pb(v); ++du[v]; } fill_n(dp + 1, n, -1); for (int i = 1; i \u003c= n; ++i) if (!du[i]) ans = max(dfs(i), ans); print(ans, '\\n'); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:7:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"H - Grid 1 走格子，老dp模型了 void problem() { int n = IO(), m = IO(); for (int i = 1; i \u003c= n; ++i) scanf(\"%s\", g[i] + 1); dp[0][1] = 1; for (int i = 1; i \u003c= n; ++i) { for (int j = 1; j \u003c= m; ++j) { if (g[i][j] != '.') continue; dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod; } } print(dp[n][m]); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:8:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"I - Coins 简单的一个概率dp 定义 dp[i][j] 表示前 i 个硬币中人头朝上的个数为 j 的概率 void problem() { int n = IO(); for (int i = 1; i \u003c= n; ++i) scanf(\"%lf\", p + i); dp[0][0] = 1; for (int i = 1; i \u003c= n; ++i) { dp[i][0] = dp[i - 1][0] * (1.0 - p[i]); for (int j = 1; j \u003c= i; ++j) { dp[i][j] += dp[i - 1][j - 1] * p[i] + dp[i - 1][j] * (1.0 - p[i]); } } double ans; for (int i = 1; i \u003c= n; ++i) { if (i \u003e n - i) ans += dp[n][i]; } printf(\"%.9f\\n\", ans); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:9:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"J - Sushi 期望dp 突破口就是每个盘子上的寿司不超过3个，计数寿司个数为 i 的盘子有几个 定义 dp[i][j][k] 表示剩下 i 个盘子上面只有1个寿司， j 个盘子上面只有2个寿司， k 个盘子只有3个寿司的期望值 转移的话，递归记忆化转移比较方便 double dfs(int a, int b, int c) { if (a + b + c == 0) return 0; if (vis[a][b][c]) return dp[a][b][c]; vis[a][b][c] = 1; double tot = a + b + c; double \u0026res = dp[a][b][c] = n * 1.0 / tot; if (a) res += dfs(a - 1, b, c) * a / tot; if (b) res += dfs(a + 1, b - 1, c) * b / tot; if (c) res += dfs(a, b + 1, c - 1) * c / tot; return res; } void problem() { n = IO(); int num[4] = {0}; for (int i = 0; i \u003c n; ++i) { int x = IO(); ++num[x]; } printf(\"%.10f\", dfs(num[1], num[2], num[3])); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:10:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"K - Stones 基础博弈dp void problem() { int n = IO(), k = IO(); for (int i = 0; i \u003c n; ++i) a[i] = IO(); dp[0] = 0; for (int i = 1; i \u003c= k; ++i) { int ok = 0; for (int j = 0; j \u003c n; ++j) { if (i \u003c a[j]) continue; if (dp[i - a[j]] == 0) { ok = 1; // 如果有一个必输点，则他必赢 break; } } dp[i] = ok; } puts(dp[k] ? \"First\" : \"Second\"); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:11:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"L - Deque 区间dp+思维 转变一下思路，先手希望 X-Y 最大，后手希望 X-Y 最小，即后手希望 Y-X最大，即都希望自己的分数减去对手的分数达到最大 设 dp[l][r] 表示 [l, r] 区间中先手分数减去后手分数的最大值，转移的话，便是用决策 加上 负数的dp值 即 dp[l][r] = max(a[r] + (-dp[l][r - 1]), a[l] + (-dp[l + 1][r])) void problem() { int n = IO(); for (int i = 1; i \u003c= n; ++i) a[i] = IO(), dp[i][i] = a[i]; for (int i = n; i; --i) { for (int j = i; j \u003c= n; ++j) { dp[i][j] = max(a[j] - dp[i][j - 1], a[i] - dp[i + 1][j]); } } print(dp[1][n]); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:12:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"M - Candies 多重背包问题 直接三重循环的话会超时，像这样的代码 dp[0][0] = 1; for (int i = 1; i \u003c= n; ++i) { for (int j = 0; j \u003c= m; ++j) { for (int k = 0; k \u003c= min(a[i], j); ++k) { dp[i][j] += dp[i - 1][j - k]; } } } 但我们不难发现第三重循环是可以优化掉的 分析 dp[i][j] 他的转移只会从 dp[i - 1][x] （其中 j - a[i] \u003c= x \u003c= j ）转移过来，固我们可以用前缀和与滑动窗口的思想来进行优化掉第三重循环 void problem() { int n = IO(), m = IO(); for (int i = 1; i \u003c= n; ++i) a[i] = IO(); dp[0][0] = 1; for (int i = 1; i \u003c= n; ++i) { ll sum = 0; for (int j = 0; j \u003c= m; ++j) { sum += dp[i - 1][j]; dp[i][j] = (sum + mod) % mod; if (j \u003e= a[i]) sum -= dp[i - 1][j - a[i]]; } } print(dp[n][m]); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:13:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"N - Slimes 区间dp入门题 void problem() { int n = IO(); memset(dp, 0x3f, sizeof dp); for (int i = 1; i \u003c= n; ++i) a[i] = IO(), sum[i] = sum[i - 1] + a[i], dp[i][i] = 0; for (int i = n; i \u003e= 1; --i) { for (int j = i; j \u003c= n; ++j) { // [i, j] 区间 for (int k = i; k \u003c j; ++k) { dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + sum[j] - sum[i - 1]); } } } print(dp[1][n]); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:14:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"O - Matching 状压dp 本质就是二分图完美匹配的方案数 设 dp[i][j] 表示正在决策第 i (下标从0开始)个男生，且前 i 个男生匹配好的女生为 j（二进制） 转移用刷表法转移比较好 ll dp[22][(1 \u003c\u003c 21) + 10]; vector\u003cint\u003e vt[22]; int count(int x) { int res = 0; while (x) { x \u0026= x - 1; res++; } return res; } int m[25][25]; void problem() { int n = IO(); for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c n; ++j) { m[i][j] = IO(); } } dp[0][0] = 1; int len = 1 \u003c\u003c n; for (int i = 0; i \u003c len; ++i) vt[count(i)].push_back(i); for (int i = 0; i \u003c n; ++i) { for (int j : vt[i]) { for (int k = 0; k \u003c n; ++k) { if (j \u0026 (1 \u003c\u003c k)) continue; if (!m[i][k]) continue; dp[i + 1][j ^ (1 \u003c\u003c k)] += dp[i][j]; dp[i + 1][j ^ (1 \u003c\u003c k)] %= mod; } } } print(dp[n][len - 1]); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:15:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"P - Independent Set 树上dp 有点类似树上独立集了 vector\u003cint\u003e mp[N]; ll dp[N][2]; // i号结点为0/1色的方案数 void dfs(int u, int fa) { dp[u][0] = dp[u][1] = 1; for (int\u0026 v : mp[u]) { if (v == fa) continue; dfs(v, u); dp[u][1] = dp[v][0] * dp[u][1] % mod; dp[u][0] = dp[u][0] * (dp[v][0] + dp[v][1]) % mod; } } void problem() { int n = IO(); for (int i = 1; i \u003c n; ++i) { int u = IO(), v = IO(); mp[u].pb(v), mp[v].pb(u); } dfs(1, 0); printf((dp[1][0] + dp[1][1]) % mod); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:16:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"Q - Flowers LIS的变种，需要用线段树优化 const int N = 2e5 + 5; struct pairs { int indx, h; ll a; }p[N]; ll seg[N \u003c\u003c 2]; void update(int indx, ll v, int l, int r, int node = 1) { if (l == r) { seg[node] = v; return; } int mid = (l + r) \u003e\u003e 1; if (indx \u003c= mid) update(indx, v, l, mid, node \u003c\u003c 1); else update(indx, v, mid + 1, r, node \u003c\u003c 1 | 1); seg[node] = max(seg[node \u003c\u003c 1], seg[node \u003c\u003c 1 | 1]); } ll get(int ql, int qr, int l, int r, int node = 1) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) return seg[node]; int mid = (l + r) \u003e\u003e 1; ll ret = 0; if (ql \u003c= mid) ret = get(ql, qr, l, mid, node \u003c\u003c 1); if (qr \u003e mid) ret = max(ret, get(ql, qr, mid + 1, r, node \u003c\u003c 1 | 1)); return ret; } void problem() { int n = IO(); for (int i = 1; i \u003c= n; ++i) { p[i].indx = i; p[i].h = IO(); } for (int i = 1; i \u003c= n; ++i) p[i].a = IO(); sort(p + 1, p + 1 + n, [](pairs\u0026 i, pairs\u0026 j) { return i.h \u003c j.h; }); ll ans = 0; for (int i = 1; i \u003c= n; ++i) { ll maxv = get(1, p[i].indx, 1, n) + p[i].a; update(p[i].indx, maxv, 1, n); ans = max(maxv, ans); } printf(ans); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:17:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"R - Walk 不多说，考的就是矩阵乘法在图中的意义（结论题） 矩阵A的n次幂表示走n次x到y的方案数，对于本题就是求矩阵的k次幂，再求结果矩阵上各个点上的和即可 #define vi vector\u003cll\u003e #define Mat vector\u003cvi\u003e Mat operator* (Mat a, Mat b) { Mat res(N, vi(N, 0)); for (int i = 0; i \u003c N; ++i) for (int j = 0; j \u003c N; ++j) for (int k = 0; k \u003c N; ++k) res[i][j] = (res[i][j] + a[i][k] * b[k][j] % mod) % mod; return res; } Mat operator^ (Mat a, long long b) { Mat res(N, vi(N, 0)); for (int i = 0; i \u003c N; ++i) res[i][i] = 1; while (b) { if (b \u0026 1) res = res * a; a = a * a, b \u003e\u003e= 1; } return res; } void problem() { ll n = IO(), k = IO(); Mat mat(N, vi(N, 0)); for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c n; ++j) { mat[i][j] = IO(); } } Mat res = mat ^ k; ll ans = 0; for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c n; ++j) { ans = (res[i][j] + ans) % mod; } } printf(ans); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:18:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"S - Digit Sum 数位dp入门题 对于数位dp，记忆化搜比较好理解 int num[N], len, n; ll dp[N][2][101]; ll dfs(int x, int limit, int m) { ll \u0026res = dp[x][limit][m]; if (~res) return res; if (x == 0) return res = (m == 0); res = 0; int up = (limit ? num[x] : 9); for (int i = 0; i \u003c= up; ++i) { res += dfs(x - 1, limit \u0026\u0026 i == up, (m + i) % n); res %= mod; } return res; } void problem() { string s; cin \u003e\u003e s \u003e\u003e n; len = s.size(); for (int i = 0, j = len; i \u003c len; ++i, --j) num[j] = s[i] - '0'; memset(dp, -1, sizeof dp); print(((dfs(len, 1, 0) - 1) % mod + mod) % mod); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:19:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"T - Permutation 比较思维的一道dp题 设 dp[i][j] 表示前 i 个排列中（包括 i ）最后一位放的是 j 的方案数 转移的话要注意，当前第 i 个放的 j ,转移利用到的第 i - 1 的排列中将小于 j 的视为小于 j ，大于等于 j 的视为严格大于 j 由于转移的时候是要三重循环，但草稿可以发现第三种循环可以优化掉的，看代码就懂了 int n; string s; ll dp[N][N]; void problem() { cin \u003e\u003e n \u003e\u003e s; dp[1][1] = 1; for (int i = 2; i \u003c= n; ++i) { if (s[i - 2] == '\u003c') { dp[i][1] = 0; for (int j = 2; j \u003c= i; ++j) { dp[i][j] = (dp[i - 1][j - 1] + dp[i][j - 1]) % mod; } } else { dp[i][i] = 0; for (int j = i - 1; j; --j) { dp[i][j] = (dp[i - 1][j] + dp[i][j + 1]) % mod; } } } ll ans = 0; for (int i = 1; i \u003c= n; ++i) { ans = (ans + dp[n][i]) % mod; } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:20:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"U - Grouping 状压dp 本题对于状压刚入门的童鞋可能比较难，但通过这题只要记住状压是怎么枚举所有子集的便可 这里写一遍，还要注意，枚举的复杂度为 O($3^n$) for (int s1 = s; s1; s1 = (s1 - 1) \u0026 s) { int s2 = s ^ s1; // s1 与 s2 互为 s 的补集，且s1与s2不会重复，即利用s1与s2可以不重不漏地枚举完所有子集 } 本题要的是真子集，所以要改改 void problem() { int n = IO(), m = 1 \u003c\u003c n; for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c n; ++j) { a[i][j] = IO(); } } for (int i = 1; i \u003c m; ++i) { for (int j = 0; j \u003c n; ++j) { if (((i \u003e\u003e j) \u0026 1) == 0) continue; for (int k = j + 1; k \u003c n; ++k) { if (((i \u003e\u003e k) \u0026 1) == 0) continue; dp[i] += a[j][k]; } } for (int j = i \u0026 (i - 1); j; j = (j - 1) \u0026 i) { dp[i] = max(dp[i], dp[j] + dp[j ^ i]); } } print(dp[m - 1]); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:21:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"V - Subtree 换根dp 换根过程中，考虑到模数可能不为质数，所以要记录每颗子树的前后缀积， void dfs(int u, int fa) { dp[u] = 1; pre[u].push_back(1); for (int v : edg[u]) { if (v == fa) continue; dfs(v, u); dp[u] = dp[u] * (1 + dp[v]) % m; pre[u].pb(dp[u]); } for (int i = (int)edg[u].size() - 1; i \u003e= 0; --i) { int v = edg[u][i]; if (v == fa) continue; ll tmp = (dp[v] + 1) % m; if (last[u].size()) tmp = last[u].back() * tmp % m;; last[u].pb(tmp); } reverse(all(last[u])); last[u].pb(1); } void solve(int u, int fa, ll sub) { int indx_pre = 0, indx_last = 1; for (int v : edg[u]) { if (v == fa) continue; ll tmp = pre[u][indx_pre++] * last[u][indx_last++] % m; // printf(\"%d %d\\n\", u, tmp); f[v] = (sub * tmp % m + 1) * dp[v] % m; solve(v, u, (tmp * sub + 1) % m); } } void problem() { n = IO(), m = IO(); for (int i = 1; i \u003c n; ++i) { int u = IO(), v = IO(); edg[u].pb(v), edg[v].pb(u); } dfs(1, 0); f[1] = dp[1]; solve(1, 0, 1); for (int i = 1; i \u003c= n; ++i) print(f[i], '\\n'); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:22:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"W - Intervals 线段树优化dp 这题有点意思，一开始没发现要数据结构优化，怎么想都觉得是一个O($n^3$)的dp，后来发现可以用线段树优化成O($nlogn$) 设 dp[i] 表示前 i 长度的字符串中，第 i 个位置必填 1 的最大价值 然后先看转移方程，设结构体 p 为题中的区间 $$ dp[i] = dp[j] + p[k].a $$ $$ 其中 0 \u003c= j \u003c i $$ $$ 并且 j \u003c p[k].l \\le i $$ $$ 且p[k].r \\ge i $$ 不难发现，暴力的话，这样转移是 O($n^3$) 但我们会发现对于一个 p[k].l \u003c= i 的区间，所有 j \u003c p[k].l 的 dp[j] 都必须要加上这个区间，然后就很容易想到将所有区间按左端点升序排序，然后线段树进行转移便可，让区间 [0, p[k].l - 1] 的所有dp值加上 p[k].a ， 记得加完要减回去 看代码简单易懂 #define ls node \u003c\u003c 1 #define rs (ls) | 1 struct pii { int x, y, v; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; struct nodes{ ll maxv, lazy; }; const int N = 1e5 + 10, M = 1e6 + 10; ll dp[M \u003c\u003c 1]; pii q[N \u003c\u003c 1]; nodes seg[N \u003c\u003c 3]; vector\u003cint\u003e pos[N \u003c\u003c 1]; void push_down(int node) { ll \u0026tmp = seg[node].lazy; if (!tmp) return; seg[ls].lazy += tmp; seg[rs].lazy += tmp; seg[ls].maxv += tmp; seg[rs].maxv += tmp; tmp = 0; assert(seg[node].lazy == 0); } void update_range(int ql, int qr, ll v, int l, int r, int node = 1) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) { seg[node].lazy += v; seg[node].maxv += v; return; } push_down(node); int mid = (l + r) \u003e\u003e 1; if (ql \u003c= mid) update_range(ql, qr, v, l, mid, ls); if (qr \u003e mid) update_range(ql, qr, v, mid + 1, r, rs); seg[node].maxv = max(seg[ls].maxv, seg[rs].maxv); } void update_pos(int indx, ll v, int l, int r, int node = 1) { if (l == r) { seg[node].maxv = v; return; } push_down(node); int mid = (l + r) \u003e\u003e 1; if (indx \u003c= mid) update_pos(indx, v, l, mid, ls); else update_pos(indx, v, mid + 1, r, rs); seg[node].maxv = max(seg[ls].maxv, seg[rs].maxv); } ll query_range(int ql, int qr, int l, int r, int node = 1) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) return seg[node].maxv; push_down(node); int mid = (l + r) \u003e\u003e 1; ll ret = -llf; if (ql \u003c= mid) ret = query_range(ql, qr, l, mid, ls); if (qr \u003e mid) ret = max(ret, query_range(ql, qr, mid + 1, r, rs)); return ret; } void problem() { int n = IO(), m = IO(); for (int i = 0; i \u003c m; ++i) { q[i].x = IO(), q[i].y = IO(), q[i].v = IO(); } sort(q, q + m); for (int i = 0; i \u003c m; ++i) pos[q[i].y].push_back(i); ll ans = 0; for (int i = 1, j = 0; i \u003c= n; ++i) { while (j \u003c m \u0026\u0026 q[j].x \u003c= i) { update_range(0, q[j].x - 1, q[j].v, 0, n); j += 1; } dp[i] = query_range(0, i - 1, 0, n); update_pos(i, dp[i], 0, n); for (int p : pos[i]) update_range(0, q[p].x - 1, -q[p].v, 0, n); ans = max(ans, dp[i]); } print(ans); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:23:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"X - Tower 贪心+01背包 dp前的贪心排序要大胆地猜，然后证明 用领项交换法的思路去思考，当前决策相邻的两个物品 $w_i, s_i$ 和 $w_j,s_j$ ，前面物品（假设合法）的重量为 $X$，若以 $i$ 在 $j$ 上的顺序放的话 $j$ 物品还能承受的重量为 $s_j - X - w_i$，反之 $i$ 物品还能承受的重量为 $s_i - X - w_j$，我们当然是想让 后面的更能承受重量，固 $s_j - X - w_i \u003e s_i - X - w_j$，化简，我们就能发现只需要按 $s_i + w_i \u003c s_j + w_j$ 排序，最后01背包找答案便可 struct pii { int w, s; ll v; bool operator\u003c (const pii\u0026 j) { return w + s \u003c j.w + j.s; } }; pii p[1010]; ll dp[20010]; void problem() { int n = IO(); for (int i = 0; i \u003c n; ++i) { p[i].w = IO(), p[i].s = IO(), p[i].v = IO(); } sort(p, p + n); for (int i = 0; i \u003c n; ++i) { for (int j = p[i].s + p[i].w; j \u003e= p[i].w; --j) { dp[j] = max(dp[j], dp[j - p[i].w] + p[i].v); } } print(*max_element(dp, dp + 20001)); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:24:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"Y - Grid 2 数学+dp 显然不能直接dp，会超时 如果是n*m的格子，无障碍的话方案数就是 $C^{n - 1}_{n + m - 2}$ 找突破口，发现障碍的点不多 设 dp[i] 表示从 (1, 1) 到第 i 个障碍的方案数，下面是转移 设第 j 个障碍点在第 i 个障碍点的左上方，再设从第 j 个障碍点到第 i 个障碍点形成的格子是 x * y 的，则 $$ dp[i] += dp[j] * C^{x - 1}_{x + y - 2} $$ 最后的答案便是将所有点往 (n, m) 点转移得到的答案 之间看代码，注意转移的顺序 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } struct pii { int x, y; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; ll dp[N], f[N * 2], inv[N * 2]; pii p[3010]; ll comb(int n, int m) { if (n \u003c m) return 0; return f[n] * inv[m] % mod * inv[n - m] % mod; } void problem() { f[0] = inv[0] = 1; for (int i = 1; i \u003c= 200000; ++i) { f[i] = f[i - 1] * i % mod; inv[i] = powf(f[i], mod - 2, mod); } int h = IO(), w = IO(), n = IO(); for (int i = 0; i \u003c n; ++i) { p[i].x = IO(), p[i].y = IO(); } sort(p, p + n); for (int i = 0; i \u003c n; ++i) { dp[i] = comb(p[i].x + p[i].y - 2, p[i].x - 1); } for (int i = 0; i \u003c n; ++i) { for (int j = 0; j \u003c i; ++j) { if (p[j].x \u003c= p[i].x \u0026\u0026 p[j].y \u003c= p[i].y) { int x = p[i].x - p[j].x + 1, y = p[i].y - p[j].y + 1; dp[i] = dp[i] - dp[j] * comb(x + y - 2, x - 1) % mod; dp[i] = (dp[i] + mod) % mod; } } } ll ans = comb(h + w - 2, h - 1); for (int i = 0; i \u003c n; ++i) { int x = h - p[i].x + 1, y = w - p[i].y + 1; ans = ans - dp[i] * comb(x + y - 2, x - 1) % mod; ans = (ans + mod) % mod; } print(ans); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:25:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":"Z - Frog 3 斜率优化的dp 当他写出 $(h_j - h_i)^2 + C$ 的时候，用膝盖想都能猜到是要斜率优化了，再加上h数组还递增，好家伙，二分都省了 const int N = 1e5 + 10, M = 1e6 + 10; ll a[M * 2], dp[M * 2], q[M * 2]; ll pow2(ll x) { return x * x; } ll gety(int i) { return dp[i] + pow2(a[i]); } ll getx(int i) { return a[i]; } int push_check(int j, int k, int i) { return gety(k) - gety(j) \u003c 2 * a[i] * (getx(k) - getx(j)); } int pop_check(int j, int k, int i) { return (gety(k) - gety(j)) * (getx(i) - getx(k)) \u003e (gety(i) - gety(k)) * (getx(k) - getx(j)); } void problem() { int n = IO(); ll m = IO(); fill_w(a + 1, n); dp[1] = 0; int l = 0, r = -1; q[++r] = 1; for (int i = 2; i \u003c= n; ++i) { while (l \u003c r \u0026\u0026 push_check(q[l], q[l + 1], i)) ++l; dp[i] = dp[q[l]] + pow2(a[i] - a[q[l]]) + m; while (l \u003c r \u0026\u0026 pop_check(q[r - 1], q[r], i)) --r; q[++r] = i; } print(dp[n]); } ","date":"2021-08-24","objectID":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/:26:0","tags":["题解","动态规划"],"title":"狂补dp Atcoder Educational DP Contest(全)","uri":"/2021/08/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/"},{"categories":["刷题"],"content":" 题意：一颗树上有很多点，0号点为根结点，边有边权即距离，点有点权即该点产量，点产生的运到一个建有伐木场的点的费用是其点到点的距离乘上产量（0号结点一开始就有伐木场，其余结点没有），问你给m个结点建造伐木场，最后最小运送费用为多少？ 一开始状态定义错了，定义 dp[u][k][1/0] 表示以u为根的子树，建造k个伐木场，该点建/不建伐木场的最小费用，交上去只有52分，想了一下，虽然这样定义转移是能转，但是有后效性 后来看了一下别人的思路，发现自己状态可以加一维来消除后效性 定义 dp[u][k][fa][1/0] 表示以u为根的子树，建造k个伐木场，fa为u的某个祖先，且该祖先为距离u点最近的建造了伐木场的点，而该点建/不建伐木场的产生的最小费用（不包括u点运到fa的费用） 转移 k = i + j dp[u][k][fa][0] = min{ dp[u][k][fa][0], dp[u][i][fa][0] + dp[v][j][fa][0] + (dep[v] - dep[fa]) * w[v], dp[u][i][fa][0] + dp[v][j][fa][1] } dp[u][k][fa][1] = min{ dp[u][k][fa][1], dp[u][i][fa][1] + dp[v][j][u][0] + (dep[v] - dep[u]) * w[v], dp[u][i][fa][1] + dp[v][j][u][1] } 初始化dp看代码 至于fa可以利用一个vector来记录，最后回溯去掉便可 具体看代码函数区 #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\" = %lld\\n\", (ll)x) #define dcout(x) cout \u003c\u003c #x \u003c\u003c \" = \" \u003c\u003c x \u003c\u003c endl #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } int getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = 0x3f3f3f3f; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1.0); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 2e2 + 10, M = 1e6 + 10; int num[M], dep[N], dp[N][N][N][2], tmp[N][N][2]; vi\u003cint\u003e f; int n, m; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ int head[N], cnt; //初始化 void init(int n) { fill_n(head, n + 5, -1); cnt = -1; } struct edges { int to, next; int w; void add(int t, int n, int w) { to = t, next = n, this-\u003ew = w; } }edge[N \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v, int w) { edge[++cnt].add(v, head[u], w); head[u] = cnt; } /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ int dfs(int u) { f.pb(u); int sum = 1; for (auto fa : f) { // 初始化 dp[u][0][fa][0] = 0; dp[u][1][fa][1] = 0; } rep(u, i, edge) { int v = edge[i].to; dep[v] = dep[u] + edge[i].w; int son = dfs(v); for (auto fa : f) { // if (fa == u) continue; for (int j = 0; j \u003c= sum + son; ++j) { tmp[j][fa][0] = tmp[j][fa][1] = inf; } for (int j = 0; j \u003c= sum; ++j) { for (int k = 0; k \u003c= son; ++k) { if (j + k \u003e m) break; tmp[j + k][fa][0] = min({ tmp[j + k][fa]","date":"2021-08-20","objectID":"/2021/08/%E6%B4%9B%E8%B0%B7-3354-riv-%E6%B2%B3%E6%B5%81/:0:0","tags":["题解","树形dp","背包问题"],"title":"洛谷 3354 Riv 河流","uri":"/2021/08/%E6%B4%9B%E8%B0%B7-3354-riv-%E6%B2%B3%E6%B5%81/"},{"categories":["刷题"],"content":" 题意：有 n 个人，第 i 个人想送给第 p[i] 个人一份礼物，保证 p 数组是一个排列且 p[i] != i ，如果 i 忘记带礼物，则 i 和 p[i] 都不会受到礼物，问恰好有 k 个人忘记带礼物，最少和最多有几个人收不到礼物 如果将送礼物的线路做成图，则将会行形成若干个环。 当一个人忘记带礼物时，则会有两个人收不到礼物 固最大值可以利用贪心来计算，设某个环的大小为 x ，若 x 偶数，则只需要让 k / 2 的人忘记带礼物便可让整个环的人多不能收到礼物；若 x 为奇数，则可以先让 (x - 1) / 2 个人忘记带礼物，此时还差一个人能够收到礼物，只需特判此人是否需要忘记带礼物才能达到恰好 k 个人忘记带便可 再来考虑最小值，这个也考虑贪心做，首先如果某个环的大小为 x , 若要环内的 y 个人忘记带礼物，则如果 y \u003c x 那么最贪心的方式就是让连续 y 个人忘记带礼物，则有 y + 1 个人收不到礼物（这是最贪心的方式了）,若 x == y 则环内所有人都收不到礼物 固最小值的答案可以推得为：若某些环的大小和恰好为 k ，则最小值为 k，否则最小值为 k + 1 对于最小值，问题转化为若干个大小为 v ，数量为 c 的数，能否凑齐恰好为 k 的数，此为多重背包 本题数据太大，尝试过用二进制优化的多重背包，发现复杂度过不去 后来想想二进制优化后产生的01背包对于凑数问题可以用bitset优化（具体看代码实现）,速度可观，完全能过 代码看主代码区部分便可 #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\" = %lld\\n\", (ll)x) #define dcout(x) cout \u003c\u003c #x \u003c\u003c \" = \" \u003c\u003c x \u003c\u003c endl #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } int getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1.0); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int len[M], vis[M], f[M], fa[M], siz[M]; bitset\u003cM\u003e dp; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ class UF { public: int n; // 当前连通分量数目 int cnt; vector\u003cint\u003e size; vector\u003cint\u003e parent; UF(int _n): n(_n + 1), cnt(_n + 1), size(_n + 1, 1), parent(_n + 1) { int i = 0; for (auto \u0026x : parent) x = i++; } int findset(int x) { return parent[x] == x ? x : parent[x] = findset(parent[x]); } bool unite(int x, int y) { x = findset(x); y = findset(y); if (x == y) { return false; } if (size[x] \u003c size[y]) { swap(x, y); } parent[y] = x; size[x] += size[y]; --cnt; return true; } bool conn(int x, int y) { x = findset(x); y = findset(y); return x == y; } }; /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), m = IO(), maxv = 0, cnt = 0, k = m; UF un(n); for (int i = 1; i \u003c= n; +","date":"2021-08-15","objectID":"/2021/08/cf755f-polandball-and-gifts/:0:0","tags":["题解","动态规划","多重背包","bitset优化","贪心"],"title":"Cf755F PolandBall and Gifts","uri":"/2021/08/cf755f-polandball-and-gifts/"},{"categories":["刷题"],"content":" 题意：给你一些硬币面值为 $a_1, a_2, a_3…$个数为 $c_1, c_2, c_3…$，问你1到m有多少个价格可以凑成 多重背包，一开始觉得必须要单调队列才能过了，后来看了别人的思路，发现是自己的格局小了 我们发现如果一个数可以凑成则不需要对其进行转移了 设 dp[i] 表示 i 是否能够凑成，1表示能，0表示不能 用 num[i] 表示当前硬币面值凑成花费了多少个，固转移时需要判断有没有超过个数 看代码好懂 #include \u003ccctype\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cstring\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003cbitset\u003e#include \u003ccmath\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\" = %lld\\n\", (ll)x) #define dcout(x) cout \u003c\u003c #x \u003c\u003c \" = \" \u003c\u003c x \u003c\u003c endl #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } int getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } // void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { // int x, y; int t, d, p, i; bool operator\u003c (const pii\u0026 j) { return d \u003c j.d; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1.0); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int a[110], c[110], dp[N], num[N]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), m = IO(); if (n + m == 0) exit(0); fill_w(a + 1, n), fill_w(c + 1, n); fill_n(dp, m + 1, 0); dp[0] = 1; for (int i = 1; i \u003c= n; ++i) { fill_n(num, m + 1, 0); for (int j = a[i]; j \u003c= m; ++j) { if (!dp[j] \u0026\u0026 dp[j - a[i]] \u0026\u0026 num[j - a[i]] \u003c c[i]) { dp[j] = 1; num[j] = num[j - a[i]] + 1; } } } int ans = 0; for (int i = 1; i \u003c= m; ++i) { ans += dp[i]; } print(ans, '\\n'); } /*------------------------------主代码区------------------------------*/ int main() { // int t = IO(); while (1) problem(); return 0; } ","date":"2021-08-13","objectID":"/2021/08/poj-1742-coins/:0:0","tags":["题解","动态规划","多重背包"],"title":"POJ 1742 Coins","uri":"/2021/08/poj-1742-coins/"},{"categories":["刷题"],"content":" 题意：着火了，要拯救有n个物品，对于每个物品的价值为 p[i] ，拯救出来所需要的时间为 t[i]， 但过了时间 d[i] 后该物品便无价值了，输出能获得物品的最大价值和拯救物品的顺序（输出其中一种即可） 这道题看是能看出是01背包，但是状态的转移需要花一些心思 首先物品的拯救的顺序不能乱来，可以贪心来搞，优先考虑快要无价值的物品 然后便是非常朴素的01背包问题和求具体方案了 #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\" = %lld\\n\", (ll)x) #define dcout(x) cout \u003c\u003c #x \u003c\u003c \" = \" \u003c\u003c x \u003c\u003c endl #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } int getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { // int x, y; int t, d, p, i; bool operator\u003c (const pii\u0026 j) { return d \u003c j.d; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int dp[110][2005]; pii p[110]; vi\u003cint\u003e res; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ void solve(int n, int m) { if (m == 0 || n == 0) { print(res.size(), '\\n'); reverse(all(res)); for (int x : res) print(x, ' '); exit(0); } if (m \u003c p[n].d \u0026\u0026 m \u003e= p[n].t \u0026\u0026 dp[n][m] == dp[n - 1][m - p[n].t] + p[n].p) { res.pb(p[n].i); solve(n - 1, m - p[n].t); res.pop_back(); } solve(n - 1, m); } /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(); for (int i = 1; i \u003c= n; ++i) { p[i].t = IO(), p[i].d = IO(), p[i].p = IO(); p[i].i = i; } sort(p + 1, p + 1 + n); int ans = 0, m = 0; for (int i = 1; i \u003c= n; ++i) { for (int j = 0; j \u003c= 2000; ++j) { dp[i][j] = dp[i - 1][j]; if (j \u003c p[i].d \u0026\u0026 j \u003e= p[i].t) { dp[i][j] = max(dp[i][j], dp[i - 1][j - p[i].t] + p[i].p); } if (i == n \u0026\u0026 dp[i][j] \u003e ans) ans = dp[i][j], m = j; } } print(ans, '\\n'); solve(n, m); } /*------------------------------主代码区------------------------------*/ int main() { // int t = IO(); while (1) problem(); return 0; } ","date":"2021-08-12","objectID":"/2021/08/cf864e-fire/:0:0","tags":["题解","贪心","动态规划","01背包"],"title":"Cf864E","uri":"/2021/08/cf864e-fire/"},{"categories":["刷题"],"content":" 题解：给你两个数组，当 a[i] 被选时， b[i] 必选，问你最终选出a数组的和恰好是b数组的k倍的最大a数组的和，不存在则输出-1 题中需要我们做的是选出一个下标集合使得 $\\sum a_i \\div \\sum b_i = k$ 思维转换一下：$\\sum a_i - k \\sum b_i = 0$ 得到： $\\sum(a_i - k\\times b_i) = 0$ 根据题意可以转化为：给你每个物品质量为 a[i] - k * b[i] 且价值为 a[i] 的物品，问你背包容量为0的最大价值为多少 需要注意的是可能有质量有负数，只需要每个质量加一个偏移量便可 直接看代码的主代码区 #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\" = %lld\\n\", (ll)x) #define dcout(x) cout \u003c\u003c #x \u003c\u003c \" = \" \u003c\u003c x \u003c\u003c endl #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } int getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int a[110], b[110], dp[2][N]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ int real(int x) { return x + 10100; } /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), k = IO(); fill_w(a + 1, n); fill_w(b + 1, n); memset(dp, 0xf7, sizeof dp); dp[0][real(0)] = 0; int now = 1, pre = 0; for (int i = 1; i \u003c= n; ++i) { int v = a[i] - k * b[i]; for (int j = -10000; j \u003c= 10000; ++j) { dp[now][real(j)] = max(dp[pre][real(j)], dp[pre][real(j - v)] + a[i]); } swap(now, pre); } print(dp[pre][real(0)] == 0 ? -1 : dp[pre][real(0)], '\\n'); } /*------------------------------主代码区------------------------------*/ int main() { // int t = IO(); while (1) problem(); return 0; } ","date":"2021-08-12","objectID":"/2021/08/cf366c-dima-and-salad/:0:0","tags":["题解","动态规划","01背包"],"title":"Cf366C Dima and Salad","uri":"/2021/08/cf366c-dima-and-salad/"},{"categories":["刷题"],"content":" 题意：给你一个数组，每次区间询问mex 这题用主席树比较好写，而且还是在线算法 利用权值线段树在每个权值上记录该数最后出现的下标，再次基础上加上可持续化，便是主席树了 最终查询 [l, r] 区间的mex时，则是在版本 r 的权值线段树中找下标小于 l 的最小的数即可 注意： 本题不需要离散化，但若是需要离散化则需要同时将比原来数多1的数和0也同时离散化，因为答案必定是原数组中某个数+1或者是0 权值线段树下标至少为1，我们让所有数先+1 直接看模板区代码 #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\" = %lld\\n\", (ll)x) #define dcout(x) cout \u003c\u003c #x \u003c\u003c \" = \" \u003c\u003c x \u003c\u003c endl #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } int getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 2e5 + 10, M = 1e6 + 10; int a[N], ram, root[N], vis[N]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ struct nodes {int l, r, minv; } hjt[N * 25]; int modify(int pre, int l, int r, int val, int pos) { int now = ++ram; hjt[now] = hjt[pre]; if (l == r) { hjt[now].minv = pos; return now; } int mid = (l + r) \u003e\u003e 1; if (val \u003c= mid) hjt[now].l = modify(hjt[now].l, l, mid, val, pos); else hjt[now].r = modify(hjt[now].r, mid + 1, r, val, pos); hjt[now].minv = min(hjt[hjt[now].l].minv, hjt[hjt[now].r].minv); return now; } int query(int tr, int l, int r, int ql) { if (l == r) return l; int mid = (l + r) \u003e\u003e 1; if (hjt[hjt[tr].l].minv \u003c ql) return query(hjt[tr].l, l, mid, ql); return query(hjt[tr].r, mid + 1, r, ql); } /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), len = 0, m = IO(); for (int i = 1; i \u003c= n; ++i) { a[i] = IO() + 1; len = max(len, a[i] + 1); } for (int i = 1; i \u003c= n; ++i) { root[i] = modify(root[i - 1], 1, len, a[i], i); } while (m --) { int l = IO(), r = IO(); print(query(root[r], 1, len, l) - 1, '\\n'); } } /*------------------------------主代码区------------------------------*/ int main() { // int t = IO(); while (1) problem(); return 0; } ","date":"2021-08-12","objectID":"/2021/08/%E6%B4%9B%E8%B0%B7-4137-mex/:0:0","tags":["题解","主席树"],"title":"洛谷 4137 mex","uri":"/2021/08/%E6%B4%9B%E8%B0%B7-4137-mex/"},{"categories":["刷题"],"content":" 题意：给你一个数组，每次询问你某个区间内不同数的个数 本题可以用离线+树状数组来做，常数小，速度快，解法移步至HDU3333刷题记录 利用主席树，最暴力的方式便是利用下标来构建一颗主席树，对于每个数，为其下标上的主席树+1，并记录本数上次出现的下标，为其在当前版本的主席树上的下标-1，最后的询问便是查询 [l, r] 区间版本的主席树中 [l, r] 区间内的和 具体看模板区代码（注意，洛谷本题数据加强，本人测试过，此解法在洛谷上加强的数据会超时2个，但在BZOJ上测试小数据范围（ $n \\le 5e4$ ）可过） #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\" = %lld\\n\", (ll)x) #define dcout(x) cout \u003c\u003c #x \u003c\u003c \" = \" \u003c\u003c x \u003c\u003c endl #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } int getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e6 + 10, M = 1e6 + 10; int a[N], ram, root[N], last[M]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ struct nodes {int l, r, sum = 0; } hjt[N * 35]; int build(int l, int r) { int now = ++ram; if (l == r) return now; int mid = (l + r) \u003e\u003e 1; hjt[now].l = build(l, mid); hjt[now].r = build(mid + 1, r); return now; } int modify(int pre, int l, int r, int indx, int val) { int now = ++ram; hjt[now] = hjt[pre], hjt[now].sum += val; if (l == r) return now; int mid = (l + r) \u003e\u003e 1; if (indx \u003c= mid) hjt[now].l = modify(hjt[now].l, l, mid, indx, val); else hjt[now].r = modify(hjt[now].r, mid + 1, r, indx, val); return now; } int query(int tl, int tr, int ql, int qr, int l, int r) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) return hjt[tr].sum - hjt[tl].sum; int mid = (l + r) \u003e\u003e 1, res = 0; if (ql \u003c= mid) res = query(hjt[tl].l, hjt[tr].l, ql, qr, l, mid); if (qr \u003e mid) res += query(hjt[tl].r, hjt[tr].r, ql, qr, mid + 1, r); return res; } /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(); root[0] = build(1, n); for (int i = 1; i \u003c= n; ++i) { a[i] = IO(); root[i] = modify(root[i - 1], 1, n, i, 1); if (last[a[i]]) root[i] = modify(root[i], 1, n, last[a[i]], -1); last[a[i]] = i; } int m = IO()","date":"2021-08-10","objectID":"/2021/08/%E6%B4%9B%E8%B0%B7-1972-hh%E7%9A%84%E9%A1%B9%E9%93%BE/:0:0","tags":["刷题","主席树"],"title":"洛谷-1972 HH的项链","uri":"/2021/08/%E6%B4%9B%E8%B0%B7-1972-hh%E7%9A%84%E9%A1%B9%E9%93%BE/"},{"categories":["刷题"],"content":" 题意：给你一个数组，问你区间 [l,r] 中出现次数超过 (r - l + 1) / k 次的最小的数，不存在输出-1 在修改一下普通主席树的询问便可，先从主席树的左边开始找，如果左边的个数和都小于了 (r - l + 1) / k 那就不用找了，但如果找到了，则右子树就不用找了 直接看模板区代码 #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\" = %lld\\n\", (ll)x) #define dcout(x) cout \u003c\u003c #x \u003c\u003c \" = \" \u003c\u003c x \u003c\u003c endl #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } int getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 3e5 + 10, M = 1e6 + 10; int a[N], ram, root[N]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ struct nodes {int l, r, sum = 0; } hjt[N * 30]; int build(int l, int r) { int now = ++ram; if (l == r) return now; int mid = (l + r) \u003e\u003e 1; hjt[now].l = build(l, mid); hjt[now].r = build(mid + 1, r); return now; } int modify(int pre, int l, int r, int indx) { int now = ++ram; hjt[now] = hjt[pre], hjt[now].sum += 1; if (l == r) return now; int mid = (l + r) \u003e\u003e 1; if (indx \u003c= mid) hjt[now].l = modify(hjt[now].l, l, mid, indx); else hjt[now].r = modify(hjt[now].r, mid + 1, r, indx); return now; } int query(int tl, int tr, int l, int r, int k) { if (hjt[tr].sum - hjt[tl].sum \u003c= k) return -1; if (l == r) return l; int mid = (l + r) \u003e\u003e 1; int res = hjt[hjt[tr].l].sum - hjt[hjt[tl].l].sum, ret = -1; if (res \u003e= k) ret = query(hjt[tl].l, hjt[tr].l, l, mid, k); if (ret == -1) ret = query(hjt[tl].r, hjt[tr].r, mid + 1, r, k); return ret; } /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), m = IO(); root[0] = build(1, n); for (int i = 1; i \u003c= n; ++i) { a[i] = IO(); root[i] = modify(root[i - 1], 1, n, a[i]); } while (m--) { int l = IO(), r = IO(), k = IO(); k = (r - l + 1) / k; print(query(root[l - 1], root[r], 1, n, k), '\\n'); } } /*------------------------------主代码区---------------------","date":"2021-08-10","objectID":"/2021/08/cf840d-destiny/:0:0","tags":["题解","主席树"],"title":"Cf840D Destiny","uri":"/2021/08/cf840d-destiny/"},{"categories":["刷题"],"content":" 题意：求解一个区间中的第k大，本题带单点修改 考虑如果是静态主席树的话，其本质是利用了前缀和思想，但我们知道前缀和只能查询不能再短时间内单点修改，这个时候就可以考虑不用前缀和来维护主席树了。 想到可以单点修改又可以区间查询的数据结构就有线段树和树状数组了 为了方便起见，我们用树状数组来维护主席树 想象树状数组每个下标都是一个主席树，这样就可以做到单点树修改和区间树查询了 值得注意的是：之前的前缀和主席树是当前树的相同结点是继承上一棵树的，他是利用前一个树来创建一颗新的树。但我们用树状数组就是更新式的，他并没有用到上一棵树的信息，同样还是试想树状数组每一个下标都是一颗树，每次都是更新那棵树，而不是创一颗树，这样理解会好一些。 主要直接看模板代码区 #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\" = %lld\\n\", (ll)x) #define dcout(x) cout \u003c\u003c #x \u003c\u003c \" = \" \u003c\u003c x \u003c\u003c endl #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() #define lb(x) ((x) \u0026 (-x)) using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } int getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int q, x, y, k; // int x, y; // bool operator\u003c (const pii\u0026 j) { // return x != j.x ? x \u003c j.x : y \u003c j.y; // } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 2e4 + 10, M = 1e6 + 10; int a[N], ram, root[N], rnk[N \u003c\u003c 1]; set\u003cint\u003e ms; umap\u003cint, int\u003e mp; pii p[N]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ struct nodes{ int l = 0, r = 0, sum = 0; }hjt[N * 200]; void push_up(int indx) { hjt[indx].sum = hjt[hjt[indx].l].sum + hjt[hjt[indx].r].sum; } int modify(int pre, int l, int r, int indx, int val) { int now = (pre == 0 ? ++ram : pre); if (l == r) { hjt[now].sum += val; return now; } int mid = (l + r) \u003e\u003e 1; if (indx \u003c= mid) hjt[now].l = modify(hjt[now].l, l, mid, indx, val); else hjt[now].r = modify(hjt[now].r, mid + 1, r, indx, val); push_up(now); return now; } int query(vi\u003cint\u003e\u0026 tl, vi\u003cint\u003e\u0026 tr, int l, int r, int k) { if (l == r) return l; int mid = (l + r) \u003e\u003e 1, res = 0; for (int x : tl) res -= hjt[hjt[x].l].sum; for (int x : tr) res += hjt[hjt[x].l].sum; if (k \u003c= res) { for (int\u0026 x : tl) x = hjt[x].l; for (int\u0026 x : tr) x = hjt[x].l; return query(tl, tr, l, mid, k); } for (int\u0026 x : tl) x = hjt[x].r; for (int\u0026 x : tr) x = hjt[x].r; return query(tl, tr, mid + 1, r, k - res); } void modify_tree(int indx, int val, int n, int len) { int x = mp[a[indx]]; while (indx \u003c= n) { root[indx] = modify(root[indx], 1, len, x, val); indx += lb(indx); } } int query_tree(int l, int r, int k, int len) { vi\u003cint\u003e tl, tr; // 预处理有哪些树状数组的主席树要求和 for (int i = l - 1; i \u003e 0;","date":"2021-08-08","objectID":"/2021/08/%E6%B4%9B%E8%B0%B7-p2617-dynamic-rankings/:0:0","tags":["题解","主席树","树状数组","树套树"],"title":"洛谷 P2617","uri":"/2021/08/%E6%B4%9B%E8%B0%B7-p2617-dynamic-rankings/"},{"categories":["刷题"],"content":" 给你一个数组，每次提问你区间中不超过k的个数 主席树板子题，需要注意的是只对数组离散化是不够的，需要离线把所有询问的k值也进行离散化 直接看代码的主代码区和模板区 #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\" = %lld\\n\", (ll)x) #define dcout(x) cout \u003c\u003c #x \u003c\u003c \" = \" \u003c\u003c x \u003c\u003c endl #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() #define ls node \u003c\u003c 1 #define rs (ls) | 1 using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } int getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int l, r, x; // int x, y; // bool operator\u003c (const pii\u0026 j) { // return x != j.x ? x \u003c j.x : y \u003c j.y; // } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 2e5 + 10, M = 1e5 + 10; int a[M], ram, root[M], kase; pii q[M]; vi\u003cint\u003e vt; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ struct nodes{ int l, r, sum = 0; }hjt[M * 20]; int build(int l, int r) { int now = ++ram; if (l == r) return now; int mid = (l + r) \u003e\u003e 1; hjt[now].l = build(l, mid); hjt[now].r = build(mid + 1, r); return now; } int insert(int pre, int l, int r, int indx) { int now = ++ram; hjt[now] = hjt[pre], hjt[now].sum += 1; if (l == r) return now; int mid = (l + r) \u003e\u003e 1; if (indx \u003c= mid) hjt[now].l = insert(hjt[now].l, l, mid, indx); else hjt[now].r = insert(hjt[now].r, mid + 1, r, indx); return now; } int query(int tl, int tr, int l, int r, int x) { if (l == r) return hjt[tr].sum - hjt[tl].sum; int mid = (l + r) \u003e\u003e 1; int res = hjt[hjt[tr].l].sum - hjt[hjt[tl].l].sum; if (x \u003e mid) return res + query(hjt[tl].r, hjt[tr].r, mid + 1, r, x); return query(hjt[tl].l, hjt[tr].l, l, mid, x); } /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ int get_id(int x) { return lower_bound(all(vt), x) - vt.begin() + 1; } /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), m = IO(); ram = 0; root[0] = build(1, n); for (int i = 1; i \u003c= n; ++i) { a[i] = IO(); vt.pb(a[i]); } for (int i = 1; i \u003c= m; ++i) { q[i].l = IO() + 1, q[i].r = IO() + 1; q[i].x = IO(); vt.pb(q[i].x); } sort(all(vt)); vt.erase(unique(all(vt)), vt.end()); for (i","date":"2021-08-07","objectID":"/2021/08/hdu-4417-super-mario/:0:0","tags":["题解","主席树","离散化"],"title":"HDU 4417 Super Mario","uri":"/2021/08/hdu-4417-super-mario/"},{"categories":["刷题"],"content":" 题意：给你一个长度为n的序列，让你在里面挑2k个数出来，然后进行两两配对，配对后的得分为两个数只差的平方，先让你求出最小的得分和 首先，两个数的配对方式要贪心选，即要最小化，则只需要挑两个大小接近的数即可，固要将原数组排序 排序后，一个数若选的话，则另一个配对的数一定是其相邻的数 一个数选与不选，最后选出2k个数，这个解释十分像是一个01背包问题 设 dp[i][j] 为前 i 个数中，选 2*j 个数的最优解 则转移方程为: dp[i][j] = max(dp[i - 1][j], dp[i - 2][j - 1] + (a[i] - a[i - 1]) * (a[i] - a[i - 1]) ) 第二维大于0的状态全部初始化为正无穷 代码直接看主代码区 #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\" = %lld\\n\", (ll)x) #define dcout(x) cout \u003c\u003c #x \u003c\u003c \" = \" \u003c\u003c x \u003c\u003c endl #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } int getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = 0x3f3f3f3f; const ll INF = 1e17; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e3 + 10, M = 1e6 + 10; int a[N \u003c\u003c 1], dp[N \u003c\u003c 1][N]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ int cal(int a) { return a * a; } /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), k = IO(); fill_w(a + 1, n); sort(a + 1, a + 1 + n); fill_n(dp[0] + 1, k, inf); fill_n(dp[1] + 1, k, inf); for (int i = 2; i \u003c= n; ++i) { fill_n(dp[i] + 1, k, inf); for (int j = 1; j \u003c= i / 2 \u0026\u0026 j \u003c= k; ++j) { dp[i][j] = min(dp[i - 1][j], dp[i - 2][j - 1] + cal(a[i] - a[i - 1])); } } print(dp[n][k], '\\n'); } /*------------------------------主代码区------------------------------*/ int main() { #ifndef ONLINE_JUDGE freopen(\"D:/MYCODE/vsCode-c/test.in\", \"r\", stdin); // freopen(\"D:/MYCODE/vsCode-c/test.out\", \"w\", stdout); #endif // int t = 1; // t = IO(); // while (t--) problem(); while (1) problem(); return 0; } ","date":"2021-08-04","objectID":"/2021/08/hdu-1421-%E6%90%AC%E5%AF%9D%E5%AE%A4/:0:0","tags":["题解","线性dp","背包","贪心"],"title":"HDU 1421 搬寝室","uri":"/2021/08/hdu-1421-%E6%90%AC%E5%AF%9D%E5%AE%A4/"},{"categories":["刷题"],"content":" 题意：给你两个字符串a、b，你每次可以把一个区间内的所有字符变成一个字符，问让a字符串变成b字符串的最少操作次数 首先肯定要知道区间中从无到b在此区间中的字符串的最少操作次数，设为 f[l][r] 再来就是从a字符串操作成b字符串的最少操作次数，设 dp[i] 表示前 i 长度字符串，由a变为b的最少操作次数 则dp的转移为 若 a[i] != b[i] ，则 dp[i] = f[1][i] 若 a[i] = b[i] ， 则 dp[i] = dp[i - 1] ,当前这个位置不用操作 最后有点类似划分dp了 ： dp[i] = min(dp[i], dp[j] + f[j + 1][i]) 其中 0 \u003c= j \u003c i 而 f[l][r] 的转移则为 若 b[l] != b[r] ，则 f[l][r] = min(f[l + 1][r], f[l][r - 1]) + 1 若 b[l] = b[r] ，则 f[l][r] = min(f[l + 1][r], f[l][r - 1]) 最后便是区间dp了：f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r]) 其中 l \u003c= k \u003c r #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\" = %lld\\n\", (ll)x) #define dcout(x) cout \u003c\u003c #x \u003c\u003c \" = \" \u003c\u003c x \u003c\u003c endl #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } int getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int dp[110], f[110][110]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { string a, b; int n = getstr(a); getstr(b); a = \" \" + a, b = \" \" + b; for (int i = n; i \u003e= 1; --i) { f[i][i] = 1; for (int j = i + 1; j \u003c= n; ++j) { // [i, j] f[i][j] = min(f[i + 1][j], f[i][j - 1]); if (b[i] != b[j]) f[i][j] += 1; for (int k = i; k \u003c j; ++k) { f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); } } } for (int i = 1; i \u003c= n; ++i) { dp[i] = f[1][i]; if (a[i] == b[i]) dp[i] = dp[i - 1]; for (int j = 0; j \u003c i; ++j) { dp[i] = min(dp[i], dp[j] + f[j + 1][i]); } } print(dp[n], '\\n'); } /*------------------------------主代码区------------------------------*/ int main() { // int t = 1; // t = IO(); // while (t--) problem(); while (1) problem(); return 0; } ","date":"2021-08-04","objectID":"/2021/08/hdu-2476-string-painter/:0:0","tags":["题解","区间dp"],"title":"HDU 2476","uri":"/2021/08/hdu-2476-string-painter/"},{"categories":["刷题"],"content":" 题意：给你一个字符串，你可以删除一些字符（也可以不删），问你有多少种删除方式使得最终得到一个回文串 将题意转化一下，就是求一个字符串有多少个回文子序列 设 dp[l][r] 为区间 [l, r] 中有多少个回文子序列 状态转移需要用到容斥 若 s[l] != s[r] ，则 dp[l][r] = dp[l][r - 1] + dp[l + 1][r] - dp[l + 1][r - 1] 否则， dp[l][r] = (dp[l][r - 1] + dp[l + 1][r] - dp[l + 1][r - 1]) + dp[l + 1][r - 1] + 1 上式化简后为 dp[l][r] = dp[l][r - 1] + dp[l + 1][r] + 1 相等的情况下加一是因为加上了 s[l] 和 s[r] 两个字符拼接后得到的回文串 代码直接看 主代码区 #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\" = %lld\\n\", (ll)x) #define dcout(x) cout \u003c\u003c #x \u003c\u003c \" = \" \u003c\u003c x \u003c\u003c endl #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } int getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; ll a[N], dp[100][100]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { string s; int n = getstr(s); s = \" \" + s; for (int i = n; i \u003e= 1; --i) { dp[i][i] = 1; for (int j = i + 1; j \u003c= n; ++j) { dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]; if (s[i] == s[j]) dp[i][j] += dp[i + 1][j - 1] + 1; } } print(dp[1][n], '\\n'); } /*------------------------------主代码区------------------------------*/ int main() { int t = 1; t = IO(); while (t--) problem(); // while (1) problem(); return 0; } ","date":"2021-08-04","objectID":"/2021/08/uva-10617-again-palindrome/:0:0","tags":["题解","区间dp","容斥原理"],"title":"UVA 10617","uri":"/2021/08/uva-10617-again-palindrome/"},{"categories":["刷题"],"content":" 题意：给你一个长为n的字符串，问你最少插入多少个字符可以使得这个字符串成为一个回文字符串 很容易想到直接找最长的回文子序列便可 设 dp[l][r] 为区间 [l, r] 的字符串中最长的回文子序列 则转移方程 若 s[l] != s[r]则 dp[l][r] = max(dp[l + 1][r], dp[l][r - 1]) 否则 dp[l][r] = max({dp[l + 1][r], dp[l][r - 1], dp[l + 1][r - 1] + 2}) 初始化 dp[i][i] = 1 最后的答案便是 n - dp[1][n] 但这样空间要开到 5000 * 5000 ，交上去后直接 MLE 了 观察到转移方程，发现可以空间优化，第一维只需开长度为2便可，然后滚动数组 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e using namespace std; const int N = 5e3 + 5; char s[N]; int dp[2][N]; int main() { int n; while (scanf(\"%d\\n%s\", \u0026n, s + 1) != -1) { int now = 0, pre = 1; for (int i = n; i \u003e= 1; --i) { dp[now][i] = 1; for (int j = i + 1; j \u003c= n; ++j) { dp[now][j] = max(dp[pre][j], dp[now][j - 1]); if (s[i] == s[j]) dp[now][j] = max(dp[now][j], dp[pre][j - 1] + 2); } swap(now, pre); } printf(\"%d\\n\", n - dp[pre][n]); } return 0; } ","date":"2021-08-04","objectID":"/2021/08/poj-1159-palindrome/:0:0","tags":["题解","区间dp","空间优化"],"title":"POJ 1159 Palindrome","uri":"/2021/08/poj-1159-palindrome/"},{"categories":["刷题"],"content":" 题意：给你一个数组，有区间修改和区间查询gcd 显然，这题是没法直接区间修改的 需要用到一个在数论中常见的gcd结论：$gcd(a_1, a_2, a_3, \\dots a_n) = gcd(a_1, a_2 - a_1, a_3 - a_2\\dots a_n - a_{n- 1})$ 观察上面的式子后发现：本来的a序列变成了他的差分序列，由差分序列的性质可知，若原序列区间加减，只需要在差分序列中区间两端加减便可。例如，我要在原序列中 [l, r] 区间中每一个数都加一个 d ，则只需要在差分序列中下标为 l 的数值加 d ，下标为 r + 1 的数值减 d 即可 固，我们只需要将原序列的差分序列建立一个线段树即可 这要做还不能完全解决这道题，利用差分序列使我们更好地操作，但不要忘了，我们还有查询 这里的查询是不能直接利用线段树的区间查询的，观察上面的式子，差分序列第一个数并没有变，所以我们要保留每一个数的上一个数是多少（注意题中区间修改操作会改变这个值），在区间 [l, r] 查询前，我们只需要将 l 下标的数组减去 l - 1 的数值再做区间查询即可 具体看代码（这里线段树保存了两个值，一个是区间的gcd，一个是原序列的值val，考虑到不用求和，因为求和可能会爆longlong，固用非叶子结点的val来当做lazy值。所以本线段树中树的建立、区间查询、单点修改都是针对gcd的，而区间修改、单点查询都是针对原序列val值的） #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\" = %lld\\n\", (ll)x) #define dcout(x) cout \u003c\u003c #x \u003c\u003c \" = \" \u003c\u003c x \u003c\u003c endl #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() #define ls (node \u003c\u003c 1) #define rs ((node \u003c\u003c 1) | 1) #define lb(x) ((x) \u0026 (-x)) using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } void getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 5e5 + 10, M = 1e6 + 10; ll a[N], b[N], lazy[N \u003c\u003c 2], val[N \u003c\u003c 2], seg[N \u003c\u003c 2]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ void build(int l, int r, int node = 1) { if (l == r) { seg[node] = b[l], val[node] = a[l]; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls), build(mid + 1, r, rs); seg[node] = gcd(abs(seg[ls]), abs(seg[rs])); } void modify_point(int indx, ll v, int l, int r, int node = 1) { if (l == r) { seg[node] += v; return; } int mid = (l + r) \u003e\u003e 1; if (indx \u003c= mid) modify_point(indx, v, l, mid, ls); else modify_point(indx, v, mid + 1, r, rs); seg[node] = gcd(abs(seg[ls]), abs(seg[rs])); } void push_down(int node) { if (val[node] == 0) return; val[ls] += val[node], val[rs] += val[node]; val[node] = 0; } void modify_range(int ql, int qr, ll v, int l, int r, int node = 1) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) { val[node] += v; return; } push_down(node); int mid = (l + r) \u003e\u003e 1; if (ql \u003c= mid) modify_range(ql, qr, v, l, mid, ls); if (qr \u003e mid) modify_range(ql, qr, v, mid + 1, r, rs); } ll get_point","date":"2021-08-03","objectID":"/2021/08/acwing246%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/:0:0","tags":["题解","线段树","数论"],"title":"AcWing 246 区间最大公约数","uri":"/2021/08/acwing246%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"},{"categories":["刷题"],"content":" 给你一个排列的数组，操作m次，要不就是将 [l, r] 区间升序，要不就是降序，最后问某个下标的值是多少 一道思维题，可以这么做，二分一个答案 x，多开一个数组 b ，将原数组比 x 小的位置在数组 b 中设置为0，大于等于 x 的位置在数组 b 中设置为1，然后针对题意中的操作，对数组 b 进行区间查询和区间修改操作，即如果升序，则将该区间前面修改为0，后面修改为1，降序同理，最后查看题中问的下标是1还是0 感觉此思路还是挺明朗的，剩下的就是套个常规的线段树板子改改就好了 #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\" = %lld\\n\", (ll)x) #define dcout(x) cout \u003c\u003c #x \u003c\u003c \" = \" \u003c\u003c x \u003c\u003c endl #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() #define ls (node \u003c\u003c 1) #define rs ((node \u003c\u003c 1) | 1) using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } void getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ /*↓可修改区*/ // 自定义结构体 struct pii { int q, l, r; // bool operator\u003c (const pii\u0026 j) { // return x != j.x ? x \u003c j.x : y \u003c j.y; // } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int a[N], b[N], seg[N \u003c\u003c 2], lazy[N \u003c\u003c 2], vis[N \u003c\u003c 2]; pii ask[N]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ int op(int a, int b) { return a + b; } // 题意不同，函数内部不同 void push_down(int l, int r, int node) { if (!vis[node]) return; // 这里如果0也有意义的话多开一个数组标记 int mid = (l + r) \u003e\u003e 1; lazy[ls] = lazy[node], lazy[rs] = lazy[node]; seg[ls] = (mid - l + 1) * lazy[node]; seg[rs] = (r - mid) * lazy[node]; vis[ls] = vis[rs] = 1, vis[node] = 0; } // 初始化 void build(int l, int r, int node) { if (l == r) { seg[node] = b[l], vis[node] = 0; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls), build(mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]), vis[node] = 0; } // 区间修改 void update(int ql, int qr, int v, int l, int r, int node) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) { // 题意不同，这里更新操作不同 lazy[node] = v, vis[node] = 1; seg[node] = (r - l + 1) * v; return; } push_down(l, r, node); int mid = (l + r) \u003e\u003e 1; if (ql \u003c= mid) update(ql, qr, v, l, mid, ls); if (qr \u003e mid) update(ql, qr, v, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间查找 int get(int ql, int qr, int l, int r, int node) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) return seg[node]; push_down(l, r, node); // 保证单点的情况下这句话可以注释掉 int mid = (l + r) \u003e\u003e 1; int ret = 0; // 题意不同，初始化不同 if (ql \u003c= mid) ret = get(ql, qr, l, mid, ls); if (qr \u003e mid) ret = op(get(ql, qr, mid + 1, r, rs), ret); return ret; } /*------------------------------模板代码区----------","date":"2021-08-03","objectID":"/2021/08/hdu-5649-dzy-loves-sorting/:0:0","tags":["题解","线段树","二分"],"title":"HDU 5649 DZY Loves Sorting","uri":"/2021/08/hdu-5649-dzy-loves-sorting/"},{"categories":["刷题"],"content":" 题意：给你一个数组，问你数组的中开始位置为 [x1, y1]， 结束位置为 [x2, y2] 的最大字段和 $x_1 \\le y1, x2 \\le y2, x1 \\le x2, y1 \\le y2$ 由题意可知区间只有两种情况 不相交 相交 对于不相交，就是直接求 [x1, y1] 区间中右端点（右端点必选）往左的最大字段和，加上 [x2, y2] 区间左端点（左端点必选）往右的最大字段和，再加上中间必选的区间 [y1 + 1, x2 - 1] 的和 而相交可以转化为以下几个不相交的区间 开始位置为 [x1, x2] ， 结束位置为 [x2 + 1, y2] 开始位置为 [x1, x2 - 1] ， 结束位置为 [x2, y2] 开始位置为 [x1, y1] ， 结束位置为 [y1 + 1, y2] 开始位置为 [x1, y1 - 1] ， 结束位置为 [y1, y2] 当然不要忘记了还有开始位置和结束位置都在 [x2, y1] 的情况 #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define debug(x) printf(#x\" = %lld\\n\", (ll)x) #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define ls (node \u003c\u003c 1) #define rs ((node \u003c\u003c 1) | 1) #define vi vector #define all(x) x.begin(), x.end() using namespace std; inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } void getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} struct pii { // int x, y; int l, r, maxv, sum; pii() : l(-1e7), r(-1e7), maxv(-1e7), sum(-1e7) {} pii(int x) : l(x), r(x), maxv(x), sum(x) {} }; const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int a[N], sum[N]; pii seg[N \u003c\u003c 2]; void push_up(int node) { seg[node].maxv = max({seg[ls].maxv, seg[rs].maxv,seg[ls].r + seg[rs].l}); seg[node].sum = seg[ls].sum + seg[rs].sum; seg[node].l = max(seg[ls].l, seg[ls].sum + seg[rs].l); seg[node].r = max(seg[rs].r, seg[rs].sum + seg[ls].r); } void build(int l, int r, int node = 1) { if (l == r) { seg[node] = pii(a[l]); return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls), build(mid + 1, r, rs); push_up(node); } pii get(int ql, int qr, int l, int r, int node = 1) { if (ql \u003e qr) return pii(); if (ql \u003c= l \u0026\u0026 r \u003c= qr) return seg[node]; int mid = (l + r) \u003e\u003e 1; if (ql \u003e mid) return get(ql, qr, mid + 1, r, rs); if (qr \u003c= mid) return get(ql, qr, l, mid, ls); pii p1 = get(ql, qr, l, mid, ls); pii p2 = get(ql, qr, mid + 1, r, rs); pii res; res.maxv = max({p1.maxv, p2.maxv, p1.r + p2.l}); res.sum = p1.sum + p2.sum; res.l = max(p1.l, p1.sum + p2.l); res.r = max(p2.r, p2.sum + p1.r); return res; } int get_sum(int l, int r) { if (l \u003e r) return 0; return sum[r] - sum[l - 1]; } void problem() { int n = IO(); fill_w(a + 1, n); for (int i = 1; i \u003c= n; ++i) sum[i] = sum[i - 1] + a[i]; build(1, n); int m = IO(); while (m--) { int x1 = IO(), y1 = IO(), x2 = IO(), y2 = IO(), res; if (y1 \u003c x2) { res = get(x1, y1, 1, n).r + get(x2, y2, 1, n).l; res += get_sum(y1 + 1, x2 - 1); } else { res = get(x1, x2, 1, n).r + get(x2 + 1, y2, 1, n).l; res = max(res, get(x1, x2 - 1, 1, n).r + get(x2, y2, 1, n).l); res = max(res, get(x1, y1 - 1, 1, n).r + get(y1, y2, 1, n).l); res = max(res, get(x1, y1, 1, n).r + get(y1 + 1, y2, 1, n).l); res = max(res, get(x2, y1, 1, n).maxv); } print(res, '\\n'); } } int main() { int t = 1; t = IO(); while (t--) problem(); // while (1) problem(); return 0; } ","date":"2021-08-03","objectID":"/2021/08/spoj-gss5-can-you-answer-these-queries-v/:0:0","tags":["题解","线段树"],"title":"SPOJ GSS5 Can you answer these queries V","uri":"/2021/08/spoj-gss5-can-you-answer-these-queries-v/"},{"categories":["刷题"],"content":" 题意：给你一个数组，每次操作将x下标位的数改成y，每次询问区间 [x, y] 之间的最大字段和 一个另类的线段树维护区间信息的题（听说如果只有查询，可以直接用猫树来做） 线段树结点维护4个值： maxv ：记录当前结点区间的最大字段和 sum：记录当前结点区间的和 l ：记录当前结点区间中，从左端点开始（即左端点必选）的最大字段和 r：记录当前结点区间中，从右端点开始的最大字段和 至于更新值的话就是 maxv ：要不就是左孩子的 maxv ，要不就是右孩子的 maxv， 又或者是左孩子的r 值加上 右孩子的 l值 sum：直接区间求和更新 l ：显然要不就是左孩子的 l 值或者是左孩子的 sum 值 加上右孩子的 l 值 r：要不就是右孩子的 r 值或者是右孩子的 sum 值 加上左孩子的 r 值 直接看代码 #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define debug(x) printf(#x\" = %lld\\n\", (ll)x) #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define ls (node \u003c\u003c 1) #define rs ((node \u003c\u003c 1) | 1) #define vi vector #define all(x) x.begin(), x.end() using namespace std; inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } void getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} struct pii { // int x, y; int l, r, maxv, sum; pii() : l(-1e7), r(-1e7), maxv(-1e7), sum(-1e7) {} pii(int x) : l(x), r(x), maxv(x), sum(x) {} }; const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int a[N]; pii seg[N \u003c\u003c 2]; void push_up(int node) { seg[node].maxv = max({seg[ls].maxv, seg[rs].maxv,seg[ls].r + seg[rs].l}); seg[node].sum = seg[ls].sum + seg[rs].sum; seg[node].l = max(seg[ls].l, seg[ls].sum + seg[rs].l); seg[node].r = max(seg[rs].r, seg[rs].sum + seg[ls].r); } void build(int l, int r, int node = 1) { if (l == r) { seg[node] = pii(a[l]); return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls), build(mid + 1, r, rs); push_up(node); } void modify(int indx, int val, int l, int r, int node = 1) { if (l == r) { seg[node] = pii(val); return; } int mid = (l + r) \u003e\u003e 1; if (indx \u003c= mid) modify(indx, val, l, mid, ls); else modify(indx, val, mid + 1, r, rs); push_up(node); } pii get(int ql, int qr, int l, int r, int node = 1) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) return seg[node]; int mid = (l + r) \u003e\u003e 1; if (ql \u003e mid) return get(ql, qr, mid + 1, r, rs); if (qr \u003c= mid) return get(ql, qr, l, mid, ls); pii p1 = get(ql, qr, l, mid, ls); pii p2 = get(ql, qr, mid + 1, r, rs); pii res; res.maxv = max({p1.maxv, p2.maxv, p1.r + p2.l}); res.sum = p1.sum + p2.sum; res.l = max(p1.l, p1.sum + p2.l); res.r = max(p2.r, p2.sum + p1.r); return res; } void problem() { int n = IO();\\ fill_w(a + 1, n); build(1, n); int m = IO(); while (m--) { int q = IO(), x = IO(), y = IO(); if (q == 1) print(get(x, y, 1, n).maxv, '\\n'); else modify(x, y, 1, n); } } int main() { // int t = 1; // t = IO(); // while (t--) problem(); while (1) problem(); return 0; } ","date":"2021-08-03","objectID":"/2021/08/spoj-gss3-can-you-answer-these-queries-iii/:0:0","tags":["题解","线段树"],"title":"SPOJ GSS3 Can you answer these queries III","uri":"/2021/08/spoj-gss3-can-you-answer-these-queries-iii/"},{"categories":["刷题"],"content":" 给你一个区间的数，每次询问时询问第x和第y（包括）个数之间的数的和，每次操作是将第x和第y（包括）个数之间的数都开方 直接暴力修改就好了，每个数最多不会被开方超过6次，直接暴力当成单点修改便可，当然如果这个数已经是1了，就没必要开方了，固如果一个区间上的和恰好为其区间的长度，则这个区间的数是不用开方的了 直接线段树暴力 #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define debug(x) printf(#x\" = %lld\\n\", (ll)x) #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define ls (node \u003c\u003c 1) #define rs ((node \u003c\u003c 1) | 1) #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-快读与快输-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } void getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } // void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-快读与快输-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-不可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-不可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↓可修改区*/ // 自定义结构体 struct pii { int x, y; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-全局变量区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; // const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; ll arr[N], seg[N \u003c\u003c 2]; int kase, flag; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-全局变量区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-模板代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ ll op(ll a, ll b) { return a + b; } void build(int l, int r, int node = 1) { if (l == r) { seg[node] = arr[l]; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls), build(mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间修改 void update(int ql, int qr, int l, int r, int node = 1) { if (seg[node] == r - l + 1) return; if (l == r) { seg[node] = (ll)sqrt(seg[node]); return; } int mid = (l + r) \u003e\u003e 1; if (ql \u003c= mid) update(ql, qr, l, mid, ls); if (qr \u003e mid) update(ql, qr, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间查找 ll get(int ql, int qr, int l, int r, int node = 1) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) return seg[node]; // push_down(l, r, node); // 保证单点的情况下这句话可以注释掉 int mid = (l + r) \u003e\u003e 1; ll ret = 0; // 题意不同，初始化不同 if (ql \u003c= mid) ret = get(ql, qr, l, mid, ls); if (qr \u003e mid) ret = op(get(ql, qr, mid + 1, r, rs), ret); return ret; } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-模板代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-函数代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-函数代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-主代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ void problem() { int n = IO(); fill_w(arr + 1, n); if (flag) puts(\"\"); else flag = 1; printf(\"Case #%d:\\n\", ++kase); build(1, n); int m = IO(); while (m--) { int q = IO(), l = IO(), r = IO(); if (l \u003e r) swap(l, r); if (q == 0) update(l, r, 1, n); else print(get(l, r, 1, n), '\\n'); } } /*↑↑↑↑↑↑↑↑","date":"2021-07-30","objectID":"/2021/07/spoj-gss4-can-you-answer-these-queries-iv/:0:0","tags":["题解","线段树"],"title":"SPOJ GSS4 Can you answer these queries IV","uri":"/2021/07/spoj-gss4-can-you-answer-these-queries-iv/"},{"categories":["刷题"],"content":" 给你一个长度为L的纸，初始化纸的颜色为1，每次回选取一端区间将其用x颜色覆盖，每次询问一端区间中有多少不同的颜色 观察到颜色的数量不多，可以用每个数的二进制位来记录当前有哪些颜色，更新结点直接用或运算便可，然后就是非常普通的线段树的区间修改与查询，直接套板子改改交上去1A了 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003ccctype\u003e#include \u003ccmath\u003e#include \u003cstring\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define debug(x) printf(#x\" = %lld\\n\", (ll)x) #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define ls (node \u003c\u003c 1) #define rs ((node \u003c\u003c 1) | 1) #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-快读与快输-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } void getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } // void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-快读与快输-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-不可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-不可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↓可修改区*/ // 自定义结构体 struct pii { int x, y; // int node, l, r; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-全局变量区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; // const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int tim, seg[N \u003c\u003c 2], lazy[N \u003c\u003c 2]; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-全局变量区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-模板代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ int op(int a, int b) { return a | b; } void push_down(int l, int r, int node) { if (!lazy[node]) return; // 这里如果0也有意义的话多开一个数组标记 lazy[ls] = lazy[node], lazy[rs] = lazy[node]; seg[ls] = lazy[node]; seg[rs] = lazy[node]; lazy[node] = 0; } void build(int l, int r, int node = 1) { if (l == r) { seg[node] = 2; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls), build(mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间修改 void update(int ql, int qr, int v, int l, int r, int node = 1) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) { // 题意不同，这里更新操作不同 lazy[node] = 1 \u003c\u003c v; seg[node] = 1 \u003c\u003c v; return; } push_down(l, r, node); int mid = (l + r) \u003e\u003e 1; if (ql \u003c= mid) update(ql, qr, v, l, mid, ls); if (qr \u003e mid) update(ql, qr, v, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间查找 int get(int ql, int qr, int l, int r, int node = 1) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) return seg[node]; push_down(l, r, node); // 保证单点的情况下这句话可以注释掉 int mid = (l + r) \u003e\u003e 1; int ret = 0; // 题意不同，初始化不同 if (ql \u003c= mid) ret = get(ql, qr, l, mid, ls); if (qr \u003e mid) ret = op(get(ql, qr, mid + 1, r, rs), ret); return ret; } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-模板代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-函数代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ int cal(int x) { int ans = 0; while (x) { ans += 1; x \u0026= (x - 1); } return ans; } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-函数代码区-↑↑↑↑↑↑↑↑↑↑↑","date":"2021-07-30","objectID":"/2021/07/poj2777-count-color/:0:0","tags":["题解","线段树"],"title":"POJ2777 Count Color","uri":"/2021/07/poj2777-count-color/"},{"categories":["刷题"],"content":" 题意：在一棵根为1的树上，每个节点初始化为1，每次指定某个结点上的数字如果一开始是1则变为0，反之变为1，并且每次询问以某个结点为根的子树上一共有多少个结点上的数字为1 这题用树链剖分就是一个板子题，但也可以用dfs序+线段树来写 具体做法就是用一个结构体记录每个节点dfs时时间戳的开始和结束，显然这个时间戳的区间便是以该结点为根的子树区间，然后就是线段树的区间查询和单点修改了 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003ccctype\u003e#include \u003ccmath\u003e#include \u003cstring\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define debug(x) printf(#x\" = %lld\\n\", (ll)x) #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define ls (node \u003c\u003c 1) #define rs ((node \u003c\u003c 1) | 1) #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-快读与快输-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } void getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } // void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-快读与快输-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-不可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-不可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↓可修改区*/ // 自定义结构体 struct pii { int x, y; // int node, l, r; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-全局变量区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; // const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int tim, seg[N \u003c\u003c 2]; pii p[N]; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-全局变量区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-模板代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ int head[N], cnt; //初始化 void init(int n) { fill_n(head, n + 5, -1); cnt = -1; tim = 0; } struct edges { int to, next; void add(int t, int n) { to = t, next = n; } }edge[N \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v) { edge[++cnt].add(v, head[u]); head[u] = cnt; } int op(int a, int b) { return a + b; } void build(int l, int r, int node = 1) { if (l == r) { seg[node] = 1; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls), build(mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 单点修改 void update(int indx, int l, int r, int node = 1) { if (l == r) { // 题意不同，这里更新操作不同 seg[node] ^= 1; return; } int mid = (l + r) \u003e\u003e 1; if (indx \u003c= mid) update(indx, l, mid, ls); else update(indx, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间查找 int get(int ql, int qr, int l, int r, int node = 1) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) return seg[node]; // push_down(l, r, node); // 保证单点的情况下这句话可以注释掉 int mid = (l + r) \u003e\u003e 1; int ret = 0; // 题意不同，初始化不同 if (ql \u003c= mid) ret = get(ql, qr, l, mid, ls); if (qr \u003e mid) ret = op(get(ql, qr, mid + 1, r, rs), ret); return ret; } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-模板代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-函数代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ void dfs(int u, int fa) { p[u].x = ++tim; rep(u, i, edge) { int v = edge[i].to; if (v == fa) contin","date":"2021-07-30","objectID":"/2021/07/poj3321-apple-tree/:0:0","tags":["题解","线段树","树"],"title":"POJ3321 Apple Tree","uri":"/2021/07/poj3321-apple-tree/"},{"categories":["刷题"],"content":" 题意：建图，1表示u、v之间连一条有向边权值为w，2表示u向[l, r]区间内所有点连一条权值为w的有向边，3表示[l, r]区间内的所有点向u连一条权值为w的有向边 直接线段树优化建图便可，具体做法就是建一个根结点连向子结点的出树，再建一个子结点连向根结点的入树，相连的是每个节点的内存池编号。 每个结点表示一个区间，若是点与区间相连，直接树上查询区间，使点向相应区间的编号建边，反之编号向点建边 最后直接在这两个树构成的图上跑最短路便可 值得扩展的是，如果是区间与区间相连权值为w，直接新编一个点，先使前区间与该点相连，权值为w，再使该点与后区间相连权值为0 本题只有点与点连，点与区间连 直接看代码 #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define debug(x) printf(#x\" = %lld\\n\", (ll)x) #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() #define ls (node \u003c\u003c 1) #define rs ((node \u003c\u003c 1) | 1) using namespace std; /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-快读与快输-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } void getstr(string \u0026s) { s.clear(); int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); for(;c \u003e 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-快读与快输-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-不可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-不可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↓可修改区*/ // 自定义结构体 struct pii { int x, y; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-全局变量区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e17; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 2e5 + 1e3, M = 1e6 + 10; bool vis[N \u003c\u003c 4]; ll dis[N \u003c\u003c 4]; int head[N \u003c\u003c 4], cnt; int ram; // 内存池编号 /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-全局变量区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-模板代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ //初始化 void init(int n) { fill_n(head, n + 5, -1); cnt = -1; } struct edges { int to, next; ll w; void add(int t, int n, ll w) { to = t, next = n, this-\u003ew = w; } }edge[N \u003c\u003c 4]; //无向图则需要乘2 inline void add(int u, int v, ll w) { edge[++cnt].add(v, head[u], w); head[u] = cnt; } struct qnode{ int v; ll w; qnode(int v = 0, ll w = 0) : v(v), w(w) {} bool operator\u003c (const qnode \u0026t) const { return w \u003e t.w; } }; void dij(int n, int s) {//n 为顶点数， m 为边数 for (int i = 0; i \u003c= n; ++i) dis[i] = INF, vis[i] = 0; dis[s] = 0; priority_queue\u003cqnode\u003e heap; heap.push(qnode(s, dis[s])); while (heap.size()) { int u = heap.top().v; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; ll w = edge[i].w; if (!vis[v] \u0026\u0026 dis[u] + w \u003c dis[v]) { //松弛 dis[v] = dis[u] + w; heap.push(qnode(v, dis[v])); } } } } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-模板代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-函数代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ struct nodes{ int l, r; }seg[N \u003c\u003c 4]; int build(int l, int r, int flag) { // flag 0 in, 1 out if (l == r) return l; int mid = (l + r) \u003e\u003e 1, now = ++ram; seg[now].l = build(l, mid, flag); seg[now].r = build(mid + 1, r, flag); if (flag) add(now, seg[now].l, 0), add(","date":"2021-07-30","objectID":"/2021/07/cf786b-legacy/:0:0","tags":["题解","线段树","最短路","图论"],"title":"Cf786B Legacy","uri":"/2021/07/cf786b-legacy/"},{"categories":["刷题"],"content":" 题意：一个长度为n的全为1的数组，每次将某点变为0，或者将上一次变为0的点变为1，又或者询问经过某点的最上连续1的序列的长度 为了使线段树能够做到区间合并后更新，显然要维护三个东西，分别是本区间中最长的连续1的长度 maxv ，本区间从左端开始最长的连续1的长度 l ，和本区间从右端点开始最长的连续1的长度 r 。 直接看代码 #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define debug(x) printf(#x\" = %lld\\n\", (ll)x) #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() #define ls (node \u003c\u003c 1) #define rs ((node \u003c\u003c 1) | 1) using namespace std; /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-快读与快输-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } void getstr(string \u0026s) { s.clear(); int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); for(;c \u003e 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-快读与快输-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-不可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-不可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↓可修改区*/ // 自定义结构体 struct pii { int x, y; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; struct pjj { int l, r, maxv; }; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-全局变量区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; pjj seg[N \u003c\u003c 1]; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-全局变量区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-模板代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-模板代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-函数代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ void push_up(int l, int r, int node) { seg[node].maxv = max({seg[ls].maxv, seg[rs].maxv, seg[ls].r + seg[rs].l}); int mid = (l + r) \u003e\u003e 1; seg[node].l = seg[ls].l, seg[node].r = seg[rs].r; if (seg[ls].l == mid - l + 1) seg[node].l += seg[rs].l; if (seg[rs].r == r - mid) seg[node].r += seg[ls].r; } void build(int l, int r, int node = 1) { if (l == r) { seg[node].l = seg[node].r = seg[node].maxv = 1; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls), build(mid + 1, r, rs); push_up(l, r, node); } void modify(int indx, int val, int l, int r, int node = 1) { if (l == r) { seg[node].maxv = seg[node].l = seg[node].r = val; return; } int mid = (l + r) \u003e\u003e 1; if (indx \u003c= mid) modify(indx, val, l, mid, ls); else modify(indx, val, mid + 1, r, rs); push_up(l, r, node); } int get(int indx, int l, int r, int node = 1) { if (l == r) return seg[node].maxv; int mid = (l + r) \u003e\u003e 1; if (indx \u003c= mid) { if (mid - indx + 1 \u003c= seg[ls].r) return seg[rs].l + seg[ls].r; else return get(indx, l, mid, ls); } else { if (indx - mid \u003c= seg[rs].l) return seg[ls].r + seg[rs].l; else return get(indx, mid + 1, r, rs); } } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-函数代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-主代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ void problem() { int n = IO(), m","date":"2021-07-30","objectID":"/2021/07/hdu1540-tunnel-warfare/:0:0","tags":["题解","线段树"],"title":"HDU1540 Tunnel Warfare","uri":"/2021/07/hdu1540-tunnel-warfare/"},{"categories":["刷题"],"content":" 题意：有N个人排队，每一个人都有一个val来对应，每一个后来人都会插入当前队伍的某一个位置pos。要求把队伍最后的状态输出。 这道题如果是直接平衡树做的话直接就是 $O(nlogn)$ 的时间复杂度，但杀鸡焉用牛刀 因为当前插队的人只会影响后面的人，固我们可以考虑倒过来插队，假设当前正在插入第 $x$ 个人，则一定是在前 $x-1$ 个相对位置中挑一个位置插入，且一旦插入后其相对前 $x-1$ 个人的位置不会再改变。 固我们可以这样做：先从最后一个人（即第 $n$ 个人）开始插，在其前 $n-1$ 个人中找其位置，然后此位置将固定为第 $n$ 个人的位置，再来给第 $n-1$ 个插入位置，此时是在前 $n-2$ 个人中找相对位置，注意这时候已经被第 $n$ 个人占用的位置是直接忽略的，以此来寻找第 $n-1$ 个人的位置。后面类推 这个过程模拟起来便是用一个数组，开始时全部初始化为1，当要找第 $x$ 个位置时，就找前缀和为 $x$ 的位置，将此位置置为0，这时对于下一个要找的位置 $y$ 依旧是找前缀和恰好（注意是恰好）为 $y$ 的位置，再将其置为0，以此类推，一直为第1个人找到位置 上诉过程是可以用线段树（或者树状数组）的单点修改来实现，至于找前缀和恰好为 $x$ 的位置可以用二分加查询来找，固这样的时间复杂度为 $O(nlog^2n)$ 但这样的时间复杂度我不能接受，可以观察我们找前缀和恰好为 $x$ 的步骤，二分是没有必要的，可以在线段树内找这个位置（线段树的强大），这样时间复杂度就是 $O(nlogn)$ 具体看代码线段树函数部分 #include \u003cbits/stdc++.h\u003e#define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define debug(x) printf(#x\" = %lld\\n\", (ll)x) #define bug puts(\"bug\") #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() #define ls (node \u003c\u003c 1) #define rs ((node \u003c\u003c 1) | 1) using namespace std; /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-快读与快输-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } void getstr(string \u0026s) { int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-快读与快输-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-不可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ // gcd template \u003ctypename T\u003e T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u003e\u003e= 1, a = a * a % p) if (b \u0026 1) res = res * a % p; return res; } // 数组读入 template \u003ctypename T\u003e inline void fill_w(T *a, int cnt) { for (int i = 0; i \u003c cnt; ++i) a[i] = IO();} /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-不可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↓可修改区*/ // 自定义结构体 struct pii { int x, y; bool operator\u003c (const pii\u0026 j) { return x != j.x ? x \u003c j.x : y \u003c j.y; } }; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-全局变量区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ const int mod = 1e9 + 7; const int inf = (1LL \u003c\u003c 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; pii p[N \u003c\u003c 1]; int seg[N \u003c\u003c 3], que[N \u003c\u003c 1]; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-全局变量区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-模板代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-模板代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-函数代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ void push_up(int node) { seg[node] = seg[ls] + seg[rs]; } void build(int l, int r, int node = 1) { if (l == r) { seg[node] = 1; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls), build(mid + 1, r, rs); push_up(node); } void modify(int k, int val, int l, int r, int node = 1) { if (l == r) { seg[node] = 0, que[l] = val; return; } int mid = (l + r) \u003e\u003e 1; if (seg[ls] \u003e= k) modify(k, val, l, mid, ls); // 找前缀和恰好为k的 else modify(k - seg[ls], val, mid + 1, r, rs); push_up(node); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-函数代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-主代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ void problem() { int n = IO(); for (int i = 0; i \u003c n; ++i) { p[i].x = IO(), p[i].y = IO(); } reverse(p, p + n); build(1, n); for (int i = 0; i \u003c","date":"2021-07-29","objectID":"/2021/07/acwing260%E4%B9%B0%E7%A5%A8/:0:0","tags":["题解","线段树","树状数组","二分"],"title":"AcWing260买票","uri":"/2021/07/acwing260%E4%B9%B0%E7%A5%A8/"},{"categories":["总结","模板","动态规划"],"content":"1. 树形dp 树的最大独立集 /* Loj 10160 每个点都有一个快乐值，子结点和父节点不能同时被选，问你最大的快乐值 dp[i][0]表示第i号结点不选时最大的快乐值 dp[i][1]表示第i号结点选时的最大的快乐值 */ #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccctype\u003e#include \u003ccstring\u003eusing namespace std; const int M = 6e3 + 5; inline long long IO() {} // 快读略 struct es{ int to, nxt; }e[M \u003c\u003c 1]; int head[M], cnt; inline void init() { memset(head, -1, sizeof head); cnt = 0; } inline void add(int u, int v) { e[++cnt] = {.to = v, .nxt = head[u]}; head[u] = cnt; } int n, h[M], vis[M], dp[M][2]; void dfs(int u) { dp[u][1] = h[u]; for (int i = head[u]; ~i; i = e[i].nxt) { int v = e[i].to; dfs(v); dp[u][0] += max(dp[v][0], dp[v][1]); dp[u][1] += dp[v][0]; } } int main() { int n = read(); for (int i = 1; i \u003c= n; ++i) h[i] = read(); int u = read(), v = read(); init(); while (u | v) { add(v, u); vis[u] = true; u = read(), v = read(); } int root = 0; for (int i = 1; i \u003c= n; ++i) { if (!vis[i]) root = i; } dfs(root); printf(\"%d\\n\", max(dp[root][0], dp[root][1])); return 0; } 树的最小支配集 /* Loj 10157 每个点都有点权，一个点可以看守连着他的边上的点，选一些点出来，使他们能够看守整颗树上所有的点 问你最小选出来的权值 dp[0][i]表示i点被选上，则其 += min({dp[0][son], dp[2][son], dp[1][son]}) dp[1][i]表示i点没被选上，但是其父亲被选上了，则其 += min(dp[0][son], dp[2][son]) dp[2][i]表示i点没被选上，但是去其中某几个儿子被选上了，注意这个比较难转移，转移方式如下 先求出所有儿子min(dp[0][son], dp[1][son])的总和，然后在递归完后选出最小是那个儿子的dp[0][son] 即dp[2][u] = min(dp[2][u], sum - min(dp[2][v], dp[0][v]) + dp[0][v]);这行 */ #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; #define ll long long #include \u003ccctype\u003einline long long IO() {} // 快读略 const int maxn = 1e5, maxm = 1e5; const int INF = 0x3f3f3f3f; int head[maxn], cnt, dis[maxn]; //初始化 void init() { memset(head, -1, sizeof head); // memset(vis, false, sizeof vis); cnt = 0; } struct edges { int to, next; int w; edges(int to = 0, int next = -1, int w = 0) : to(to), next(next), w(w) {} }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v, int w = 0) { if (cnt == 0) init(); edge[++cnt] = edges(v, head[u], w); head[u] = cnt; } const int M = 1e4, inf = 0x3f3f3f3f; int n, m, dp[3][M], vis[M], c[M]; void dfs(int u, int fa) { dp[0][u] = c[u], dp[2][u] = inf; int sum = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; dfs (v, u); dp[0][u] += min({dp[0][v], dp[2][v], dp[1][v]}); if (fa != -1) dp[1][u] += min(dp[2][v], dp[0][v]); sum += min(dp[2][v], dp[0][v]); } for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; dp[2][u] = min(dp[2][u], sum - min(dp[2][v], dp[0][v]) + dp[0][v]); } } int main() { n = IO(); init(); for (int i = 0; i \u003c n; ++i) { int u = IO(), w = IO(), k = IO(); c[u] = w; while (k--) { int v = IO(); add(u, v), add(v, u); } } dfs(1, -1); printf(\"%d\", min(dp[0][1], dp[2][1])); return 0; } 树的最小点覆盖 /* Loj10156 每个点都能看到他所连着的边，问你选出最少的点使树上所有的边都能被看到 dp[0][i]表示不选i点的最小选择数 则其 += dp[1][son] dp[1][i]表示选i点的最小选择数，则其 += min(dp[0][son], dp[1][son]) */ #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; #define ll long long #include \u003ccctype\u003einline long long IO() {} // 快读略 const int maxn = 1e5, maxm = 1e5; const int INF = 0x3f3f3f3f; int head[maxn], cnt, dis[maxn]; //初始化 void init() { memset(head, -1, sizeof head); // memset(vis, false, sizeof vis); cnt = 0; } struct edges { int to, next; int w; edges(int to = 0, int next = -1, int w = 0) : to(to), next(next), w(w) {} }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v, int w = 0) { if (cnt == 0) init(); edge[++cnt] = edges(v, head[u], w); head[u] = cnt; } const int M = 1e4; int n, m, dp[2][M], vis[M]; void dfs(int u, int fa) { dp[1][u] = 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; dfs(v, u); dp[1][u] += min(dp[0][v], dp[1][v]); dp[0][u] += dp[1][v]; } } int main() { n = IO(); for (int i = 0; i \u003c n; ++i) { int u = IO(), k = IO(); while (k--) { int v = IO(); add(u, v), add(v, u); } } dfs(0, -1); // printf(\"%d\\n\", ans); printf(\"%d\", min(dp[0][0], dp[1][0])); return 0; } 树的直径","date":"2021-07-27","objectID":"/2021/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%A5%97%E8%B7%AF%E6%9D%BF%E5%AD%90/:0:1","tags":null,"title":"动态规划套路板子","uri":"/2021/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%A5%97%E8%B7%AF%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","动态规划"],"content":"最长上升子序列 朴素动态规划 dp[N], ans = 1; for (int i = 1; i \u003c= n; ++i) { dp[i] = 1; for (int j = 1; j \u003c i; ++j) { if (a[j] \u003c a[i]) { // 严格上升用 \u003c , 否则用 \u003c= dp[i] = max(dp[i], dp[j] + 1); } } ans = max(ans, dp[i]); } 贪心 // 坑（未补） 树状数组（或线段树）优化动态规划（直接优化） inline long long IO() {} using namespace std; const int N = 1e5 + 5, M = 1e6 + 5, inf = 1e9; int a[M]; unordered_map\u003cint, int\u003e mp; void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } #define lb(x) (x \u0026 (-x)) int bit[M], n; int get(int i) { int res = 0; while (i) { res = max(res, bit[i]), i -= lb(i); } return res; } void update(int i, int v, int\u0026 len) { while(i \u003c= len) { bit[i] = max(bit[i], v), i += lb(i); } } void problem() { int n = IO(); vector\u003cint\u003e arr; for (int i = 0; i \u003c n; ++i) a[i] = IO(), arr.push_back(a[i]); sort(arr.begin(), arr.end()); arr.erase(unique(arr.begin(), arr.end()), arr.end()); int cnt = 0, res = 0, len = arr.size(); for (int x : arr) mp[x] = ++cnt; for (int i = 0; i \u003c n; ++i) { int ans = get(mp[a[i]] - 1) + 1; res = max(ans, res); update(mp[a[i]], ans, len); } print(res); } int main() { int n = 1; while (n--) { problem(); } return 0; } 树状数组（或线段树）优化（将值排序，求下标的最长上升子序列） #define ll long long #define all(x) x.begin(), x.end() inline long long IO() {} using namespace std; const int N = 1e5 + 5, M = 1e6 + 5, inf = 1e9; int num[N], sum[410]; ll a[210]; void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } struct pii{ int x, indx; }p[N]; #define lb(x) (x \u0026 (-x)) int bit[N], n; int get(int i) { int res = 0; while (i) { res = max(res, bit[i]), i -= lb(i); } return res; } void update(int i, int v) { while(i \u003c= n) { bit[i] = max(bit[i], v), i += lb(i); } } void problem() { n = IO(); for (int i = 0; i \u003c n; ++i) p[i].x = IO(), p[i].indx = i + 1; sort(p, p + n, [] (pii \u0026i, pii \u0026j) { if (i.x == j.x) return i.indx \u003e j.indx; return i.x \u003c j.x; }); int res = 0; for (int i = 0; i \u003c n; ++i) { int ans = get(p[i].indx - 1) + 1; res = max(ans, res); update(p[i].indx, ans); } print(res); } int main() { int n = 1; while (n--) { problem(); } return 0; } ","date":"2021-07-27","objectID":"/2021/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%A5%97%E8%B7%AF%E6%9D%BF%E5%AD%90/:0:2","tags":null,"title":"动态规划套路板子","uri":"/2021/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%A5%97%E8%B7%AF%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","计算几何"],"content":"二维几何（未完善） #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003ccmath\u003e#include \u003cvector\u003e /** * 本板子属于半成品，有些功能并没有验证 * 函数说明： * 关于点的函数 * 点的Point(double, double) 构造函数 * + 向量加法 * - 向量减法 * == 判断两个点是否相等 * *(Point) 向量点乘 * *(double) 向量伸长(没有除法，要用除法直接乘倒数) * ^ 向量叉乘 * \u003c 点对点的比较 * double len() 向量的长度，也可以用来求两个点的距离 * double len2() const; 向量长度的平方 * double dist(Point); 判断p点到这个点的距离 * double angle(Point, Point); // 传入两个点a b， 返回 角apb 的弧度 * Point rotate(double angle) 向量逆时针旋转angle弧度 * Point rotate(Point, double) 点让点p逆时针旋转angle弧度 * void print() 将点输出 * int init() 输入点的坐标 返回值和scanf相同 * 其他非结构体函数 * angle(Point\u0026, Point\u0026) 计算两个向量的夹角 * * 关于线的函数 * Line(Point, Point) 构造函数 * Line(Point, double) 根据一个点和一个倾斜角 0 \u003c= angle \u003c PI确定直线 （未验证） * double len() 返回线段的长度 * Point vec(); 获取该线的向量 * double point(double t) 返回距离点p向前t倍向量的点 * double angle() 返回直线的倾斜角 范围[0, PI) (未验证) * int PointAndLine(Point); // 点和直线的关系，1 点在线左边，2 右边， 3 线上面 * double disPointToLine(const Point\u0026) 点到这条直线的距离 * double disPointToSeg(const Point\u0026) 点到这条线段的距离（未验证） * Point getPro(const Point\u0026) 点在这条线上的投影 （未验证） * Point getSym(const Point\u0026) 点关于这条线的对称点 （未验证） * bool isOnLine(const Point\u0026) 验证该点是否在这条直线上（未验证） * bool isOnSeg(const Point\u0026) 验证该点是否在这条线段上（未验证） * Point cross(Line\u0026) 直线和这条直线的交点，前提是相交 * void print() 输出这条线段 * * 其他非结构体 * int LineAndLine(Line\u0026, Line\u0026) 直线和直线的关系 0平行 1重合 2相交 （未验证） * Point getLineInter(const Line\u0026, const Line\u0026) 求两直线的交点,必须相交才能调用 （此函数有问题） * int SegAndSeg(const Line\u0026 l1, const Line\u0026 l2) 两个线段的关系 0不相交 1非规范相交(其中一个线段的端点和另一个线段相交) 2规范相交 （未验证） * int LineAndSeg(const Line\u0026 line, const Line\u0026 seg) 直线和线段的关系，0不相交 1非规范相交 2规范相交 （未验证） * * 关于圆的函数 * Circle(Point, double) 构造函数 * Circle(Point, Point, Point) 过三点的圆 * double area() const; 返回圆的面积 * double circum() const 返回圆的周长 * int PointAndCircle(Point\u0026) 点和圆的关系 返回 0圆外 1圆上 2圆内 * int LineAndCircle(Point\u0026) 点和圆的关系 返回 0不相交 1相交 2相交两个点（未验证） * int CircleAndCircle(Circle\u0026) 圆和圆的关系 返回 0内含 1内切 2相交两点 3外切 4外离 （未验证） * * 关于三角形的函数 * Triangle(Point, Point, Point) 构造函数 * double area() const 返回三角形函数 * Circle outerCircle() 获取三角形的外接圆 * * 关于多边形的函数 * Polygon(vector\u003cPoint\u003e\u0026) 构造函数 * double circum(); 求凸包的周长 * void graham(Polygon\u0026) 求凸包 传入值为需要求出的凸包的点集 * int PointAndPolgon(Point\u0026) 判断点与多边形的关系，0外 1内 2边上 3点上 （未实现） * double minRectCover() 点集的最小矩形覆盖，自己必须是（逆时针）凸包才能调用 （未实现） * Circle minCircleCover() 点集的最小圆覆盖 */ using namespace std; const double eps = 1e-8, PI = acos(-1.0); int dcmp(double x) { if (fabs(x) \u003c eps) return 0; return x \u003e 0 ? 1 : -1; } /******************************点*******************************/ /* 除了结构体内部函数还有 angle(Point\u0026 a, Point\u0026 b) // 两个向量的夹角 */ struct Point { double x, y; Point(double x = 0, double y = 0) : x(x), y(y) {} Point operator + (const Point\u0026) const; Point operator - (const Point\u0026) const; double operator * (const Point\u0026) const; // 点乘 double operator ^ (const Point\u0026) const; // 叉乘 bool operator == (const Point\u0026) const; bool operator \u003c (const Point\u0026) const; // 排序需要 Point operator * (double); //向量伸长b倍 double len() const; // 向量的长度 double len2() const; // 向量长度的平方 double dist(Point); // 判断p点到这个点的距离 double angle(Point, Point); // 传入两个点a b， 返回 角apb 的弧度 Point rotate(double); // 向量逆时针旋转a弧度后 Point rotate(Point\u0026, double); // 点绕p点顺时针旋转a弧度后 void print() { printf(\"%.2f %.2f\", x, y); } int init() { return scanf(\"%lf%lf\", \u0026x, \u0026y); } }; Point Point::operator + (const Point\u0026 b) const { return Point(x + b.x, y + b.y); } Point Point::operator - (const Point\u0026 b) const { return Point(x - b.x, y - b.y); } // 点乘 double Point::operator * (const Point\u0026 b) const { return x * b.x + y * b.y; } // 叉乘 double Point::operator ^ (const Point\u0026 b) const { return x * b.y - y * b.x; } bool Point::operator == (const Point\u0026 b) const { return !dcmp(x - b.x) \u0026\u0026 !dcmp(y - b.y); } bool Point::operator \u003c (const Point\u0026 b) const { return (!dcmp(x - b.x)) ? dcmp(y - b.y) \u003c 0 : x \u003c b.x; } // 向量的长度 double Point::len() const { return hypot(x, y); } // 向量长度平方 double Point::len2() const { return x * x + y * y; } // 判断p点到这个点的距离 double Point::dist(Point p) { return hypot(x - p.x, y - p.y); } // 向量伸长b倍 Point Point::operator * (double b) ","date":"2021-07-27","objectID":"/2021/07/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%9D%BF%E5%AD%90/:0:0","tags":null,"title":"计算几何板子","uri":"/2021/07/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","字符串"],"content":"1. KMP const int M = 1e6 + 5; //普通版本 void getnext(char *x, int len, int *nxt) { int i = 0, j; j = nxt[0] = -1; while (i \u003c len) { while(j != -1 \u0026\u0026 x[i] != x[j]) j = nxt[j]; nxt[++i] = ++j; } } //略微优化版本 void getNext(char *x, int len, int *nxt) { int i = 0, j; j = nxt[0] = -1; while (i \u003c len) { while (j != -1 \u0026\u0026 x[i] != x[j]) j = nxt[j]; if (x[++i] == x[++j]) nxt[i] = nxt[j]; else nxt[i] = j; } } // y是主串 int nxt[M]; int kmpCount(char *y, int n, char *x, int m) { int i = 0, j = 0, ans = 0; getnext(x, m, nxt); while (i \u003c n) { while (j != -1 \u0026\u0026 y[i] != x[j]) j = nxt[j]; ++i, ++j; if (j \u003e= m) ++ans, j = nxt[j]; } return ans; } ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%BF%E5%AD%90/:0:1","tags":null,"title":"字符串板子","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","字符串"],"content":"2. 字符串Hash unsigned int DJBHash(const char *str) { unsigned int hash = 5381; while (*str) hash += (hash \u003c\u003c 5) + (*str++); return (hash \u0026 0x7fffffff); //7个f } unsigned int BKDRHash(const char *str) { unsigned int seed = 131; // 31 131 1313 13131 131313... unsigned int hash = 0; while (*str) hash = hash * seed + (*str++); return (hash \u0026 0x7fffffff); } #define ull unsigned long long ull strhash(const char *s) { ull seed = 1313, res = 0; // 31 131 1313 13131 while (*s) res = res * seed + (*s++); return res; } ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%BF%E5%AD%90/:0:2","tags":null,"title":"字符串板子","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","字符串"],"content":"3. 马拉车 ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%BF%E5%AD%90/:0:3","tags":null,"title":"字符串板子","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","字符串"],"content":"4. exkmp void pre_exkmp(char x[], int m, int next[]) { next[0] = m; int j = 0; while (j + 1 \u003c m \u0026\u0026 x[j] == x[j + 1]) j++; next[1] = j; int k = 1; for (int i = 2; i \u003c m; i++) { int p = next[k] + k - 1; int L = next[i - k]; if (i + L \u003c p + 1) next[i] = L; else { j = max(0, p - i + 1); while (i + j \u003c m \u0026\u0026 x[i + j] == x[j]) j++; next[i] = j; k = i; } } } void exkmp(char x[], int m, char y[], int n, int next[], int extend[]) { pre_exkmp(x, m, next); int j = 0; while (j \u003c n \u0026\u0026 j \u003c m \u0026\u0026 x[j] == y[j]) j++; extend[0] = j; int k = 0; for (int i = 1; i \u003c n; i++) { int p = extend[k] + k - 1; int L = next[i - k]; if (i + L \u003c p + 1) extend[i] = L; else { j = max(0, p - i + 1); while (i + j \u003c n \u0026\u0026 j \u003c m \u0026\u0026 y[i + j] == x[j]) j++; extend[i] = j; k = i; } } } ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%BF%E5%AD%90/:0:4","tags":null,"title":"字符串板子","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","图论"],"content":"前置存图 const int N = 1e5 + 10, M = 2e5 + 10; const int INF = 0x3f3f3f3f; int head[N], cnt; //初始化 void init(int n) { fill_n(head, n + 5, -1); cnt = -1; } struct edges { int to, next; int w; void add(int t, int n, int w) { to = t, next = n, this-\u003ew = w; } }edge[N \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v, int w) { edge[++cnt].add(v, head[u], w); head[u] = cnt; } ","date":"2021-07-27","objectID":"/2021/07/%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:1","tags":null,"title":"图论板子","uri":"/2021/07/%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","图论"],"content":"1. 最短路 dijkstra //顶点数和边数 const int maxn = 1e5 + 10, maxm = 2e5 + 10; const int INF = 0x3f3f3f3f; int head[maxn], cnt, dis[maxn]; bool vis[maxn]; //初始化 void init(int n) { // n个点 fill_n(head, n + 1, -1); cnt = 0; } struct edges { int to, next; int w; edges(int to = 0, int next = -1, int w = 0) : to(to), next(next), w(w) {} }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add_edges(int u, int v, int w) { edge[++cnt] = edges(v, head[u], w); head[u] = cnt; } struct qnode{ int v; int w; qnode(int v = 0, int w = 0) : v(v), w(w) {} bool operator\u003c (const qnode \u0026t) const { return w \u003e t.w; } }; void dij(int n, int s) {//n 为顶点数， m 为边数 for (int i = 0; i \u003c= n; ++i) dis[i] = INF, vis[i] = 0; dis[s] = 0; priority_queue\u003cqnode\u003e heap; heap.push(qnode(s, dis[s])); while (heap.size()) { int u = heap.top().v; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; int w = edge[i].w; if (!vis[v] \u0026\u0026 dis[u] + w \u003c dis[v]) { //松弛 dis[v] = dis[u] + w; heap.push(qnode(v, dis[v])); } } } } bellman-ford const int maxn = 1e5 + 10, maxm = 2e5 + 10, inf = 0x3f3f3f3f; int dis[maxn]; struct edges { int u, v, w; edges(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) {} } edge[maxm]; bool bf(int n, int m, int s) { // n个点， m个边， s为起点 fill_n(dis, n + 1, inf); dis[s] = 0; for (int k = 1; k \u003c n; k++) { int ok = 1; for (int i = 1; i \u003c= m; i++) { if (dis[edge[i].v] \u003e dis[edge[i].u] + edge[i].w) { //松弛 dis[edge[i].v] = dis[edge[i].u] + edge[i].w; ok = 0; } } if (ok) break; // 小优化，无松弛操作 } for (int i = 1; i \u003c= m; i++) { if (dis[edge[i].v] \u003e dis[edge[i].u] + edge[i].w) { return false; // 有负环 } } return true;// 无负环 } spfa const int maxn = 1e5 + 10, maxm = 2e5 + 10, inf = 0x3f3f3f3f; int dis[maxn], num[maxn], head[maxn], cnt; //num 数组是判断是否有负环 bool inq[maxn]; void init(int n) { // n个点 fill_n(head, n + 5, -1); cnt = 0; } struct edges { int to, w, next; edges(int to = 0, int w = 0, int next = -1) : to(to), w(w), next(next) {} } edge[maxm]; inline void add_edges(int u, int v, int w) { edge[++cnt] = edges(v, w, head[u]); head[u] = cnt; } bool spfa(int n, int s) {// n个点， s为起点 for (int i = 0; i \u003c= n; ++i) { dis[i] = inf, num[i] = inq[i] = 0; } queue\u003cint\u003e q; q.push(s); inq[s] = num[s] = 1, dis[s] = 0; while (q.size()) { int u = q.front(); q.pop(); inq[u] = false; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to, w = edge[i].w; if (dis[v] \u003e dis[u] + w) { dis[v] = dis[u] + w; if (!inq[v]) { q.push(v); inq[v] = true, num[v]++; if (num[v] \u003e= n) return false; //如果从1号点到x的最短路中包含至少n个点（不包括自己），则存在环 } } } } return true; } floyd const int M = 2e2; int n, m; //顶点数和边数 int dis[M][M]; void floyd() { for (int k = 0; k \u003c n; k++) { for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j++) { if (dis[i][j] \u003e dis[i][k] + dis[k][j]) { dis[i][j] = dis[i][k] + dis[k][j]; } } } } } void init() { memset(dis, 0x3f, sizeof dis); for (int i = 0; i \u003c M; ++i) dis[i][i] = 0; } ","date":"2021-07-27","objectID":"/2021/07/%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:2","tags":null,"title":"图论板子","uri":"/2021/07/%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","图论"],"content":"2. 生成树 kruskal 适合稀疏图 #define ll long long using namespace std; #include \u003ccctype\u003einline long long IO() {} //省略快读 const int M = 2e5 + 10, N = 5e5 + 5; int fa[M]; struct edges { int u, v; ll w; } e[N]; bool cmp(edges\u0026 i, edges\u0026 j) { return i.w \u003c j.w; } int findset(int x) { return x == fa[x] ? x : fa[x] = findset(fa[x]); } bool un(int a, int b) { int fa1 = findset(a), fa2 = findset(b); if (fa1 == fa2) return false; fa[fa1] = fa2; return true; } ll kruskal(int n, int m) { sort(e, e + m, cmp); for (int i = 0; i \u003c= n; ++i) fa[i] = i; int cnt = 0; ll ans = 0; for (int i = 0; i \u003c m; ++i) { if (un(e[i].u, e[i].v)) { ans += e[i].w; if (++cnt == n - 1) break; } } return n - 1 == cnt ? ans : -1; } int main() { int n = IO(), m = IO(); for (int i = 0; i \u003c m; ++i) e[i].u = IO(), e[i].v = IO(), e[i].w = IO(); printf(\"%lld\\n\", kruskal(n, m)); return 0; } ","date":"2021-07-27","objectID":"/2021/07/%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:3","tags":null,"title":"图论板子","uri":"/2021/07/%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","图论"],"content":"3. tarjan ","date":"2021-07-27","objectID":"/2021/07/%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:4","tags":null,"title":"图论板子","uri":"/2021/07/%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","图论"],"content":"4. 网络流 Edmonds-Karp算法，速度较慢 #define ll long long #include \u003ccctype\u003einline long long IO() // 快读略 const int N = 205, M = 1e4 + 5; struct edges{ int to, next; ll cap, flow;// flow为记录当前路径流的流量，cap为容量 void add(int a, int b, ll c) { to = a, next = b; cap = c, flow = 0; } }; struct EK{ edges e[M]; const ll inf = 1e18; int head[N], cnt, n = 0, vis[N], pre[N];// vis记录是否在队内, pre记录前驱内存池编号 ll minc[N]; // 记录增广路的最小流 void init(int n) { this-\u003en = n, cnt = -1; fill_n(head, n + 1, -1); } void add(int u, int v, ll cap, int f = 1) { e[++cnt].add(v, head[u], cap); head[u] = cnt; if (f) add(v, u, 0, 0); } int bfs(int s, int t) { queue\u003cint\u003e q; for (int i = 0; i \u003c= n; ++i) vis[i] = 0, pre[i] = -1; q.push(s), vis[s] = 1, minc[s] = inf;// 初始化minc为无穷大 while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (vis[v] || e[i].cap == e[i].flow) continue; vis[v] = 1, pre[v] = i; minc[v] = min(minc[u], e[i].cap - e[i].flow);// 更新最小流 if (v == t) return 1;//找到了终点（汇点） q.push(v); } } return 0; } ll ek(int s, int t) { ll ans = 0, \u0026dif = minc[t]; while (bfs(s, t)) { ans += dif; for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { e[i].flow += dif; // 正向边flow+ e[i ^ 1].flow -= dif; // 反向边flow- } } return ans; } void clearflow() { // 清空流 for (int i = 0; i \u003c= cnt; ++i) e[i].flow = 0; } }ek; int main() { int n = IO(), m = IO(), s = IO(), t = IO(); ek.init(n); for (int i = 0; i \u003c m; ++i) { int u = IO(), v = IO(), cap = IO(); ek.add(u, v, cap); } printf(\"%lld\", ek.ek(s, t)); return 0; } dinic, 当前弧优化+多路增广优化+炸点优化(模板题),复杂度$O(n^2m)$ inline long long IO() // 快读略 const int N = 205, M = 1e4 + 5; struct edges{ int to, next; ll cap, flow;// flow为记录当前路径流的流量，cap为容量 void add(int a, int b, ll c) { to = a, next = b; cap = c, flow = 0; } }; struct Dinic { edges e[M]; const ll inf = 1e18; int head[N], cnt, n = 0, deep[N], cur[N]; void init(int n) { this-\u003en = n, cnt = -1; fill_n(head, n + 1, -1); } void add(int u, int v, ll cap, int f = 1) { e[++cnt].add(v, head[u], cap); head[u] = cnt; if (f) add(v, u, 0, 0); } // bfs求增广路，一次求出多条增广路 int bfs(int s, int t) { queue\u003cint\u003e q; fill_n(deep, n + 1, 0); deep[s] = 1, q.push(s); while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (deep[v] || e[i].cap == e[i].flow) continue; deep[v] = deep[u] + 1; q.push(v); } } return deep[t] != 0; } ll dfs(int u, int t, ll flow) { if (u == t) return flow; ll nowflow = 0; for (int i = cur[u]; ~i; i = e[i].next) { cur[u] = i;// 当前弧优化 int v = e[i].to; if (deep[v] != deep[u] + 1 || e[i].cap == e[i].flow) continue; if (ll low = dfs(v, t, min(flow - nowflow, e[i].cap - e[i].flow))) { e[i].flow += low, e[i ^ 1].flow -= low; nowflow += low;// 多路增广优化 if (nowflow == flow) break; } } if (!nowflow) deep[u] = -2;// 炸点优化 return nowflow; } ll dinic(int s, int t) { ll ans = 0; while (bfs(s, t)) { for (int i = 0; i \u003c= n; ++i) cur[i] = head[i];// 预处理，方便当前弧优化 ans += dfs(s, t, inf);// 进过多路增广优化可不用循环 } return ans; } void clearflow() { // 清空流 for (int i = 0; i \u003c= cnt; ++i) e[i].flow = 0; } }dinic; int main() { int n = IO(), m = IO(), s = IO(), t = IO(); dinic.init(n); for (int i = 0; i \u003c m; ++i) { int u = IO(), v = IO(); ll c = IO(); dinic.add(u, v, c); } printf(\"%lld\", dinic.dinic(s, t)); return 0; } 最小费用最大流，将ek算法中的bfs换成spfa inline long long IO() // 快读代码略 const int N = 410, M = 2e5 + 5; struct edges { int to, next; ll cap, cost, flow; void add(int a, int b, ll c, ll d) { to = a, next = b; cap = c, cost = d, flow = 0; } }; struct MCMF{ const ll inf = 1e15; int head[N], pre[N], cnt, n, inq[N]; ll maxflow, mincost, dist[N]; edges e[M]; void add(int u, int v, ll cap, ll cost, int f = 1) { e[++cnt].add(v, head[u], cap, cost); head[u] = cnt; if (f) add(v, u, 0, -cost, 0);// 建立反向弧，费用相反 } int spfa(int s, int t) {// 利用spaf找最小费用的路，即最短路 for (int i = 0; i \u003c= n; ++i) inq[i] = 0, dist[i] = inf, pre[i] = -1; queue\u003cint\u003e q; inq[s] = 1, q.push(s), dist[s] = 0; while (q.size()) { int u = q.front(); q.pop(); inq[u] = 0; for (int i = head[u]; ~i; i = e[i]","date":"2021-07-27","objectID":"/2021/07/%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:5","tags":null,"title":"图论板子","uri":"/2021/07/%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","图论"],"content":"5. 二分图 匈牙利算法，时间复杂度$O(ev)$ int match[M]; bool vis[M]; bool dfs(int u) { for (int \u0026v : gp[u]) { if (vis[v]) continue; vis[v] = true; if (!match[v] || dfs(match[v])) { match[u] = v, match[v] = u; return true; } } return false; } // 主函数里 fill_n(match, n + 1, 0); // n是点的个数 for (int i = 1; i \u003c= n; ++i) { if (match[i]) continue; fill_n(vis, n + 1, false); dfs(i); } ","date":"2021-07-27","objectID":"/2021/07/%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:6","tags":null,"title":"图论板子","uri":"/2021/07/%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"1. 并查集 简便的路径压缩版 const int Max = 1e5 + 10; int fa[Max]; inline void init() { for (int i = 0; i \u003c Max; i++) fa[i] = i; } int findfa(int x) { return x == fa[x] ? x : fa[x] = findfa(fa[x]); } void Un(int a, int b) { int fa1 = findfa(a); int fa2 = findfa(b); if (fa1 != fa2) fa[fa1] = fa2; } 网络赛版 class UF { public: int n; // 当前连通分量数目 int cnt; vector\u003cint\u003e size; vector\u003cint\u003e parent; UF(int _n): n(_n + 1), cnt(_n + 1), size(_n + 1, 1), parent(_n + 1) { int i = 0; for (auto \u0026x : parent) x = i++; } int findset(int x) { return parent[x] == x ? x : parent[x] = findset(parent[x]); } bool unite(int x, int y) { x = findset(x); y = findset(y); if (x == y) { return false; } if (size[x] \u003c size[y]) { swap(x, y); } parent[y] = x; size[x] += size[y]; --cnt; return true; } bool conn(int x, int y) { x = findset(x); y = findset(y); return x == y; } }; ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/:0:1","tags":null,"title":"数据结构板子","uri":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"2. 树状数组 单点修改与区间查询 // 修改复杂度与查询复杂度O(logn) #define lb(x) ((x) \u0026 (-x)) #define ll long long const int N = 1e6 + 5, M = 2e5 + 5; ll n, m, a[N], bit[N]; // 初始化 void build(int n) { for (int i = 1; i \u003c= n; ++i) { bit[i] += a[i]; int j = lb(i) + i; if (j \u003c= n) bit[j] += bit[i]; } } // 单点修改 void update(int index, ll val, int n) { while (index \u003c= n) { bit[index] += val; index += lb(index); } } // 前缀查询 ll get(int index, int n) { ll res = 0; while (index) { res += bit[index]; index -= lb(index); } return res; } // 区间和查询 ll get(int l, int r, int n) { return get(r, n) - get(l - 1, n); } 区间修改，区间查询 设$d[i] = a[i] - a[i - 1]$ 则 $a[ x ] = \\sum_{i = 1}^{x}{d_i}$ 设 $sum[ x ] = \\sum_{i = 1}^{x}{a_i}$ 即 $sum[ x ] = d[1] + d[1] + d[2] + d[1] + d[2] + d[3] + …… + d[1] + ……+ d[n]$ 化简得 $sum[ x ] = \\sum_{i = 1}^{x}{d_i \\times (n - i + 1)}$ 得 $sum[ x ] = (n + 1) \\times \\sum_{i = 1}^{x}{d_i} - \\sum_{i = 1}^{x}{i \\times d_i}$ 固开两个树状数组，一个维护差分数组$d_i$，一个维护$i \\times d_i$ #define lb(x) ((x) \u0026 (-x)) #define int long long const int N = 5e3 + 5, M = 1e6 + 5; int n, m, d[M], id[M]; // 基础树状数组单点更新 void update(int i, int val, int *bit) { while (i \u003c= n) { bit[i] += val; i += lb(i); } } // 单点修改 void update(int i, int val) { update(i, val, d), update(i, val * i, id); } // 区间修改 void update(int l, int r, int val) { update(l, val, d), update(r + 1, -val, d); update(l, l * val, id), update(r + 1, (-val) * (r + 1), id); } // 前缀查询 int get(int i, int *bit) { int res = 0; while (i) res += bit[i], i -= lb(i); return res; } // 区间和查询 int get(int l, int r) { int res = get(r, d) * (r + 1) - get(r, id); res -= get(l - 1, d) * l - get(l - 1, id); return res; } 网络赛类封装版 template\u003cclass T\u003e class BIT{ inline int lb(int x) { return x \u0026 (-x); } vector\u003cT\u003e bit; T getSum(int i) { T ret = 0; while (i \u003e 0) { ret += bit[i]; i -= lb(i); } return ret; } int n; public: BIT (int n, T val) : bit(n + 1, val), n(n) {}; BIT (int n, T *a) { rebuild(n, a); } void rebuild(int n, T *a) { bit.clear(); bit.push_back(); this-\u003en = n; for (int i = 1; i \u003c= n; ++i) { bit.push_back(a[i]); } for (int i = 1; i \u003c= n; ++i) { if (i + lb(i) \u003c= n) { bit[i + lb(i)] += bit[i]; } } } void point_update(int index, T val) { while (index \u003c= n) { bit[index] += val; index += lb(index); } } T get(int l, int r) { if (l \u003e r) return 0; return getSum(r) - getSum(l - 1); } }; ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/:0:2","tags":null,"title":"数据结构板子","uri":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"3. 线段树 精简版 // 宏 #define ls ((node) \u003c\u003c 1) #define rs (((node) \u003c\u003c 1) | 1) // 变量 const int N = 2e5 + 5; ll seg[N \u003c\u003c 2], lazy[N \u003c\u003c 2], arr[N]; // 操作 ll op(ll a, ll b) { return a + b; } // 题意不同，函数内部不同 void push_down(int l, int r, int node) { if (!lazy[node]) return; // 这里如果0也有意义的话多开一个数组标记 int mid = (l + r) \u003e\u003e 1; lazy[ls] += lazy[node], lazy[rs] += lazy[node]; seg[ls] += (mid - l + 1) * lazy[node]; seg[rs] += (r - mid) * lazy[node]; lazy[node] = 0; } // 初始化 void build(int l, int r, int node) { if (l == r) { seg[node] = arr[l]; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls), build(mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 单点修改 void update(int indx, ll v, int l, int r, int node) { if (l == r) { // 题意不同，这里更新操作不同 seg[node] = v; return; } int mid = (l + r) \u003e\u003e 1; if (indx \u003c= mid) update(indx, v, l, mid, ls); else update(indx, v, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间修改 void update(int ql, int qr, ll v, int l, int r, int node) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) { // 题意不同，这里更新操作不同 lazy[node] += v; seg[node] += (r - l + 1) * v; return; } push_down(l, r, node); int mid = (l + r) \u003e\u003e 1; if (ql \u003c= mid) update(ql, qr, v, l, mid, ls); if (qr \u003e mid) update(ql, qr, v, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间查找 ll get(int ql, int qr, int l, int r, int node) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) return seg[node]; push_down(l, r, node); // 保证单点的情况下这句话可以注释掉 int mid = (l + r) \u003e\u003e 1; ll ret = 0; // 题意不同，初始化不同 if (ql \u003c= mid) ret = get(ql, qr, l, mid, ls); if (qr \u003e mid) ret = op(get(ql, qr, mid + 1, r, rs), ret); return ret; } 结构体版 #include \u003cbits/stdc++.h\u003eusing namespace std; const int M = 1e6; typedef long long ll; template\u003cclass T\u003e struct Tree{ #define ls(node) (node \u003c\u003c 1) #define rs(node) ((node \u003c\u003c 1) | 1) Tree(int len = 10): len(len) {} T sum[M \u003c\u003c 2], lazy[M \u003c\u003c 2], arr[M]; int len; private: void pushup(const int node) {// 写题目要求维护的代码，如求和，最大最小…… sum[node] = max(sum[ls(node)], sum[rs(node)]); } void pushdown(int l, int r, const int node) {//同pushup int mid = (l + r) \u003e\u003e 1; lazy[ls(node)] += lazy[node], lazy[rs(node)] += lazy[node]; sum[ls(node)] += (mid - l + 1) * lazy[node]; sum[rs(node)] += (r - mid) * lazy[node]; lazy[node] = 0; } void build(int l, int r, int node) { if (l == r) { sum[node] = arr[l]; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls(node)), build(mid + 1, r, rs(node)); pushup(node); } void update(int ql, int qr, T v, int l, int r, int node) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) { sum[node] += (r - l + 1) * v;//更新操作根据题目要求更改 lazy[node] += v; return; } if (lazy[node]) pushdown(l, r, node); int mid = (l + r) \u003e\u003e 1; if (ql \u003c= mid) update(ql, qr, v, l, mid, ls(node)); if (qr \u003e mid) update(ql, qr, v, mid + 1, r, rs(node)); pushup(node); } T getAsk(int ql, int qr, int l, int r, int node) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) return sum[node];//上同 if (lazy[node]) pushdown(l, r, node); T res = 0; int mid = (l + r) \u003e\u003e 1; if (ql \u003c= mid) res = getAsk(ql, qr, l, mid, ls(node)); if (qr \u003e mid) res = max(res, getAsk(ql, qr, mid + 1, r, rs(node))); return res; } public: //以下为可以，直接调用的函数 void build() { build(1, len, 1); } void update(int ql, int qr, T v) { update(ql, qr, v, 1, len, 1); } void update(int index, T v) { update(index, index, v, 1, len, 1); } T getAsk(int ql, int qr) { return getAsk(ql, qr, 1, len, 1); } void clear() { memset(arr, 0, sizeof(T) * (len + 10)); memset(sum, 0, sizeof(T) * (len \u003c\u003c 2)); memset(lazy, 0, sizeof(T) * (len \u003c\u003c 2)); } T\u0026 operator[] (int x) { return arr[x]; } }; int main(){ return 0; } 类版-网络赛 #include \u003cbits/stdc++.h\u003e using namespace std; /** * 使用说明： * 本线段树板子可用于多数 网络赛 * 需要注意的是此板子在性能方面由于三层封装，固较简洁版的线段树性能慢，但灵活性高（适合网络赛抢时间） * 使用时只需要修改 \"可修改区的上下界\" 中间的代码部分 * lazy使用结构体封装是应付在某些题目在区间修改时有两种操作，下面给的例题有示例 * vals是最终题目需要维护的东西（sum, max, min……），针对不同的操作只需修改结构体内的加法（+）操作即可 * 同时若题目需要区间修改，则直接修改区间修改部分的代码即可，单点修改同理 * 注意：区间修改针对不同的操作，lazy中的加等于（+=）也要具体根据题意修改 * 例题1：洛谷 */ /****************************可修改区上界******************************/ template\u003cclass T\u003e struct lazy{ T lazy1; lazy(T lazy1 = 0){ this-\u003elazy1 = lazy1; } void operator+= (const lazy\u003c","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/:0:3","tags":null,"title":"数据结构板子","uri":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"4. ST表 const int M = 1e5 + 5; int st[M][30], lg[M]; // st表预处理, 注意下标从1开始到n结束 void init(int *a, int n) { lg[0] = -1; for (int i = 1; i \u003c= n; ++i) lg[i] = lg[i \u003e\u003e 1] + 1, st[i][0] = a[i]; for (int j = 1; j \u003c= lg[n]; ++j) { int k = 1 \u003c\u003c (j - 1); for (int i = 1; i + k - 1 \u003c= n; ++i) { st[i][j] = max(st[i][j - 1], st[i + k][j - 1]); } } } // 询问 // 尽可能让l + 2^(len) - 1接近r int get(int l, int r) { int x = lg[r - l + 1]; return max(st[l][x], st[r - (1 \u003c\u003c x) + 1][x]); } ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/:0:4","tags":null,"title":"数据结构板子","uri":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"5. 分块 const int N = 1e5 + 5, M = 500; #define ll long long ll a[N]; int belong[N]; struct blocks { int l, r; ll lazy; blocks() : lazy(0){} }b[M]; // 以下函数是基本不变的 void build(int n) { int siz = sqrt(n), cnt = n / siz; if (n % siz) ++cnt; for (int i = 1; i \u003c= cnt; ++i) { b[i].l = (i - 1) * siz + 1; b[i].r = i * siz; } b[cnt].r = n; for (int i = 1; i \u003c= n; ++i) belong[i] = (i - 1) / siz + 1; } ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/:0:5","tags":null,"title":"数据结构板子","uri":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"6. 莫队 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e using namespace std; const int M = 1e5 + 10; int n, m, block, arr[M], pos[M], ans[M], res; struct MO{ int l, r, k; MO(int l = 0, int r = 0, int k = 0) : l(l), r(r), k(k) {} }q[M]; bool cmp(MO a, MO b) { if (pos[a.l] ^ pos[b.l]) {//不在同一个块 return pos[a.l] \u003c pos[b.l]; } if (pos[a.l] \u0026 1) return a.r \u003c b.r; return b.r \u003c a.r; } void add(int x) { } void del(int x) { } void solve() { int l = 1, r = 0; for (int i = 0; i \u003c m; i++) { while (l \u003e q[i].l) add(--l); while (l \u003c q[i].l) del(l++); while (r \u003c q[i].r) add(++r); while (r \u003e q[i].r) del(r--); ans[q[i].k] = res;//res根据题目意思来 } } void init() { scanf(\"%d %d\", \u0026n, \u0026m); block = sqrt(n); for (int i = 1; i \u003c= n; i++) { scanf(\"%d\", arr + i); pos[i] = i / block; } for (int i = 0; i \u003c m; i++) { int l, r; scanf(\"%d %d\", \u0026l, \u0026r); q[i] = MO(l, r, i); } sort(q, q + m, cmp); } int main() { init(); solve(); return 0; } ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/:0:6","tags":null,"title":"数据结构板子","uri":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"7. 平衡树 fhq treap // 洛谷板子题 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003crandom\u003e#include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } using namespace std; const int N = 4e5 + 10; mt19937 rnd(233); struct treap{ int val, l, r, size, key; }fhq[N]; int root, cnt; inline void update(int now) { fhq[now].size = fhq[fhq[now].l].size + fhq[fhq[now].r].size + 1; } int new_node(int val) { fhq[++cnt] = {.val = val, .l = 0, .r = 0, .size = 1, .key = rnd()}; return cnt; } void split(int now, int val, int \u0026x, int \u0026y) { if (!now) { x = y = 0; return; } if (fhq[now].val \u003c= val) x = now, split(fhq[now].r, val, fhq[now].r, y); else y = now, split(fhq[now].l, val, x, fhq[now].l); update(now); } int merge(int x, int y) { if (!x || !y) return x | y; // 大根堆 if (fhq[x].key \u003e fhq[y].key) { //右下角 fhq[x].r = merge(fhq[x].r, y), update(x); return x; } // 左下角 fhq[y].l = merge(x, fhq[y].l), update(y); return y; } // 插入 inline void insert(int val) { int x, y; split(root, val, x, y); root = merge(merge(x, new_node(val)), y); } // 按值删除 inline void del(int val) { int x, y, z; split(root, val, x, z); split(x, val - 1, x, y); y = merge(fhq[y].l, fhq[y].r); root = merge(merge(x, y), z); } // 按值获取排名 inline int getrank(int val) { int x, y, ans; split(root, val - 1, x, y); ans = fhq[x].size + 1; root = merge(x, y); return ans; } // 按排名获取值 inline int getval(int rank) { int now = root; while (now) { if (fhq[fhq[now].l].size + 1 == rank) break; else if (fhq[fhq[now].l].size \u003e= rank) now = fhq[now].l; else rank -= fhq[fhq[now].l].size + 1, now = fhq[now].r; } return fhq[now].val; } // 求前驱，即严格比val小的最大值 inline int pre(int val) { int x, y; split(root, val - 1, x, y); int now = x; while (fhq[now].r) now = fhq[now].r; root = merge(x, y); return fhq[now].val; } // 求后继，即严格比val大的最小值 inline int nxt(int val) { int x, y; split(root, val, x, y); int now = y; while (fhq[now].l) now = fhq[now].l; root = merge(x, y); return fhq[now].val; } int main() { int t = IO(); while (t--) { int q = IO(), val = IO(); if (q == 1) insert(val); else if (q == 2) del(val); else if (q == 3) printf(\"%d\\n\", getrank(val)); else if (q == 4) printf(\"%d\\n\", getval(val)); else if (q == 5) printf(\"%d\\n\", pre(val)); else printf(\"%d\\n\", nxt(val)); } return 0; } spaly 替罪羊 ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/:0:7","tags":null,"title":"数据结构板子","uri":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"8. 左偏树 ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/:0:8","tags":null,"title":"数据结构板子","uri":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"9. 主席树 主席树（静态）洛谷模板题 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } using namespace std; /*************************************离散化********************************************/ // vt存放可用于查询原本的数（用离散化值），打表后用于查询离散化表（用下标） vector\u003cint\u003e vt; inline int get_id(const int \u0026x) { return lower_bound(vt.begin(), vt.end(), x) - vt.begin() + 1; } inline void erase_vt() { sort(vt.begin(), vt.end()); vt.erase(unique(vt.begin(), vt.end()), vt.end()); } // 打表, 注意，原数组下标要从1开始，返回离散化后的表大小 inline int id_table(int n, int *a, vector\u003cint\u003e \u0026res) { res.emplace_back(0); for (int i = 1; i \u003c= n; ++i) res.emplace_back(get_id(a[i])); return vt.size(); } /*************************************主席树********************************************/ const int N = 2e5 + 5; struct nodes{ int l, r, sum; nodes() : sum(0) {} }hjt[N \u003c\u003c 5]; int root[N], cnt; // 记录每个根结点的内存池编号， 内存池 int build(int l, int r) { int now = ++cnt; // 内存申请 if (l \u003c r) { int mid = (l + r) \u003e\u003e 1; hjt[now].l = build(l, mid); hjt[now].r = build(mid + 1, r); } return now; } // 插入新节点的操作 int update(int pre, int l, int r, int x) { int now = ++cnt; // 内存申请 hjt[now] = hjt[pre], ++hjt[now].sum; // 继承 if (l \u003c r) { // 寻找拼接点 int mid = (l + r) \u003e\u003e 1; if (x \u003c= mid) hjt[now].l = update(hjt[now].l, l, mid, x); // 如果x在左边，则让当前新节点的左孩子接继承后的左孩子 else hjt[now].r = update(hjt[now].r, mid + 1, r, x); // 否则同理 } return now; } // 返回第qr版本的主席树 - 第ql版本的主席树， 注意返回的是离散化后的值 int get(int ql, int qr, int l, int r, int k) { if (l == r) return l; int mid = (l + r) \u003e\u003e 1; int dif = hjt[hjt[qr].l].sum - hjt[hjt[ql].l].sum; if (k \u003c= dif) return get(hjt[ql].l, hjt[qr].l, l, mid, k); // 左孩子上 return get(hjt[ql].r, hjt[qr].r, mid + 1, r, k - dif); // 右孩子上 } /*************************************主函数********************************************/ int a[N]; int main() { int n = IO(), m = IO(); for (int i = 1; i \u003c= n; ++i) a[i] = IO(), vt.emplace_back(a[i]); erase_vt(); vector\u003cint\u003e id; int siz = id_table(n, a, id); root[0] = build(1, siz); for (int i = 1; i \u003c= n; ++i) root[i] = update(root[i - 1], 1, siz, id[i]); while (m--) { int l = IO(), r = IO(), k = IO(); printf(\"%d\\n\", vt[get(root[l - 1], root[r], 1, siz, k) - 1]); } return 0; } ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/:0:9","tags":null,"title":"数据结构板子","uri":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"10. LCA // 洛谷板子题 // 注意，尽量让结点编号从1开始 #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccctype\u003e#define ll long long inline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } using namespace std; const int maxn = 5e5 + 5, maxm = 5e5 + 5; const int INF = 0x3f3f3f3f; int head[maxn], cnt; struct edges { int to, next; void add(int t, int n) { to = t, next = n; } }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v) { edge[++cnt].add(v, head[u]); head[u] = cnt; } int fa[maxn][35], dep[maxn], lg[maxn]; /* 另一种写法 void dfs(int u, int f) { deep[u] = deep[f] + 1; fa[u][0] = f; for (int i = 1; (1 \u003c\u003c i) \u003c= deep[u]; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int\u0026 v : mp[u]) { if (v ^ f) dfs(v, u); } } int lca(int a, int b) { if (deep[a] \u003c deep[b]) swap(a, b); for (int i = 18; ~i; --i) if (deep[fa[a][i]] \u003e= deep[b]) a = fa[a][i]; if (a == b) return a; for (int i = 20; ~i; --i) { if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; } return fa[a][0]; } */ void dfs(int u, int f) { fa[u][0] = f; dep[u] = dep[f] + 1; for (int i = 1; i \u003c= lg[dep[u]]; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v ^ f) dfs(v, u); } } void init(int root, int n) { // 通过检查代码，反向51行dep[root] = -1没意义，具体细节以后填这个坑 dep[root] = lg[0] = -1; memset(head, -1, sizeof head); cnt = 0; for (int i = 1; i \u003c= n; ++i) lg[i] = lg[i \u003e\u003e 1] + 1; } int lca(int a, int b) { if (dep[a] \u003c dep[b]) swap(a, b); while (dep[a] \u003e dep[b]) a = fa[a][lg[dep[a] - dep[b]]]; if (a == b) return a; for (int i = lg[dep[a]]; ~i; --i) { if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; } return fa[a][0]; } int main() { int n = IO(), m = IO(), root = IO(); init(root, n); for (int i = 1; i \u003c n; ++i) { int u = IO(), v = IO(); add(u, v), add(v, u); } dfs(root, 0); while (m--) { int a = IO(), b = IO(); printf(\"%d\\n\", lca(a, b)); } return 0; } ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/:0:10","tags":null,"title":"数据结构板子","uri":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"11. 树链剖分 // 洛谷板子题 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ciostream\u003e#include \u003ccmath\u003e#include \u003cbitset\u003eusing namespace std; #define ll long long const int N = 1e5 + 5, M = 2e5 + 5; const int maxn = 1e5 + 5, maxm = 2e5 + 5; const int INF = 0x3f3f3f3f; int head[maxn], cnt; //初始化 void init() { memset(head, -1, sizeof head); cnt = -1; } struct edges { int to, next; void add(int t, int n) { to = t, next = n; } }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v) { edge[++cnt].add(v, head[u]); head[u] = cnt; } /*******************************树链剖分**********************************/ int fa[N], dep[N], siz[N], son[N]; void dfs1(int u, int f) { fa[u] = f, siz[u] = 1; dep[u] = dep[f] + 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == f) continue; dfs1(v, u); siz[u] += siz[v]; if (siz[v] \u003e siz[son[u]]) son[u] = v; // 找重儿子 } } int v[N]; // 点上的权值 int tim, dfn[N], top[N], w[N]; // w的下标是时间戳，对应的是相应时间戳上的点的点权 void dfs2(int u, int t) { dfn[u] = ++tim, top[u] = t; w[tim] = v[u]; if (!son[u]) return; dfs2(son[u], t); for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa[u] || v == son[u]) continue; dfs2(v, v); } } /*******************************线段树******************************/ inline int ls(const int\u0026 x) { return x \u003c\u003c 1;} inline int rs(const int\u0026 x) { return x \u003c\u003c 1 | 1;} ll seg[N \u003c\u003c 2], lazy[N \u003c\u003c 2], p; int n, m; inline ll op(const ll\u0026 a, const ll\u0026 b) { // seg[x] = max(seg[ls(x)], seg[rs(x)]); return (a + b) % p; } inline void push_down(const int\u0026 l, const int\u0026 r, const int\u0026 node) { if (!lazy[node]) return; lazy[ls(node)] += lazy[node], lazy[rs(node)] += lazy[node]; lazy[ls(node)] %= p, lazy[rs(node)] %= p; int mid = (l + r) \u003e\u003e 1; seg[ls(node)] = (lazy[node] * (mid - l + 1) + seg[ls(node)]) % p; seg[rs(node)] = (lazy[node] * (r - mid) + seg[rs(node)]) % p; lazy[node] = 0; } void build(int l, int r, int node = 1) { if (l == r) { seg[node] = w[l]; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls(node)), build(mid + 1, r, rs(node)); seg[node] = op(seg[ls(node)], seg[rs(node)]); } void update(int ql, int qr, ll x, int l = 1, int r = n, int node = 1) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) { lazy[node] = (lazy[node] + x) % p; seg[node] = (seg[node] + (r - l + 1) * x) % p; return; } push_down(l, r, node); int mid = (l + r) \u003e\u003e 1; if (ql \u003c= mid) update(ql, qr, x, l, mid, ls(node)); if (qr \u003e mid) update(ql, qr, x, mid + 1, r, rs(node)); seg[node] = op(seg[ls(node)], seg[rs(node)]); } int get(int ql, int qr, int l = 1, int r = n, int node = 1) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) return seg[node]; push_down(l, r, node); int mid = (l + r) \u003e\u003e 1, res = 0; if (ql \u003c= mid) res = get(ql, qr, l, mid, ls(node)); if (qr \u003e mid) res = op(res, get(ql, qr, mid + 1, r, rs(node))); return res; } /********************************树上操作**********************************/ void update_chain(int x, int y, ll z) {// 将树从 x 到 y 结点最短路径上所有节点的值都加上 z。 while (top[x] != top[y]) { if (dep[top[x]] \u003c dep[top[y]]) swap(x, y); update(dfn[top[x]], dfn[x], z); x = fa[top[x]]; } if (dep[x] \u003e dep[y]) swap(x, y); update(dfn[x], dfn[y], z); } ll get_chain(int x, int y) {//求树从 x 到 y 结点最短路径上所有节点的值之和。 int res = 0; while (top[x] != top[y]) { if (dep[top[x]] \u003c dep[top[y]]) swap(x, y); res = op(res, get(dfn[top[x]], dfn[x])); x = fa[top[x]]; } if (dep[x] \u003e dep[y]) swap(x, y); return op(res, get(dfn[x], dfn[y])); } void update_son(int x, ll z) {// 将以 x 为根节点的子树内所有节点值都加上 z update(dfn[x], dfn[x] + siz[x] - 1, z); } ll get_son(int x) {// 求以 x 为根节点的子树内所有节点值之和 return get(dfn[x], dfn[x] + siz[x] - 1); } /********************************主函数************************************/ int main() { std::ios::sync_with_stdio(false); cout.tie(0), cin.tie(0); init(); int root; cin \u003e\u003e n \u003e\u003e m \u003e\u003e root \u003e\u003e p; for (int i = 1; i \u003c= n; ++i) cin \u003e\u003e v[i]; for (int i = 1; i \u003c n; ++i) { int u, v; cin \u003e\u003e u \u003e\u003e v; add(u, v), add(v, u); } dfs1(root, root), dfs2(root, root); build(1, n); while (m--) { int q, x, y, z; cin \u003e\u003e q \u003e\u003e x; if (q == 1) { cin \u003e\u003e y \u003e\u003e z; update","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/:0:11","tags":null,"title":"数据结构板子","uri":"/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","数论"],"content":"1. gcd与lcm typedef long long ll; //最大公因数，公约数 ll gcd(ll a, ll b, ll m = 1) { while(b) m = a % b, a = b, b = m; return a; } //最小公倍数 ll lcm(ll a, ll b) { return a / gcd(a, b) * b; } ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:1","tags":null,"title":"数论板子","uri":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","数论"],"content":"2. ex_gcd /* 通解为 x' = x * c / gcd + (b / gcd) * k y' = y * c / gcd - (a / gcd) * k */ typedef long long ll; // 扩展欧几里得算法核心函数 void exgcd(ll a, ll b, ll \u0026g, ll \u0026x, ll \u0026y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } /** * 此函数为 求解 ax + by = c * 返回 x的最小正整数解 * 返回 -1 说明无解 */ ll minx(ll a, ll b, ll c) { ll x, y, g; exgcd(a, b, g, x, y); if (c % g != 0) return -1; ll t = abs(b / g); x = (x * c / g % t + t) % t; return x == 0 ? x + t : x; // 返回最小正整数解 } ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:2","tags":null,"title":"数论板子","uri":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","数论"],"content":"3. 素数筛 埃式筛 const int M = 1e5 + 5; int pri[M], cnt = 0; bool isp[M]; // 复杂度O(nloglogn) // true 为非素数， false 为素数 void table() { isp[0] = isp[1] = true; for (int i = 2; i \u003c M; i++) { if (isp[i]) continue; pri[cnt++] = i; for (int j = i + i; j \u003c M; j += i) isp[j] = true; } } 线性筛 // 复杂度O(n) const int M = 1e5 + 10; int cnt = 0; bool isp[M]; // true 为非素数， false 为素数 vector\u003cint\u003e pri; void table(int n = 1e5) { isp[0] = isp[1] = 1; for (int i = 2; i \u003c= n; ++i) { if (!isp[i]) pri.push_back(i); for (int x : pri) { if (x * i \u003e n) break; isp[x * i] = 1; if (i % x == 0) break; } } } ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:3","tags":null,"title":"数论板子","uri":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","数论"],"content":"4. 逆元 线性版 typedef long long ll; // 时间复杂度O(n) void fny(const int \u0026n, ll *inv, const ll mod) { inv[0] = inv[1] = 1; for (ll i = 2; i \u003c= n; i++) { inv[i] =((mod - mod / i) * inv[mod % i]) % mod; } } 扩欧版 typedef long long ll; void exgcd(ll a, ll b, ll \u0026g, ll \u0026x, ll \u0026y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } // ax=1(mod m) ll inverse(ll a, ll m) {//扩展欧几里得法求逆元，返回-1代表没有逆元 ll g, x, y; exgcd(a, m, g, x, y); return g == 1 ? (x % m + m) % m : -1; } 费马小定理版 //a ^ (p - 1) = 1 (mod p), p为素数 //a ^ (p - 2) = a ^ (-1) (mod p) //a 的逆元为 a ^ (p - 2) typedef long long ll; ll pow_f(ll a, ll b, const ll mo) { ll ans = 1; a %= mo; while (b) { if (b \u0026 1) ans = (ans * a) % mo; a = (a * a) % mo; b \u003e\u003e= 1; } return ans; } ll inverse(ll a, ll m) { return pow_f(a, m - 2, m); } ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:4","tags":null,"title":"数论板子","uri":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","数论"],"content":"5. 快速幂 #define ll long long ll powf(ll a, ll b, const ll mod) {// 返回a^b % mod ll res = 1; for (a %= mod; b; b \u003e\u003e= 1, a = a * a % mod) if (b \u0026 1) res = res * a % mod; return res; } ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:5","tags":null,"title":"数论板子","uri":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","数论"],"content":"6. 矩阵快速幂 结构体版 const ll MOD = 1e9 + 7; #define MO(x) ((x) % MOD) struct Mat { ll mat[10][10]; int n; // n * n 阶矩阵 Mat(int n = 2) : n(n) { memset(mat, 0, sizeof mat); }//记得修改 void to_one() { for (int i = 0; i \u003c n; i++) mat[i][i] = 1; } Mat operator*(const Mat a) const { Mat res; for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j++) { ll sum = 0; for (int k = 0; k \u003c n; k++) { sum += MO(this-\u003emat[i][k] * a.mat[k][j]); } res.mat[i][j] = MO(sum); } } return res; } ll *operator[](int x) { return mat[x]; } }; Mat pow_f(Mat a, ll b) { //a ^ b次幂 Mat ans; ans.to_one(); while (b) { if (b \u0026 1) ans = ans * a; a = a * a; b \u003e\u003e= 1; } return ans; } vector重载运算符版 #define ll long long #define vi vector\u003cll\u003e #define Mat vector\u003cvi\u003e const int X = 6; const ll mod = 1e9 + 7; Mat operator* (Mat a, Mat b) { Mat res(X, vi(X, 0)); for (int i = 0; i \u003c X; ++i) for (int j = 0; j \u003c X; ++j) for (int k = 0; k \u003c X; ++k) res[i][j] = (res[i][j] + a[i][k] * b[k][j] % mod) % mod; return res; } Mat operator^ (Mat a, long long b) { Mat res(X, vi(X, 0)); for (int i = 0; i \u003c X; ++i) res[i][i] = 1; while (b) { if (b \u0026 1) res = res * a; a = a * a, b \u003e\u003e= 1; } return res; } ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:6","tags":null,"title":"数论板子","uri":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","数论"],"content":"7. 高斯消元 普通浮点数高斯消元，洛谷模板题 // 洛谷模板题 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003cvector\u003e using namespace std; const int N = 110; const double eps = 1e-6; // 用来控制进度 // 普通的高斯消元是将矩阵转化成上三角的形式，再回带求出答案 double ans[N]; // 用来记录答案 int gauss(int n, int m, vector\u003cvector\u003cdouble\u003e\u003e \u0026a) { // n行m + 1列的增广矩阵 int r, c; // 当前行和当前列 for (r = c = 0; c \u003c m \u0026\u0026 r \u003c n; ++ c) { int maxr = r; // 记录最大 for (int i = r + 1; i \u003c n; ++i) if (abs(a[i][c]) \u003e abs(a[maxr][c])) maxr = i; // 寻找从当前行开始向下走的当前列中的绝对值最大值 if (r ^ maxr) swap(a[r], a[maxr]); // 如果不是当前行，则交换两行 if (abs(a[r][c]) \u003c eps) continue; // 如果当前行当前列的最大值为0则不作消元 for (int i = m; i \u003e= c; --i) a[r][i] /= a[r][c]; // 将当前行的从当前列开始到最后一列 for (int i = r + 1; i \u003c n; ++i) { if (abs(a[i][c]) \u003c eps) continue; // 如果改行的当前列已经是0，则不作消元 for (int j = m; j \u003e= c; --j) { // 逆向消元，可以少开一个变量 a[i][j] -= a[r][j] * a[i][c]; } } ++r; } if (r \u003c n) { // 无穷解 或者 无解 for (int i = r; i \u003c n; ++r) if (abs(a[i][n]) \u003c eps) return 0; return -1; // 无穷解 } for (int i = n - 1; ~i; --i) { // 回带 for (int j = i + 1; j \u003c n; ++j) { a[i][n] -= a[i][j] * ans[j]; } ans[i] = a[i][n]; } return 1; // 唯一解 } vector\u003cvector\u003cdouble\u003e\u003e a; int main() { int n; scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; ++i) { a.push_back({}); for (int j = 0; j \u003c= n; ++j) { double x; scanf(\"%lf\", \u0026x); a[i].push_back(x); } } if (gauss(n, n, a) == 1) { for (int i = 0; i \u003c n; ++i) printf(\"%.2f\\n\", ans[i]); } else puts(\"No Solution\"); return 0; } 浮点数高斯约旦消元法， 洛谷模板题 // 洛谷模板题 #include \u003ccstdio\u003e#include \u003ccmath\u003e#include \u003cvector\u003e using namespace std; const double eps = 1e-6; double ans[110]; // 记录答案 int gauss_j(int n, int m, vector\u003cvector\u003cdouble\u003e\u003e \u0026a) { // n行m + 1列增广矩阵 int r, c; // 当前行当前列 for (r = c = 0; c \u003c m \u0026\u0026 r \u003c n; ++c) { // int maxr = r; // 记录最大值 for (int i = r + 1; i \u003c n; ++i) if (abs(a[i][c]) \u003e abs(a[maxr][c])) maxr = i; // 寻找从当前行开始向下走的当前列中的绝对值最大值 if (maxr ^ r) swap(a[r], a[maxr]); // 交换两行 if (abs(a[r][c]) \u003c eps) continue; // 如果为当前行中的当前列的值为0 for (int i = 0; i \u003c n; ++i) { // 约旦消元 if (abs(a[i][c]) \u003c eps || i == r) continue; // 如果是当前行或者改行的当前列已经是0 for (int j = m; j \u003e= c; --j) a[i][j] -= a[i][c] / a[r][c] * a[r][j]; } ++r; } if (r \u003c n) return 0; // 无解或者无穷解 for (int i = 0; i \u003c n; ++i) ans[i] = a[i][n] / a[i][i]; // 回带 return 1; } vector\u003cvector\u003cdouble\u003e\u003e a; int main() { int n; scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; ++i) { a.push_back({}); for (int j = 0; j \u003c= n; ++j) { double x; scanf(\"%lf\", \u0026x); a[i].push_back(x); } } if (gauss_j(n, n, a) == 1) { for (int i = 0; i \u003c n; ++i) printf(\"%.2f\\n\", ans[i]); } else puts(\"No Solution\"); return 0; } 模意义下的高斯消元法，POJ - 2065 SETI // POJ - 2065 SETI #include \u003ccassert\u003e#include \u003cvector\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e using namespace std; int gcd(int a, int b) { int m; while(b) m = a % b, a = b, b = m; return a; } int lcm(int a, int b) { return a / gcd(a, b) * b; } int p, ans[310]; // 记录答案 int powf(int a, int b, const int mod, int ans = 1) { a %= mod; while (b) { if (b \u0026 1) ans = ans * a % mod; b \u003e\u003e= 1, a = a * a % mod; } return ans; } int inv(int a, int m) { return powf(a, m - 2, m); } //模意义下的高斯消元不需要用约旦的方式，因为整数不用考虑精度问题 // n 行 m + 1列的增广矩阵，从0开始 int gauss(int n, int m, vector\u003cvector\u003cint\u003e \u003e \u0026a, const int \u0026p) { // 传入模p int r, c; // 当前行和当前列 for (r = c = 0; c \u003c m \u0026\u0026 r \u003c n; ++c) { int maxr = r; // 记录最大值 for (int i = r + 1; i \u003c n; ++i) if (abs(a[i][c]) \u003e abs(a[maxr][c])) maxr = i; // 寻找当前列中从当前行开始的绝对值的最大值 if (maxr ^ r) swap(a[r], a[maxr]); // 交换两行 if (!a[r][c]) continue; // 如果为0 for (int i = r + 1; i \u003c n; ++i) { if (!a[i][c]) continue; // 如果当前列中 改行已经为0 int LCM = lcm(abs(a[i][c]), abs(a[r][c])); int x = LCM / abs(a[i][c]), y = LCM / abs(a[r][c]); // 使该行乘x，当前行乘y使得他们在当前列的数都变成同一个数 if (a[i][c] * a[r][c] \u003c 0) y = -y; // 如果有一个是负数 for (int j = c; j \u003c= m; ++j) a[i][j] = ((a[i][j] * x - a[r][j] * y) % p + p) % p; } ++r; } for (int i = r; i \u003c n; ++i) if (a[i][c]) return 0; // 无解 if (r \u003c m) return -1; // 无穷解 for (int i = m - 1; ~i; --i) { int tmp = a[i][m]; for (int j = i + 1; j \u003c m; ++j) { if (!a[i][j]) continue; tmp -= ans[j] * a[i][j]; tmp = ((tmp % p) + p) % p; } an","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:7","tags":null,"title":"数论板子","uri":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","数论"],"content":"8. 卢卡斯定理 lucas const ll mod = 10007;// 注意lucas算法，mod必须为质数 ll fac[mod + 10], inv[mod + 10]; void fny(const int \u0026n, ll *inv, const ll mod) { fac[0] = fac[1] = inv[0] = inv[1] = 1; for (ll i = 2; i \u003c= n; i++) { inv[i] =((mod - mod / i) * inv[mod % i]) % mod; fac[i] = fac[i - 1] * i % mod; } } ll comb(ll n, ll m) { if (m \u003e n) return 0; return fac[n] * inv[fac[n - m] * fac[m] % mod] % mod; } ll lucas(ll n, ll m) { // 本函数不考虑comb的时间复杂度的话就是O(logmod) if (m == 0) return 1; if (n \u003c mod) return comb(n, m); return comb(n % mod, m % mod) * lucas(n / mod, m / mod) % mod; } exlucas ll powf(ll a, ll b, const ll mod) {// 返回a^b % mod ll res = 1; for (a %= mod; b; b \u003e\u003e= 1, a = a * a % mod) if (b \u0026 1) res = res * a % mod; return res; } void exgcd(ll a, ll b, ll \u0026g, ll \u0026x, ll \u0026y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } // ax=1(mod m) ll inverse(ll a, ll m) {//扩展欧几里得法求逆元，返回-1代表没有逆元 ll g, x, y; exgcd(a, m, g, x, y); return g == 1 ? (x % m + m) % m : -1; } ll crt(ll *a, ll *b, int n) {// x % b[i] = a[i], 返回最小的x， b[i]中互质， O(nlogn) ll mul = 1, ret = 0; for (int i = 0; i \u003c n; ++i) mul *= b[i]; for (int i = 0; i \u003c n; ++i) { ll minlcm = mul / b[i]; ll inv = inverse(minlcm, b[i]); // 求逆元 ret = (ret + minlcm * inv * a[i]) % mul; } return (ret + mul) % mul; } ll cal(ll n, ll p, ll pk) { // 计算n!中取出所有p因子后mod pk的结果 if (n == 0) return 1; ll res = 1; for (int i = 1; i \u003c pk; ++i) { if (i % p) res = res * i % pk; } res = powf(res, n / pk, pk); int len = n % pk; for (int i = 1; i \u003c= len; ++i) { if (i % p) res = res * i % pk; } return res * cal(n / p, p, pk) % pk; } ll comb(ll n, ll m, ll p, ll pk) {// 计算C(n, m) % pk的结果，其中p^k = pk if (n \u003c m) return 0; ll up = cal(n, p, pk), down = cal(m, p, pk) * cal(n - m, p, pk) % pk, cnt = 0; for (ll i = n; i; i /= p) cnt += i / p; for (ll i = m; i; i /= p) cnt -= i / p; for (ll i = n - m; i; i /= p) cnt -= i / p; return up * inverse(down, pk) % pk * powf(p, cnt, pk) % pk; } //直接调用此函数即可 ll exlucas(ll n, ll m, ll p) { // 计算C(n, m) % p，其中p不为质数 ll b[50], a[50], len = 0, tmp = p; for (ll i = 2; i * i \u003c= tmp; ++i) { if (tmp % i) continue; b[len] = 1; while (tmp % i == 0) b[len] *= i, tmp /= i; a[len] = comb(n, m, i, b[len]); len += 1; } if (tmp \u003e 1) b[len] = tmp, a[len] = comb(n, m, tmp, tmp), len += 1; return crt(a, b, len); } ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:8","tags":null,"title":"数论板子","uri":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","数论"],"content":"9. 线性基 struct LB { using ll = long long; ll d[65], cnt, num; // cnt 原序列的个数， num 基的个数 bool re; LB () : cnt(0), num(0), re(false) { memset(d, 0, sizeof d); } // 添加一个数x void add(ll x) { ++cnt; for (int i = 60; ~i \u0026\u0026 x; --i) { if ((x \u003e\u003e i) \u0026 1) { if (d[i]) x ^= d[i]; else d[i] = x, x = 0, ++num, re = 0; } } } // 询问是否能异或出x bool check(ll x) { for (int i = 60; ~i \u0026\u0026 x; --i) { if ((x \u003e\u003e i) \u0026 1) { if (d[i]) x ^= d[i]; else return true; } } return false; } ll get_max() { ll res = 0; for (int i = 60; ~i; --i) { if ((d[i] ^ res) \u003e res) res ^= d[i]; } return res; } // 求的是线性基的异或最小值，不是原序列，否则要特判是否为0 ll get_min() { for (int i = 0; i \u003c= 60; ++i) { if (d[i]) return d[i]; } } void rebuild() { for (int i = 0; i \u003c= 60; ++i) { for (int j = 0; j \u003c i; ++j) { if ((d[i] \u003e\u003e j) \u0026 1) { d[i] ^= d[j]; } } } re = true; } ll k_th(ll k) { if (!re) rebuild(); if (k == 1 \u0026\u0026 num \u003c cnt) return 0; // 如果异或得到0 if (num \u003c cnt) --k; ll res = 0; for (int i = 0; i \u003c= 60; ++i) { if (d[i]) { if (k \u0026 1) res ^= d[i]; k \u003e\u003e= 1; } } return res; } }; ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:9","tags":null,"title":"数论板子","uri":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","数论"],"content":"10. 中国剩余定理 Crt ll crt(ll *a, ll *b, int n) {// x % b[i] = a[i], 返回最小的x， b[i]中互质， O(nlogn) ll mul = 1, ret = 0; for (int i = 0; i \u003c n; ++i) mul *= b[i]; for (int i = 0; i \u003c n; ++i) { ll minlcm = mul / b[i]; ll inv = inverse(minlcm, b[i]); // 求逆元 ret = (ret + minlcm * inv * a[i]) % mul; } return (ret + mul) % mul; } ExCrt ll mul(ll a, ll b, ll p) { ll res = 0; for (a %= p; b; b \u003e\u003e= 1) { if (b \u0026 1) res = (res + a) % p; a = (a + a) % p; } return res; } void exgcd(ll a, ll b, ll \u0026g, ll \u0026x, ll \u0026y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } ll excrt(ll *a, ll *b, int n) {// x % b[i] = a[i], 返回最小的x ll res = a[0], minlcm = b[0], x, y, g; for (int i = 1; i \u003c n; ++i) { ll c = (a[i] - res % b[i] + b[i]) % b[i]; exgcd(minlcm, b[i], g, x, y); if (c % g != 0) return -1; // 无解 x = mul(x, c / g, b[i] / g);// 快速乘 res += x * minlcm; minlcm *= b[i] / g; res = (res % minlcm + minlcm) % minlcm; } return (res % minlcm + minlcm) % minlcm; } ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:10","tags":null,"title":"数论板子","uri":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","数论"],"content":"11. 欧拉函数 线性复杂度O(n) void getphi() { phi[1] = 1; for (int i = 2; i \u003c M; ++i) { if (!isp[i]) pri[cnt++] = i, phi[i] = i - 1; for (int j = 0; j \u003c cnt \u0026\u0026 i * pri[j] \u003c M; ++j) { isp[i * pri[j]] = 1; if (i % pri[j] == 0) { phi[i * pri[j]] = pri[j] * phi[i]; break; } else { phi[i * pri[j]] = (pri[j] - 1) * phi[i]; } } } } ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:11","tags":null,"title":"数论板子","uri":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板","数论"],"content":"12. 求组合数 递推版，针对取余p为质数（如果有的话），且m较小的情况,O(m) ll comb(ll n, ll m) { if (n \u003c m) return 0; ll ret = 1; for (int i = 1; i \u003c= m; ++i) ret = ret * (n - i + 1) / i; return ret; } 素因子版，针对取余p不为质数，其n较小的情况，O(nlogn) // 计算分子分母的素数个数差来计算结果O(nlogn),需要用到质数表，和快速幂 ll comb(int n, int m, int p) {// 求C(n, m) % p的结果，其中n, m \u003c= 1e6, p \u003c= 1e9 if (n \u003c m) return 0; ll res = 1; for (int i = 0; i \u003c cnt \u0026\u0026 pri[i] \u003c= n; ++i) { int num = 0; for (int j = n; j; j /= pri[i]) num += j / pri[i]; for (int j = m; j; j /= pri[i]) num -= j / pri[i]; for (int j = n - m; j; j /= pri[i]) num -= j / pri[i]; res = res * powf(pri[i], num, p) % p; } return res; } ​ ","date":"2021-07-27","objectID":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/:0:12","tags":null,"title":"数论板子","uri":"/2021/07/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"1. 二分 整数二分 // 1 while (l \u003c r) { int mid = (l + r) \u003e\u003e 1; if (check(mid)) l = mid + 1; else r = mid; } // 2 while (l \u003c r) { int mid = (l + r + 1) \u003e\u003e 1; if (check(mid)) l = mid; else r = mid - 1; } // 常用 while (l \u003c= r) { int mid = (l + r) \u003e\u003e 1; if (check(mid)) ans = mid, l = mid + 1; else r = mid - 1; } 浮点数二分 // 通用版 while (r - l \u003e 1e-5) { double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; } // 防卡精度 for (int i = 0; i \u003c 100; ++i) { double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; } ","date":"2021-07-27","objectID":"/2021/07/%E5%9F%BA%E7%A1%80%E6%9D%BF%E5%AD%90/:0:1","tags":null,"title":"基础板子","uri":"/2021/07/%E5%9F%BA%E7%A1%80%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"2. 离散化 template\u003cclass T\u003e struct discrete { vector\u003cT\u003e v; int init() { // 离散化，返回离散化后的个数 sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); return v.size(); } int size() { return v.size(); } void add(const T x) { v.push_back(x); } int operator[] (const T x) {// 查找一个值离散化后的值 return lower_bound(v.begin(), v.end(), x) - v.begin() + 1; } T kth(int k) { return v[k - 1]; } // 查找排第k的是多少，查找范围[1, n] }; ","date":"2021-07-27","objectID":"/2021/07/%E5%9F%BA%E7%A1%80%E6%9D%BF%E5%AD%90/:0:2","tags":null,"title":"基础板子","uri":"/2021/07/%E5%9F%BA%E7%A1%80%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"3. 高精 复杂版 #include \u003ccstdio\u003e#include \u003ccctype\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cstring\u003e#include \u003ciostream\u003e using namespace std; typedef long long ll; /* 用前必读： 本高精采用可调压位式运算对于不同需求记得更改下面的压位代码 注意笔者只封装了 bign * int 没有封装 int * bign , 用时注意顺序 若出现 bign * x,中 x 不是常量变量或者不是变量（例如具体数字 3 4 5……） 记得把封装的与int相关的 运算符重载函数 的const和取地址符\u0026去掉，防止报错 若是爆栈请尝试开全局变量或者把数组改小即 M 改小 本代码暂时只支持 高精 + 高精 高精1 - 高精2 （高精1 \u003e 高精2） 高精 * 低精 高精 / 低精 高精 * 高精 高精 % 低精 高精 与 高精 的大小对比 高精 += 高精 高精1 -= 高精2 （高精1 \u003e 高精2） 高精 *= 低精 高精 /= 低精 高精 *= 高精 高精 %= 低精 尚未完成的功能 高精 / 高精 高精 % 高精 高精1 - 高精2 （高精1 \u003c 高精2） …… 其余请读者自己体会 */ const int w = 1e8, M = 1e4, wsize = 8;//压位8个0 const char pout[] = \"%08lld\";//记得修改 struct bign{ ll num[M]; char str[M * wsize]; int len; void clear() { memset(num, 0, sizeof num); len = 0;} /* 初始化 */ bign() : len(0) { clear(); } bign(int n); bign(ll n); bign(char str[]); bign(string str); void change(); void operator= (const int x) { *this = bign(x); } void operator= (const ll x) { *this = bign(x); } void operator= (char x[]) { *this = bign(x); } void operator= (string x) { *this = bign(x); } ll \u0026operator[] (int x) { return num[x]; } /* 输出 */ void print(); void print() const; /* 比较(未验证) */ bool operator\u003c (const bign \u0026b) const; bool operator\u003e (const bign \u0026b) const { return b \u003c *this; } bool operator\u003c= (const bign \u0026b) const { return !(b \u003c *this); } bool operator\u003e= (const bign \u0026b) const { return !(*this \u003c b); } bool operator!= (const bign \u0026b) const { return b \u003c *this || *this \u003c b; } bool operator== (const bign \u0026b) const { return !(b \u003c *this) \u0026\u0026 !(*this \u003c b); } /* 各种运算 */ bign operator+ (const bign \u0026b) const; // 高精 + 高精 bign operator* (const int \u0026b) const; // 高精 * 低精 bign operator* (const bign \u0026b); // 高精 * 高精 bign operator- (const bign \u0026b) const; // 高精 - 高精 bign operator/ (const int \u0026b) const; // 高精 / 低精 bign operator% (const int \u0026b); // 高精 % 低精 void operator+= (const bign \u0026b); // 高精 += 高精 void operator*= (const int \u0026b); // 高精 *= 低精 void operator*= (const bign \u0026b); // 高精 *= 高精 void operator-= (const bign \u0026b); // 高精 -= 高精 void operator/= (const int \u0026b); // 高精 /= 低精 void operator%= (const int \u0026b); // 高精 %= 低精 /* 输入输出重载 */ friend istream\u0026 operator\u003e\u003e (istream \u0026in, bign \u0026res) ; friend ostream\u0026 operator\u003c\u003c (ostream \u0026out, const bign \u0026res) ; }; bign::bign(int n) : len(0) { clear(); while (1) { num[++len] = n % w, n /= w; if (!n) break; } } bign::bign(ll n) : len(0) { clear(); while (1) { num[++len] = n % w, n /= w; if (!n) break; } } bign::bign(char str[]) : len(0) { clear(); int l = strlen(str) - 1; for (int i = l; i \u003e= 0; i -= wsize) { ll tmp = 0, k = 1; for (int j = 0; j \u003c wsize \u0026\u0026 i - j \u003e= 0; j++, k *= 10) { tmp += (str[i - j] - '0') * k; } num[++len] = tmp; } } bign::bign(string str) : len(0) { clear(); int l = str.size() - 1; for (int i = l; i \u003e= 0; i -= wsize) { ll tmp = 0, k = 1; for (int j = 0; j \u003c wsize \u0026\u0026 i - j \u003e= 0; j++, k *= 10) { tmp += (str[i - j] - '0') * k; } num[++len] = tmp; } } void bign::change() { int l = strlen(str) - 1; len = 0; for (int i = l; i \u003e= 0; i -= wsize) { ll tmp = 0, k = 1; for (int j = 0; j \u003c wsize \u0026\u0026 i - j \u003e= 0; j++, k *= 10) { tmp += (str[i - j] - '0') * k; } num[++len] = tmp; } } /* 输出 */ void bign::print() { printf(\"%lld\", num[len]); for (int i = len - 1; i \u003e 0; i--) printf(pout, num[i]); puts(\"\"); } void bign::print() const { printf(\"%lld\", num[len]); for (int i = len - 1; i \u003e 0; i--) printf(pout, num[i]); // puts(\"\"); } /* 比较(未验证) */ bool bign::operator\u003c (const bign \u0026b) const { if (len != b.len) return len \u003c b.len; for (int i = len; i \u003e 0; i--) { if (num[i] != b.num[i]) return num[i] \u003c b.num[i]; } return false; } /************************常用****************************/ /* 各种运算 */ bign bign::operator+ (const bign \u0026b) const { bign res = *this; if (res.len \u003c b.len) res.len = b.len; for (int i = 1; i \u003c= res.len; i++) { res.num[i] += b.num[i]; res.num[i + 1] += res.num[i] / w; res.num[i] %= w; } while (res.num[res.len + 1]) res.len++; return res; } bign bign::operator* (const int \u0026b) const { bign res; ll carry = 0; for (int i = 1; i \u003c= len;","date":"2021-07-27","objectID":"/2021/07/%E5%9F%BA%E7%A1%80%E6%9D%BF%E5%AD%90/:0:3","tags":null,"title":"基础板子","uri":"/2021/07/%E5%9F%BA%E7%A1%80%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"4. 差分 const int M = 1e5 + 10; int dif[M], arr[M], res[M]; void change(int l, int r, int v) { // [l, r] + v dif[l] += v, dif[r + 1] -= v; } void init(int n) { dif[1] = arr[1]; for (int i = 2; i \u003c= n; ++i) dif[i] = arr[i] - arr[i - 1]; } void get_res(int n) { res[1] = dif[1]; for (int i = 2; i \u003c= n; ++i) { res[i] = dif[i] + res[i - 1]; } } ","date":"2021-07-27","objectID":"/2021/07/%E5%9F%BA%E7%A1%80%E6%9D%BF%E5%AD%90/:0:4","tags":null,"title":"基础板子","uri":"/2021/07/%E5%9F%BA%E7%A1%80%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"5.三分 double ts(int l, int r) { double ans1 = 0x3f3f3f3f, ans2 = 0x3f3f3f3f; while (l \u003c r) { int lmid = l + (r - l) / 3; int rmid = r - (r - l) / 3; ans1 = f(lmid), ans2 = f(rmid); if (ans1 \u003c= ans2) r = rmid - 1; // 凹函数的最小值， 凸函数\u003c=反过来 else l = lmid + 1; } return min(ans1, ans2); //凸函数这里记得改成max } ","date":"2021-07-27","objectID":"/2021/07/%E5%9F%BA%E7%A1%80%E6%9D%BF%E5%AD%90/:0:5","tags":null,"title":"基础板子","uri":"/2021/07/%E5%9F%BA%E7%A1%80%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"6. cout控制宽度和精度 #include \u003ciomanip\u003e// setw()只对其后面紧跟的输出产生作用 cout \u003c\u003c setw(8) \u003c\u003c setfill('0') \u003c\u003c 123 \u003c\u003c endl; // 00000123 cout.precision(3); // 之后的输出都置保留3位有效数字 cout.setf(ios::fixed); // 固定小数点，即之后的都保留3位小数 cout.unsetf(ios::fixed); // 取消固定小数点 ","date":"2021-07-27","objectID":"/2021/07/%E5%9F%BA%E7%A1%80%E6%9D%BF%E5%AD%90/:0:6","tags":null,"title":"基础板子","uri":"/2021/07/%E5%9F%BA%E7%A1%80%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"7. 快读快输 inline char getc() {// 重写getchar static char buf[1 \u003c\u003c 21], *p1 = buf, *p2 = buf; return p1 == p2 \u0026\u0026 (p2 = (p1 = buf) + fread(buf, 1, 1 \u003c\u003c 21, stdin), p1 == p2) ? EOF : *p1++; } inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } //if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } void getstr(string \u0026s) { // 字符串快读 int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); //if (c == -1) exit(0); s.clear(); for(;c \u003e 32; c = getchar()) s.push_back(c); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } ","date":"2021-07-27","objectID":"/2021/07/%E5%9F%BA%E7%A1%80%E6%9D%BF%E5%AD%90/:0:7","tags":null,"title":"基础板子","uri":"/2021/07/%E5%9F%BA%E7%A1%80%E6%9D%BF%E5%AD%90/"},{"categories":["总结","模板"],"content":"常用模板（包括网络赛） ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:0:0","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"一、基础板子 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:1:0","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"1. 二分 整数二分 // 1 while (l \u003c r) { int mid = (l + r) \u003e\u003e 1; if (check(mid)) l = mid + 1; else r = mid; } // 2 while (l \u003c r) { int mid = (l + r + 1) \u003e\u003e 1; if (check(mid)) l = mid; else r = mid - 1; } // 常用 while (l \u003c= r) { int mid = (l + r) \u003e\u003e 1; if (check(mid)) ans = mid, l = mid + 1; else r = mid - 1; } 浮点数二分 // 通用版 while (r - l \u003e 1e-5) { double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; } // 防卡精度 for (int i = 0; i \u003c 100; ++i) { double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:1:1","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"2. 离散化 template\u003cclass T\u003e struct discrete { vector\u003cT\u003e v; int init() { // 离散化，返回离散化后的个数 sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); return v.size(); } int size() { return v.size(); } void add(const T x) { v.push_back(x); } int operator[] (const T x) {// 查找一个值离散化后的值 return lower_bound(v.begin(), v.end(), x) - v.begin() + 1; } T kth(int k) { return v[k - 1]; } // 查找排第k的是多少，查找范围[1, n] }; ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:1:2","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"3. 高精 复杂版 #include \u003ccstdio\u003e#include \u003ccctype\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cstring\u003e#include \u003ciostream\u003e using namespace std; typedef long long ll; /* 用前必读： 本高精采用可调压位式运算对于不同需求记得更改下面的压位代码 注意笔者只封装了 bign * int 没有封装 int * bign , 用时注意顺序 若出现 bign * x,中 x 不是常量变量或者不是变量（例如具体数字 3 4 5……） 记得把封装的与int相关的 运算符重载函数 的const和取地址符\u0026去掉，防止报错 若是爆栈请尝试开全局变量或者把数组改小即 M 改小 本代码暂时只支持 高精 + 高精 高精1 - 高精2 （高精1 \u003e 高精2） 高精 * 低精 高精 / 低精 高精 * 高精 高精 % 低精 高精 与 高精 的大小对比 高精 += 高精 高精1 -= 高精2 （高精1 \u003e 高精2） 高精 *= 低精 高精 /= 低精 高精 *= 高精 高精 %= 低精 尚未完成的功能 高精 / 高精 高精 % 高精 高精1 - 高精2 （高精1 \u003c 高精2） …… 其余请读者自己体会 */ const int w = 1e8, M = 1e4, wsize = 8;//压位8个0 const char pout[] = \"%08lld\";//记得修改 struct bign{ ll num[M]; char str[M * wsize]; int len; void clear() { memset(num, 0, sizeof num); len = 0;} /* 初始化 */ bign() : len(0) { clear(); } bign(int n); bign(ll n); bign(char str[]); bign(string str); void change(); void operator= (const int x) { *this = bign(x); } void operator= (const ll x) { *this = bign(x); } void operator= (char x[]) { *this = bign(x); } void operator= (string x) { *this = bign(x); } ll \u0026operator[] (int x) { return num[x]; } /* 输出 */ void print(); void print() const; /* 比较(未验证) */ bool operator\u003c (const bign \u0026b) const; bool operator\u003e (const bign \u0026b) const { return b \u003c *this; } bool operator\u003c= (const bign \u0026b) const { return !(b \u003c *this); } bool operator\u003e= (const bign \u0026b) const { return !(*this \u003c b); } bool operator!= (const bign \u0026b) const { return b \u003c *this || *this \u003c b; } bool operator== (const bign \u0026b) const { return !(b \u003c *this) \u0026\u0026 !(*this \u003c b); } /* 各种运算 */ bign operator+ (const bign \u0026b) const; // 高精 + 高精 bign operator* (const int \u0026b) const; // 高精 * 低精 bign operator* (const bign \u0026b); // 高精 * 高精 bign operator- (const bign \u0026b) const; // 高精 - 高精 bign operator/ (const int \u0026b) const; // 高精 / 低精 bign operator% (const int \u0026b); // 高精 % 低精 void operator+= (const bign \u0026b); // 高精 += 高精 void operator*= (const int \u0026b); // 高精 *= 低精 void operator*= (const bign \u0026b); // 高精 *= 高精 void operator-= (const bign \u0026b); // 高精 -= 高精 void operator/= (const int \u0026b); // 高精 /= 低精 void operator%= (const int \u0026b); // 高精 %= 低精 /* 输入输出重载 */ friend istream\u0026 operator\u003e\u003e (istream \u0026in, bign \u0026res) ; friend ostream\u0026 operator\u003c\u003c (ostream \u0026out, const bign \u0026res) ; }; bign::bign(int n) : len(0) { clear(); while (1) { num[++len] = n % w, n /= w; if (!n) break; } } bign::bign(ll n) : len(0) { clear(); while (1) { num[++len] = n % w, n /= w; if (!n) break; } } bign::bign(char str[]) : len(0) { clear(); int l = strlen(str) - 1; for (int i = l; i \u003e= 0; i -= wsize) { ll tmp = 0, k = 1; for (int j = 0; j \u003c wsize \u0026\u0026 i - j \u003e= 0; j++, k *= 10) { tmp += (str[i - j] - '0') * k; } num[++len] = tmp; } } bign::bign(string str) : len(0) { clear(); int l = str.size() - 1; for (int i = l; i \u003e= 0; i -= wsize) { ll tmp = 0, k = 1; for (int j = 0; j \u003c wsize \u0026\u0026 i - j \u003e= 0; j++, k *= 10) { tmp += (str[i - j] - '0') * k; } num[++len] = tmp; } } void bign::change() { int l = strlen(str) - 1; len = 0; for (int i = l; i \u003e= 0; i -= wsize) { ll tmp = 0, k = 1; for (int j = 0; j \u003c wsize \u0026\u0026 i - j \u003e= 0; j++, k *= 10) { tmp += (str[i - j] - '0') * k; } num[++len] = tmp; } } /* 输出 */ void bign::print() { printf(\"%lld\", num[len]); for (int i = len - 1; i \u003e 0; i--) printf(pout, num[i]); puts(\"\"); } void bign::print() const { printf(\"%lld\", num[len]); for (int i = len - 1; i \u003e 0; i--) printf(pout, num[i]); // puts(\"\"); } /* 比较(未验证) */ bool bign::operator\u003c (const bign \u0026b) const { if (len != b.len) return len \u003c b.len; for (int i = len; i \u003e 0; i--) { if (num[i] != b.num[i]) return num[i] \u003c b.num[i]; } return false; } /************************常用****************************/ /* 各种运算 */ bign bign::operator+ (const bign \u0026b) const { bign res = *this; if (res.len \u003c b.len) res.len = b.len; for (int i = 1; i \u003c= res.len; i++) { res.num[i] += b.num[i]; res.num[i + 1] += res.num[i] / w; res.num[i] %= w; } while (res.num[res.len + 1]) res.len++; return res; } bign bign::operator* (const int \u0026b) const { bign res; ll carry = 0; for (int i = 1; i \u003c= len;","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:1:3","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"4. 差分 const int M = 1e5 + 10; int dif[M], arr[M], res[M]; void change(int l, int r, int v) { // [l, r] + v dif[l] += v, dif[r + 1] -= v; } void init(int n) { dif[1] = arr[1]; for (int i = 2; i \u003c= n; ++i) dif[i] = arr[i] - arr[i - 1]; } void get_res(int n) { res[1] = dif[1]; for (int i = 2; i \u003c= n; ++i) { res[i] = dif[i] + res[i - 1]; } } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:1:4","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"5.三分 double ts(int l, int r) { double ans1 = 0x3f3f3f3f, ans2 = 0x3f3f3f3f; while (l \u003c r) { int lmid = l + (r - l) / 3; int rmid = r - (r - l) / 3; ans1 = f(lmid), ans2 = f(rmid); if (ans1 \u003c= ans2) r = rmid - 1; // 凹函数的最小值， 凸函数\u003c=反过来 else l = lmid + 1; } return min(ans1, ans2); //凸函数这里记得改成max } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:1:5","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"6. cout控制宽度和精度 #include \u003ciomanip\u003e// setw()只对其后面紧跟的输出产生作用 cout \u003c\u003c setw(8) \u003c\u003c setfill('0') \u003c\u003c 123 \u003c\u003c endl; // 00000123 cout.precision(3); // 之后的输出都置保留3位有效数字 cout.setf(ios::fixed); // 固定小数点，即之后的都保留3位小数 cout.unsetf(ios::fixed); // 取消固定小数点 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:1:6","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"7. 快读快输 inline char getc() {// 重写getchar static char buf[1 \u003c\u003c 21], *p1 = buf, *p2 = buf; return p1 == p2 \u0026\u0026 (p2 = (p1 = buf) + fread(buf, 1, 1 \u003c\u003c 21, stdin), p1 == p2) ? EOF : *p1++; } inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026\u0026 c != -1; c = getchar()) { if (c == '-') f = 1; } //if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c ^ '0'); } return f ? -x : x; } void getstr(string \u0026s) { // 字符串快读 int c = getchar(); while (c \u003c 33 \u0026\u0026 c != -1) c = getchar(); //if (c == -1) exit(0); for(;c \u003e 32; c = getchar()) s.push_back(c); } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } void print(const string\u0026 s) { for (char c : s) putchar(c); } template \u003ctypename T\u003e void print(T x, char c) { print(x); putchar(c); } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:1:7","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"二、数论 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:0","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"1. gcd与lcm typedef long long ll; //最大公因数，公约数 ll gcd(ll a, ll b, ll m = 1) { while(b) m = a % b, a = b, b = m; return a; } //最小公倍数 ll lcm(ll a, ll b) { return a / gcd(a, b) * b; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:1","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"2. ex_gcd /* 通解为 x' = x * c / gcd + (b / gcd) * k y' = y * c / gcd - (a / gcd) * k */ typedef long long ll; // 扩展欧几里得算法核心函数 void exgcd(ll a, ll b, ll \u0026g, ll \u0026x, ll \u0026y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } /** * 此函数为 求解 ax + by = c * 返回 x的最小正整数解 * 返回 -1 说明无解 */ ll minx(ll a, ll b, ll c) { ll x, y, g; exgcd(a, b, g, x, y); if (c % g != 0) return -1; ll t = abs(b / g); x = (x * c / g % t + t) % t; return x == 0 ? x + t : x; // 返回最小正整数解 } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:2","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"3. 素数筛 埃式筛 const int M = 1e5 + 5; int pri[M], cnt = 0; bool isp[M]; // 复杂度O(nloglogn) // true 为非素数， false 为素数 void table() { isp[0] = isp[1] = true; for (int i = 2; i \u003c M; i++) { if (isp[i]) continue; pri[cnt++] = i; for (int j = i + i; j \u003c M; j += i) isp[j] = true; } } 线性筛 // 复杂度O(n) const int M = 1e5 + 10; int cnt = 0; bool isp[M]; // true 为非素数， false 为素数 vector\u003cint\u003e pri; void table(int n = 1e5) { isp[0] = isp[1] = 1; for (int i = 2; i \u003c= n; ++i) { if (!isp[i]) pri.push_back(i); for (int x : pri) { if (x * i \u003e n) break; isp[x * i] = 1; if (i % x == 0) break; } } } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:3","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"4. 逆元 线性法 typedef long long ll; // 时间复杂度O(n) void fny(const int \u0026n, ll *inv, const ll mod) { inv[0] = inv[1] = 1; for (ll i = 2; i \u003c= n; i++) { inv[i] =((mod - mod / i) * inv[mod % i]) % mod; } } 扩欧法 typedef long long ll; void exgcd(ll a, ll b, ll \u0026g, ll \u0026x, ll \u0026y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } // ax=1(mod m) ll inverse(ll a, ll m) {//扩展欧几里得法求逆元，返回-1代表没有逆元 ll g, x, y; exgcd(a, m, g, x, y); return g == 1 ? (x % m + m) % m : -1; } 费马小定理法 //a ^ (p - 1) = 1 (mod p), p为素数 //a ^ (p - 2) = a ^ (-1) (mod p) //a 的逆元为 a ^ (p - 2) typedef long long ll; ll pow_f(ll a, ll b, const ll mo) { ll ans = 1; a %= mo; while (b) { if (b \u0026 1) ans = (ans * a) % mo; a = (a * a) % mo; b \u003e\u003e= 1; } return ans; } ll inverse(ll a, ll m) { return pow_f(a, m - 2, m); } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:4","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"5. 快速幂 #define ll long long ll powf(ll a, ll b, const ll mod) {// 返回a^b % mod ll res = 1; for (a %= mod; b; b \u003e\u003e= 1, a = a * a % mod) if (b \u0026 1) res = res * a % mod; return res; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:5","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"6. 矩阵快速幂 结构体版 const ll MOD = 1e9 + 7; #define MO(x) ((x) % MOD) struct Mat { ll mat[10][10]; int n; // n * n 阶矩阵 Mat(int n = 2) : n(n) { memset(mat, 0, sizeof mat); }//记得修改 void to_one() { for (int i = 0; i \u003c n; i++) mat[i][i] = 1; } Mat operator*(const Mat a) const { Mat res; for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j++) { ll sum = 0; for (int k = 0; k \u003c n; k++) { sum += MO(this-\u003emat[i][k] * a.mat[k][j]); } res.mat[i][j] = MO(sum); } } return res; } ll *operator[](int x) { return mat[x]; } }; Mat pow_f(Mat a, ll b) { //a ^ b次幂 Mat ans; ans.to_one(); while (b) { if (b \u0026 1) ans = ans * a; a = a * a; b \u003e\u003e= 1; } return ans; } vector 重载运算符版 #define ll long long #define vi vector\u003cll\u003e #define Mat vector\u003cvi\u003e const int X = 6; const ll mod = 1e9 + 7; Mat operator* (Mat a, Mat b) { Mat res(X, vi(X, 0)); for (int i = 0; i \u003c X; ++i) for (int j = 0; j \u003c X; ++j) for (int k = 0; k \u003c X; ++k) res[i][j] = (res[i][j] + a[i][k] * b[k][j] % mod) % mod; return res; } Mat operator^ (Mat a, long long b) { Mat res(X, vi(X, 0)); for (int i = 0; i \u003c X; ++i) res[i][i] = 1; while (b) { if (b \u0026 1) res = res * a; a = a * a, b \u003e\u003e= 1; } return res; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:6","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"7. 高斯消元 普通浮点数高斯消元，洛谷模板题 // 洛谷模板题 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003cvector\u003e using namespace std; const int N = 110; const double eps = 1e-6; // 用来控制进度 // 普通的高斯消元是将矩阵转化成上三角的形式，再回带求出答案 double ans[N]; // 用来记录答案 int gauss(int n, int m, vector\u003cvector\u003cdouble\u003e\u003e \u0026a) { // n行m + 1列的增广矩阵 int r, c; // 当前行和当前列 for (r = c = 0; c \u003c m \u0026\u0026 r \u003c n; ++ c) { int maxr = r; // 记录最大 for (int i = r + 1; i \u003c n; ++i) if (abs(a[i][c]) \u003e abs(a[maxr][c])) maxr = i; // 寻找从当前行开始向下走的当前列中的绝对值最大值 if (r ^ maxr) swap(a[r], a[maxr]); // 如果不是当前行，则交换两行 if (abs(a[r][c]) \u003c eps) continue; // 如果当前行当前列的最大值为0则不作消元 for (int i = m; i \u003e= c; --i) a[r][i] /= a[r][c]; // 将当前行的从当前列开始到最后一列 for (int i = r + 1; i \u003c n; ++i) { if (abs(a[i][c]) \u003c eps) continue; // 如果改行的当前列已经是0，则不作消元 for (int j = m; j \u003e= c; --j) { // 逆向消元，可以少开一个变量 a[i][j] -= a[r][j] * a[i][c]; } } ++r; } if (r \u003c n) { // 无穷解 或者 无解 for (int i = r; i \u003c n; ++r) if (abs(a[i][n]) \u003c eps) return 0; return -1; // 无穷解 } for (int i = n - 1; ~i; --i) { // 回带 for (int j = i + 1; j \u003c n; ++j) { a[i][n] -= a[i][j] * ans[j]; } ans[i] = a[i][n]; } return 1; // 唯一解 } vector\u003cvector\u003cdouble\u003e\u003e a; int main() { int n; scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; ++i) { a.push_back({}); for (int j = 0; j \u003c= n; ++j) { double x; scanf(\"%lf\", \u0026x); a[i].push_back(x); } } if (gauss(n, n, a) == 1) { for (int i = 0; i \u003c n; ++i) printf(\"%.2f\\n\", ans[i]); } else puts(\"No Solution\"); return 0; } 浮点数高斯约旦消元法， 洛谷模板题 // 洛谷模板题 #include \u003ccstdio\u003e#include \u003ccmath\u003e#include \u003cvector\u003e using namespace std; const double eps = 1e-6; double ans[110]; // 记录答案 int gauss_j(int n, int m, vector\u003cvector\u003cdouble\u003e\u003e \u0026a) { // n行m + 1列增广矩阵 int r, c; // 当前行当前列 for (r = c = 0; c \u003c m \u0026\u0026 r \u003c n; ++c) { // int maxr = r; // 记录最大值 for (int i = r + 1; i \u003c n; ++i) if (abs(a[i][c]) \u003e abs(a[maxr][c])) maxr = i; // 寻找从当前行开始向下走的当前列中的绝对值最大值 if (maxr ^ r) swap(a[r], a[maxr]); // 交换两行 if (abs(a[r][c]) \u003c eps) continue; // 如果为当前行中的当前列的值为0 for (int i = 0; i \u003c n; ++i) { // 约旦消元 if (abs(a[i][c]) \u003c eps || i == r) continue; // 如果是当前行或者改行的当前列已经是0 for (int j = m; j \u003e= c; --j) a[i][j] -= a[i][c] / a[r][c] * a[r][j]; } ++r; } if (r \u003c n) return 0; // 无解或者无穷解 for (int i = 0; i \u003c n; ++i) ans[i] = a[i][n] / a[i][i]; // 回带 return 1; } vector\u003cvector\u003cdouble\u003e\u003e a; int main() { int n; scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; ++i) { a.push_back({}); for (int j = 0; j \u003c= n; ++j) { double x; scanf(\"%lf\", \u0026x); a[i].push_back(x); } } if (gauss_j(n, n, a) == 1) { for (int i = 0; i \u003c n; ++i) printf(\"%.2f\\n\", ans[i]); } else puts(\"No Solution\"); return 0; } 模意义下的高斯消元法，POJ - 2065 SETI // POJ - 2065 SETI #include \u003ccassert\u003e#include \u003cvector\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e using namespace std; int gcd(int a, int b) { int m; while(b) m = a % b, a = b, b = m; return a; } int lcm(int a, int b) { return a / gcd(a, b) * b; } int p, ans[310]; // 记录答案 int powf(int a, int b, const int mod, int ans = 1) { a %= mod; while (b) { if (b \u0026 1) ans = ans * a % mod; b \u003e\u003e= 1, a = a * a % mod; } return ans; } int inv(int a, int m) { return powf(a, m - 2, m); } //模意义下的高斯消元不需要用约旦的方式，因为整数不用考虑精度问题 // n 行 m + 1列的增广矩阵，从0开始 int gauss(int n, int m, vector\u003cvector\u003cint\u003e \u003e \u0026a, const int \u0026p) { // 传入模p int r, c; // 当前行和当前列 for (r = c = 0; c \u003c m \u0026\u0026 r \u003c n; ++c) { int maxr = r; // 记录最大值 for (int i = r + 1; i \u003c n; ++i) if (abs(a[i][c]) \u003e abs(a[maxr][c])) maxr = i; // 寻找当前列中从当前行开始的绝对值的最大值 if (maxr ^ r) swap(a[r], a[maxr]); // 交换两行 if (!a[r][c]) continue; // 如果为0 for (int i = r + 1; i \u003c n; ++i) { if (!a[i][c]) continue; // 如果当前列中 改行已经为0 int LCM = lcm(abs(a[i][c]), abs(a[r][c])); int x = LCM / abs(a[i][c]), y = LCM / abs(a[r][c]); // 使该行乘x，当前行乘y使得他们在当前列的数都变成同一个数 if (a[i][c] * a[r][c] \u003c 0) y = -y; // 如果有一个是负数 for (int j = c; j \u003c= m; ++j) a[i][j] = ((a[i][j] * x - a[r][j] * y) % p + p) % p; } ++r; } for (int i = r; i \u003c n; ++i) if (a[i][c]) return 0; // 无解 if (r \u003c m) return -1; // 无穷解 for (int i = m - 1; ~i; --i) { int tmp = a[i][m]; for (int j = i + 1; j \u003c m; ++j) { if (!a[i][j]) continue; tmp -= ans[j] * a[i][j]; tmp = ((tmp % p) + p) % p; } an","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:7","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"8. 卢卡斯定理 lucas const ll mod = 10007;// 注意lucas算法，mod必须为质数 ll fac[mod + 10], inv[mod + 10]; void fny(const int \u0026n, ll *inv, const ll mod) { fac[0] = fac[1] = inv[0] = inv[1] = 1; for (ll i = 2; i \u003c= n; i++) { inv[i] =((mod - mod / i) * inv[mod % i]) % mod; fac[i] = fac[i - 1] * i % mod; } } ll comb(ll n, ll m) { if (m \u003e n) return 0; return fac[n] * inv[fac[n - m] * fac[m] % mod] % mod; } ll lucas(ll n, ll m) { // 本函数不考虑comb的时间复杂度的话就是O(logmod) if (m == 0) return 1; if (n \u003c mod) return comb(n, m); return comb(n % mod, m % mod) * lucas(n / mod, m / mod) % mod; } exlucas ll powf(ll a, ll b, const ll mod) {// 返回a^b % mod ll res = 1; for (a %= mod; b; b \u003e\u003e= 1, a = a * a % mod) if (b \u0026 1) res = res * a % mod; return res; } void exgcd(ll a, ll b, ll \u0026g, ll \u0026x, ll \u0026y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } // ax=1(mod m) ll inverse(ll a, ll m) {//扩展欧几里得法求逆元，返回-1代表没有逆元 ll g, x, y; exgcd(a, m, g, x, y); return g == 1 ? (x % m + m) % m : -1; } ll crt(ll *a, ll *b, int n) {// x % b[i] = a[i], 返回最小的x， b[i]中互质， O(nlogn) ll mul = 1, ret = 0; for (int i = 0; i \u003c n; ++i) mul *= b[i]; for (int i = 0; i \u003c n; ++i) { ll minlcm = mul / b[i]; ll inv = inverse(minlcm, b[i]); // 求逆元 ret = (ret + minlcm * inv * a[i]) % mul; } return (ret + mul) % mul; } ll cal(ll n, ll p, ll pk) { // 计算n!中取出所有p因子后mod pk的结果 if (n == 0) return 1; ll res = 1; for (int i = 1; i \u003c pk; ++i) { if (i % p) res = res * i % pk; } res = powf(res, n / pk, pk); int len = n % pk; for (int i = 1; i \u003c= len; ++i) { if (i % p) res = res * i % pk; } return res * cal(n / p, p, pk) % pk; } ll comb(ll n, ll m, ll p, ll pk) {// 计算C(n, m) % pk的结果，其中p^k = pk if (n \u003c m) return 0; ll up = cal(n, p, pk), down = cal(m, p, pk) * cal(n - m, p, pk) % pk, cnt = 0; for (ll i = n; i; i /= p) cnt += i / p; for (ll i = m; i; i /= p) cnt -= i / p; for (ll i = n - m; i; i /= p) cnt -= i / p; return up * inverse(down, pk) % pk * powf(p, cnt, pk) % pk; } //直接调用此函数即可,时间复杂度应该是O(p + logn*logp), 因此此时n和m可以很大 ll exlucas(ll n, ll m, ll p) { // 计算C(n, m) % p，其中p不为质数 ll b[50], a[50], len = 0, tmp = p; for (ll i = 2; i * i \u003c= tmp; ++i) { if (tmp % i) continue; b[len] = 1; while (tmp % i == 0) b[len] *= i, tmp /= i; a[len] = comb(n, m, i, b[len]); len += 1; } if (tmp \u003e 1) b[len] = tmp, a[len] = comb(n, m, tmp, tmp), len += 1; return crt(a, b, len); } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:8","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"9. 线性基 struct LB { using ll = long long; ll d[65], cnt, num; // cnt 原序列的个数， num 基的个数 bool re; LB () : cnt(0), num(0), re(false) { memset(d, 0, sizeof d); } // 添加一个数x void add(ll x) { ++cnt; for (int i = 60; ~i \u0026\u0026 x; --i) { if ((x \u003e\u003e i) \u0026 1) { if (d[i]) x ^= d[i]; else d[i] = x, x = 0, ++num, re = 0; } } } // 询问是否能异或出x bool check(ll x) { for (int i = 60; ~i \u0026\u0026 x; --i) { if ((x \u003e\u003e i) \u0026 1) { if (d[i]) x ^= d[i]; else return true; } } return false; } ll get_max() { ll res = 0; for (int i = 60; ~i; --i) { if ((d[i] ^ res) \u003e res) res ^= d[i]; } return res; } // 求的是线性基的异或最小值，不是原序列，否则要特判是否为0 ll get_min() { for (int i = 0; i \u003c= 60; ++i) { if (d[i]) return d[i]; } } void rebuild() { for (int i = 0; i \u003c= 60; ++i) { for (int j = 0; j \u003c i; ++j) { if ((d[i] \u003e\u003e j) \u0026 1) { d[i] ^= d[j]; } } } re = true; } ll k_th(ll k) { if (!re) rebuild(); if (k == 1 \u0026\u0026 num \u003c cnt) return 0; // 如果异或得到0 if (num \u003c cnt) --k; ll res = 0; for (int i = 0; i \u003c= 60; ++i) { if (d[i]) { if (k \u0026 1) res ^= d[i]; k \u003e\u003e= 1; } } return res; } }; ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:9","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"10. 中国剩余定理 Crt ll crt(ll *a, ll *b, int n) {// x % b[i] = a[i], 返回最小的x， b[i]中互质， O(nlogn) ll mul = 1, ret = 0; for (int i = 0; i \u003c n; ++i) mul *= b[i]; for (int i = 0; i \u003c n; ++i) { ll minlcm = mul / b[i]; ll inv = inverse(minlcm, b[i]); // 求逆元 ret = (ret + minlcm * inv * a[i]) % mul; } return (ret + mul) % mul; } ExCrt ll mul(ll a, ll b, ll p) { ll res = 0; for (a %= p; b; b \u003e\u003e= 1) { if (b \u0026 1) res = (res + a) % p; a = (a + a) % p; } return res; } void exgcd(ll a, ll b, ll \u0026g, ll \u0026x, ll \u0026y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } ll excrt(ll *a, ll *b, int n) {// x % b[i] = a[i], 返回最小的x ll res = a[0], minlcm = b[0], x, y, g; for (int i = 1; i \u003c n; ++i) { ll c = (a[i] - res % b[i] + b[i]) % b[i]; exgcd(minlcm, b[i], g, x, y); if (c % g != 0) return -1; // 无解 x = mul(x, c / g, b[i] / g);// 快速乘 res += x * minlcm; minlcm *= b[i] / g; res = (res % minlcm + minlcm) % minlcm; } return (res % minlcm + minlcm) % minlcm; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:10","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"11. 欧拉函数 线性版O(n) void getphi() { phi[1] = 1; for (int i = 2; i \u003c M; ++i) { if (!isp[i]) pri[cnt++] = i, phi[i] = i - 1; for (int j = 0; j \u003c cnt \u0026\u0026 i * pri[j] \u003c M; ++j) { isp[i * pri[j]] = 1; if (i % pri[j] == 0) { phi[i * pri[j]] = pri[j] * phi[i]; break; } else { phi[i * pri[j]] = (pri[j] - 1) * phi[i]; } } } } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:11","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"12. 求组合数 递推版，针对取余p为质数（如果有的话），且m较小的情况,O(m) ll comb(ll n, ll m) { if (n \u003c m) return 0; ll ret = 1; for (int i = 1; i \u003c= m; ++i) ret = ret * (n - i + 1) / i; return ret; } 素因子版，针对取余p不为质数，其n较小的情况，O(nlogn) // 计算分子分母的素数个数差来计算结果O(nlogn),需要用到质数表，和快速幂 ll comb(int n, int m, int p) {// 求C(n, m) % p的结果，其中n, m \u003c= 1e6, p \u003c= 1e9 if (n \u003c m) return 0; ll res = 1; for (int i = 0; i \u003c cnt \u0026\u0026 pri[i] \u003c= n; ++i) { int num = 0; for (int j = n; j; j /= pri[i]) num += j / pri[i]; for (int j = m; j; j /= pri[i]) num -= j / pri[i]; for (int j = n - m; j; j /= pri[i]) num -= j / pri[i]; res = res * powf(pri[i], num, p) % p; } return res; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:2:12","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"三、数据结构 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:0","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"1. 并查集 简便的路径压缩版 const int Max = 1e5 + 10; int fa[Max]; inline void init() { for (int i = 0; i \u003c Max; i++) fa[i] = i; } int findfa(int x) { return x == fa[x] ? x : fa[x] = findfa(fa[x]); } void Un(int a, int b) { int fa1 = findfa(a); int fa2 = findfa(b); if (fa1 != fa2) fa[fa1] = fa2; } 网络赛版 class UF { public: int n; // 当前连通分量数目 int cnt; vector\u003cint\u003e size; vector\u003cint\u003e parent; UF(int _n): n(_n + 1), cnt(_n + 1), size(_n + 1, 1), parent(_n + 1) { int i = 0; for (auto \u0026x : parent) x = i++; } int findset(int x) { return parent[x] == x ? x : parent[x] = findset(parent[x]); } bool unite(int x, int y) { x = findset(x); y = findset(y); if (x == y) { return false; } if (size[x] \u003c size[y]) { swap(x, y); } parent[y] = x; size[x] += size[y]; --cnt; return true; } bool conn(int x, int y) { x = findset(x); y = findset(y); return x == y; } }; ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:1","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"2. 树状数组 单点修改与区间查询 // 修改复杂度与查询复杂度O(logn) #define lb(x) ((x) \u0026 (-x)) #define ll long long const int N = 1e6 + 5, M = 2e5 + 5; ll n, m, a[N], bit[N]; // 初始化 void build(int n) { for (int i = 1; i \u003c= n; ++i) { bit[i] += a[i]; int j = lb(i) + i; if (j \u003c= n) bit[j] += bit[i]; } } // 单点修改 void update(int index, ll val) { a[index] += val; while (index \u003c= n) { bit[index] += val; index += lb(index); } } // 前缀查询 ll get(int index) { ll res = 0; while (index) { res += bit[index]; index -= lb(index); } return res; } // 区间和查询 ll get(int l, int r) { return get(r) - get(l - 1); } 区间修改，区间查询 设$d[i] = a[i] - a[i - 1]$ 则 $a[ x ] = \\sum_{i = 1}^{x}{d_i}$ 设 $sum[ x ] = \\sum_{i = 1}^{x}{a_i}$ 即 $sum[ x ] = d[1] + d[1] + d[2] + d[1] + d[2] + d[3] + …… + d[1] + ……+ d[n]$ 化简得 $sum[ x ] = \\sum_{i = 1}^{x}{d_i \\times (n - i + 1)}$ 得 $sum[ x ] = (n + 1) \\times \\sum_{i = 1}^{x}{d_i} - \\sum_{i = 1}^{x}{i \\times d_i}$ 固开两个树状数组，一个维护差分数组$d_i$，一个维护$i \\times d_i$ #define lb(x) ((x) \u0026 (-x)) #define int long long const int N = 5e3 + 5, M = 1e6 + 5; int n, m, d[M], id[M]; // 基础树状数组单点更新 void update(int i, int val, int *bit) { while (i \u003c= n) { bit[i] += val; i += lb(i); } } // 单点修改 void update(int i, int val) { update(i, val, d), update(i, val * i, id); } // 区间修改 void update(int l, int r, int val) { update(l, val, d), update(r + 1, -val, d); update(l, l * val, id), update(r + 1, (-val) * (r + 1), id); } // 前缀查询 int get(int i, int *bit) { int res = 0; while (i) res += bit[i], i -= lb(i); return res; } // 区间和查询 int get(int l, int r) { int res = get(r, d) * (r + 1) - get(r, id); res -= get(l - 1, d) * l - get(l - 1, id); return res; } 网络赛类封装版 template\u003cclass T\u003e class BIT{ inline int lb(int x) { return x \u0026 (-x); } vector\u003cT\u003e bit; T getSum(int i) { T ret = 0; while (i \u003e 0) { ret += bit[i]; i -= lb(i); } return ret; } int n; public: BIT (int n, T val) : bit(n + 1, val), n(n) {}; BIT (int n, T *a) { rebuild(n, a); } void rebuild(int n, T *a) { bit.clear(); bit.push_back(); this-\u003en = n; for (int i = 1; i \u003c= n; ++i) { bit.push_back(a[i]); } for (int i = 1; i \u003c= n; ++i) { if (i + lb(i) \u003c= n) { bit[i + lb(i)] += bit[i]; } } } void point_update(int index, T val) { while (index \u003c= n) { bit[index] += val; index += lb(index); } } T get(int l, int r) { if (l \u003e r) return 0; return getSum(r) - getSum(l - 1); } }; ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:2","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"3. 线段树 精简版 // 宏 #define ls ((node) \u003c\u003c 1) #define rs (((node) \u003c\u003c 1) | 1) // 变量 const int N = 2e5 + 5; ll seg[N \u003c\u003c 2], lazy[N \u003c\u003c 2], arr[N]; // 操作 ll op(ll a, ll b) { return a + b; } // 题意不同，函数内部不同 void push_down(int l, int r, int node) { if (!lazy[node]) return; // 这里如果0也有意义的话多开一个数组标记 int mid = (l + r) \u003e\u003e 1; lazy[ls] += lazy[node], lazy[rs] += lazy[node]; seg[ls] += (mid - l + 1) * lazy[node]; seg[rs] += (r - mid) * lazy[node]; lazy[node] = 0; } // 初始化 void build(int l, int r, int node) { if (l == r) { seg[node] = arr[l]; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls), build(mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 单点修改 void update(int indx, ll v, int l, int r, int node) { if (l == r) { // 题意不同，这里更新操作不同 seg[node] = v; return; } int mid = (l + r) \u003e\u003e 1; if (indx \u003c= mid) update(indx, v, l, mid, ls); else update(indx, v, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间修改 void update(int ql, int qr, ll v, int l, int r, int node) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) { // 题意不同，这里更新操作不同 lazy[node] += v; seg[node] += (r - l + 1) * v; return; } push_down(l, r, node); int mid = (l + r) \u003e\u003e 1; if (ql \u003c= mid) update(ql, qr, v, l, mid, ls); if (qr \u003e mid) update(ql, qr, v, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间查找 ll get(int ql, int qr, int l, int r, int node) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) return seg[node]; push_down(l, r, node); // 保证单点的情况下这句话可以注释掉 int mid = (l + r) \u003e\u003e 1; ll ret = 0; // 题意不同，初始化不同 if (ql \u003c= mid) ret = get(ql, qr, l, mid, ls); if (qr \u003e mid) ret = op(get(ql, qr, mid + 1, r, rs), ret); return ret; } 结构体版 #include \u003cbits/stdc++.h\u003eusing namespace std; const int M = 1e6; typedef long long ll; template\u003cclass T\u003e struct Tree{ #define ls(node) (node \u003c\u003c 1) #define rs(node) ((node \u003c\u003c 1) | 1) Tree(int len = 10): len(len) {} T sum[M \u003c\u003c 2], lazy[M \u003c\u003c 2], arr[M]; int len; private: void pushup(const int node) {// 写题目要求维护的代码，如求和，最大最小…… sum[node] = max(sum[ls(node)], sum[rs(node)]); } void pushdown(int l, int r, const int node) {//同pushup int mid = (l + r) \u003e\u003e 1; lazy[ls(node)] += lazy[node], lazy[rs(node)] += lazy[node]; sum[ls(node)] += (mid - l + 1) * lazy[node]; sum[rs(node)] += (r - mid) * lazy[node]; lazy[node] = 0; } void build(int l, int r, int node) { if (l == r) { sum[node] = arr[l]; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls(node)), build(mid + 1, r, rs(node)); pushup(node); } void update(int ql, int qr, T v, int l, int r, int node) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) { sum[node] += (r - l + 1) * v;//更新操作根据题目要求更改 lazy[node] += v; return; } if (lazy[node]) pushdown(l, r, node); int mid = (l + r) \u003e\u003e 1; if (ql \u003c= mid) update(ql, qr, v, l, mid, ls(node)); if (qr \u003e mid) update(ql, qr, v, mid + 1, r, rs(node)); pushup(node); } T getAsk(int ql, int qr, int l, int r, int node) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) return sum[node];//上同 if (lazy[node]) pushdown(l, r, node); T res = 0; int mid = (l + r) \u003e\u003e 1; if (ql \u003c= mid) res = getAsk(ql, qr, l, mid, ls(node)); if (qr \u003e mid) res = max(res, getAsk(ql, qr, mid + 1, r, rs(node))); return res; } public: //以下为可以，直接调用的函数 void build() { build(1, len, 1); } void update(int ql, int qr, T v) { update(ql, qr, v, 1, len, 1); } void update(int index, T v) { update(index, index, v, 1, len, 1); } T getAsk(int ql, int qr) { return getAsk(ql, qr, 1, len, 1); } void clear() { memset(arr, 0, sizeof(T) * (len + 10)); memset(sum, 0, sizeof(T) * (len \u003c\u003c 2)); memset(lazy, 0, sizeof(T) * (len \u003c\u003c 2)); } T\u0026 operator[] (int x) { return arr[x]; } }; int main(){ return 0; } 类版-网络赛 #include \u003cbits/stdc++.h\u003e using namespace std; /** * 使用说明： * 本线段树板子可用于多数 网络赛 * 需要注意的是此板子在性能方面由于三层封装，固较简洁版的线段树性能慢，但灵活性高（适合网络赛抢时间） * 使用时只需要修改 \"可修改区的上下界\" 中间的代码部分 * lazy使用结构体封装是应付在某些题目在区间修改时有两种操作，下面给的例题有示例 * vals是最终题目需要维护的东西（sum, max, min……），针对不同的操作只需修改结构体内的加法（+）操作即可 * 同时若题目需要区间修改，则直接修改区间修改部分的代码即可，单点修改同理 * 注意：区间修改针对不同的操作，lazy中的加等于（+=）也要具体根据题意修改 * 例题1：洛谷 */ /****************************可修改区上界******************************/ template\u003cclass T\u003e struct lazy{ T lazy1; lazy(T lazy1 = 0){ this-\u003elazy1 = lazy1; } void operator+= (const lazy\u003c","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:3","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"4. ST表 const int M = 1e5 + 5; int st[M][30], lg[M]; // st表预处理, 注意下标从1开始到n结束 void init(int *a, int n) { lg[0] = -1; for (int i = 1; i \u003c= n; ++i) lg[i] = lg[i \u003e\u003e 1] + 1, st[i][0] = a[i]; for (int j = 1; j \u003c= lg[n]; ++j) { int k = 1 \u003c\u003c (j - 1); for (int i = 1; i + k - 1 \u003c= n; ++i) { st[i][j] = max(st[i][j - 1], st[i + k][j - 1]); } } } // 询问 // 尽可能让l + 2^(len) - 1接近r int get(int l, int r) { int x = lg[r - l + 1]; return max(st[l][x], st[r - (1 \u003c\u003c x) + 1][x]); } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:4","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"5. 分块 const int N = 1e5 + 5, M = 500; #define ll long long ll a[N]; int belong[N]; struct blocks { int l, r; ll lazy; blocks() : lazy(0){} }b[M]; // 以下函数是基本不变的 void build(int n) { int siz = sqrt(n), cnt = n / siz; if (n % siz) ++cnt; for (int i = 1; i \u003c= cnt; ++i) { b[i].l = (i - 1) * siz + 1; b[i].r = i * siz; } b[cnt].r = n; for (int i = 1; i \u003c= n; ++i) belong[i] = (i - 1) / siz + 1; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:5","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"6. 莫队 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e using namespace std; const int M = 1e5 + 10; int n, m, block, arr[M], pos[M], ans[M], res; struct MO{ int l, r, k; MO(int l = 0, int r = 0, int k = 0) : l(l), r(r), k(k) {} }q[M]; bool cmp(MO a, MO b) { if (pos[a.l] ^ pos[b.l]) {//不在同一个块 return pos[a.l] \u003c pos[b.l]; } if (pos[a.l] \u0026 1) return a.r \u003c b.r; return b.r \u003c a.r; } void add(int x) { } void del(int x) { } void solve() { int l = 1, r = 0; for (int i = 0; i \u003c m; i++) { while (l \u003e q[i].l) add(--l); while (l \u003c q[i].l) del(l++); while (r \u003c q[i].r) add(++r); while (r \u003e q[i].r) del(r--); ans[q[i].k] = res;//res根据题目意思来 } } void init() { scanf(\"%d %d\", \u0026n, \u0026m); block = sqrt(n); for (int i = 1; i \u003c= n; i++) { scanf(\"%d\", arr + i); pos[i] = i / block; } for (int i = 0; i \u003c m; i++) { int l, r; scanf(\"%d %d\", \u0026l, \u0026r); q[i] = MO(l, r, i); } sort(q, q + m, cmp); } int main() { init(); solve(); return 0; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:6","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"7. 平衡树 fhq treap // 洛谷板子题 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003crandom\u003e#include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } using namespace std; const int N = 4e5 + 10; mt19937 rnd(233); struct treap{ int val, l, r, size, key; }fhq[N]; int root, cnt; inline void update(int now) { fhq[now].size = fhq[fhq[now].l].size + fhq[fhq[now].r].size + 1; } int new_node(int val) { fhq[++cnt] = {.val = val, .l = 0, .r = 0, .size = 1, .key = rnd()}; return cnt; } void split(int now, int val, int \u0026x, int \u0026y) { if (!now) { x = y = 0; return; } if (fhq[now].val \u003c= val) x = now, split(fhq[now].r, val, fhq[now].r, y); else y = now, split(fhq[now].l, val, x, fhq[now].l); update(now); } int merge(int x, int y) { if (!x || !y) return x | y; // 大根堆 if (fhq[x].key \u003e fhq[y].key) { //右下角 fhq[x].r = merge(fhq[x].r, y), update(x); return x; } // 左下角 fhq[y].l = merge(x, fhq[y].l), update(y); return y; } // 插入 inline void insert(int val) { int x, y; split(root, val, x, y); root = merge(merge(x, new_node(val)), y); } // 按值删除 inline void del(int val) { int x, y, z; split(root, val, x, z); split(x, val - 1, x, y); y = merge(fhq[y].l, fhq[y].r); root = merge(merge(x, y), z); } // 按值获取排名 inline int getrank(int val) { int x, y, ans; split(root, val - 1, x, y); ans = fhq[x].size + 1; root = merge(x, y); return ans; } // 按排名获取值 inline int getval(int rank) { int now = root; while (now) { if (fhq[fhq[now].l].size + 1 == rank) break; else if (fhq[fhq[now].l].size \u003e= rank) now = fhq[now].l; else rank -= fhq[fhq[now].l].size + 1, now = fhq[now].r; } return fhq[now].val; } // 求前驱，即严格比val小的最大值 inline int pre(int val) { int x, y; split(root, val - 1, x, y); int now = x; while (fhq[now].r) now = fhq[now].r; root = merge(x, y); return fhq[now].val; } // 求后继，即严格比val大的最小值 inline int nxt(int val) { int x, y; split(root, val, x, y); int now = y; while (fhq[now].l) now = fhq[now].l; root = merge(x, y); return fhq[now].val; } int main() { int t = IO(); while (t--) { int q = IO(), val = IO(); if (q == 1) insert(val); else if (q == 2) del(val); else if (q == 3) printf(\"%d\\n\", getrank(val)); else if (q == 4) printf(\"%d\\n\", getval(val)); else if (q == 5) printf(\"%d\\n\", pre(val)); else printf(\"%d\\n\", nxt(val)); } return 0; } spaly 替罪羊 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:7","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"8. 左偏树 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:8","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"9. 主席树 主席树（静态）洛谷模板题 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } using namespace std; /*************************************离散化********************************************/ // vt存放可用于查询原本的数（用离散化值），打表后用于查询离散化表（用下标） vector\u003cint\u003e vt; inline int get_id(const int \u0026x) { return lower_bound(vt.begin(), vt.end(), x) - vt.begin() + 1; } inline void erase_vt() { sort(vt.begin(), vt.end()); vt.erase(unique(vt.begin(), vt.end()), vt.end()); } // 打表, 注意，原数组下标要从1开始，返回离散化后的表大小 inline int id_table(int n, int *a, vector\u003cint\u003e \u0026res) { res.emplace_back(0); for (int i = 1; i \u003c= n; ++i) res.emplace_back(get_id(a[i])); return vt.size(); } /*************************************主席树********************************************/ const int N = 2e5 + 5; struct nodes{ int l, r, sum; nodes() : sum(0) {} }hjt[N \u003c\u003c 5]; int root[N], cnt; // 记录每个根结点的内存池编号， 内存池 int build(int l, int r) { int now = ++cnt; // 内存申请 if (l \u003c r) { int mid = (l + r) \u003e\u003e 1; hjt[now].l = build(l, mid); hjt[now].r = build(mid + 1, r); } return now; } // 插入新节点的操作 int update(int pre, int l, int r, int x) { int now = ++cnt; // 内存申请 hjt[now] = hjt[pre], ++hjt[now].sum; // 继承 if (l \u003c r) { // 寻找拼接点 int mid = (l + r) \u003e\u003e 1; if (x \u003c= mid) hjt[now].l = update(hjt[now].l, l, mid, x); // 如果x在左边，则让当前新节点的左孩子接继承后的左孩子 else hjt[now].r = update(hjt[now].r, mid + 1, r, x); // 否则同理 } return now; } // 返回第qr版本的主席树 - 第ql版本的主席树， 注意返回的是离散化后的值 int get(int ql, int qr, int l, int r, int k) { if (l == r) return l; int mid = (l + r) \u003e\u003e 1; int dif = hjt[hjt[qr].l].sum - hjt[hjt[ql].l].sum; if (k \u003c= dif) return get(hjt[ql].l, hjt[qr].l, l, mid, k); // 左孩子上 return get(hjt[ql].r, hjt[qr].r, mid + 1, r, k - dif); // 右孩子上 } /*************************************主函数********************************************/ int a[N]; int main() { int n = IO(), m = IO(); for (int i = 1; i \u003c= n; ++i) a[i] = IO(), vt.emplace_back(a[i]); erase_vt(); vector\u003cint\u003e id; int siz = id_table(n, a, id); root[0] = build(1, siz); for (int i = 1; i \u003c= n; ++i) root[i] = update(root[i - 1], 1, siz, id[i]); while (m--) { int l = IO(), r = IO(), k = IO(); printf(\"%d\\n\", vt[get(root[l - 1], root[r], 1, siz, k) - 1]); } return 0; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:9","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"10. LCA // 洛谷板子题 // 注意，尽量让结点编号从1开始 #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003ccctype\u003e#define ll long long inline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } using namespace std; const int maxn = 5e5 + 5, maxm = 5e5 + 5; const int INF = 0x3f3f3f3f; int head[maxn], cnt; struct edges { int to, next; void add(int t, int n) { to = t, next = n; } }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v) { edge[++cnt].add(v, head[u]); head[u] = cnt; } int fa[maxn][35], dep[maxn], lg[maxn]; /* 另一种写法 void dfs(int u, int f) { deep[u] = deep[f] + 1; fa[u][0] = f; for (int i = 1; (1 \u003c\u003c i) \u003c= deep[u]; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int\u0026 v : mp[u]) { if (v ^ f) dfs(v, u); } } int lca(int a, int b) { if (deep[a] \u003c deep[b]) swap(a, b); for (int i = 18; ~i; --i) if (deep[fa[a][i]] \u003e= deep[b]) a = fa[a][i]; if (a == b) return a; for (int i = 20; ~i; --i) { if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; } return fa[a][0]; } */ void dfs(int u, int f) { fa[u][0] = f; dep[u] = dep[f] + 1; for (int i = 1; i \u003c= lg[dep[u]]; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v ^ f) dfs(v, u); } } void init(int root, int n) { // 通过检查代码，反向51行dep[root] = -1没意义，具体细节以后填这个坑 dep[root] = lg[0] = -1; memset(head, -1, sizeof head); cnt = 0; for (int i = 1; i \u003c= n; ++i) lg[i] = lg[i \u003e\u003e 1] + 1; } int lca(int a, int b) { if (dep[a] \u003c dep[b]) swap(a, b); while (dep[a] \u003e dep[b]) a = fa[a][lg[dep[a] - dep[b]]]; if (a == b) return a; for (int i = lg[dep[a]]; ~i; --i) { if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; } return fa[a][0]; } int main() { int n = IO(), m = IO(), root = IO(); init(root, n); for (int i = 1; i \u003c n; ++i) { int u = IO(), v = IO(); add(u, v), add(v, u); } dfs(root, 0); while (m--) { int a = IO(), b = IO(); printf(\"%d\\n\", lca(a, b)); } return 0; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:10","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"11. 树链剖分 // 洛谷板子题 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ciostream\u003e#include \u003ccmath\u003e#include \u003cbitset\u003eusing namespace std; #define ll long long const int N = 1e5 + 5, M = 2e5 + 5; const int maxn = 1e5 + 5, maxm = 2e5 + 5; const int INF = 0x3f3f3f3f; int head[maxn], cnt; //初始化 void init() { memset(head, -1, sizeof head); cnt = -1; } struct edges { int to, next; void add(int t, int n) { to = t, next = n; } }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v) { edge[++cnt].add(v, head[u]); head[u] = cnt; } /*******************************树链剖分**********************************/ int fa[N], dep[N], siz[N], son[N]; void dfs1(int u, int f) { fa[u] = f, siz[u] = 1; dep[u] = dep[f] + 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == f) continue; dfs1(v, u); siz[u] += siz[v]; if (siz[v] \u003e siz[son[u]]) son[u] = v; // 找重儿子 } } int v[N]; // 点上的权值 int tim, dfn[N], top[N], w[N]; // w的下标是时间戳，对应的是相应时间戳上的点的点权 void dfs2(int u, int t) { dfn[u] = ++tim, top[u] = t; w[tim] = v[u]; if (!son[u]) return; dfs2(son[u], t); for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa[u] || v == son[u]) continue; dfs2(v, v); } } /*******************************线段树******************************/ inline int ls(const int\u0026 x) { return x \u003c\u003c 1;} inline int rs(const int\u0026 x) { return x \u003c\u003c 1 | 1;} ll seg[N \u003c\u003c 2], lazy[N \u003c\u003c 2], p; int n, m; inline ll op(const ll\u0026 a, const ll\u0026 b) { // seg[x] = max(seg[ls(x)], seg[rs(x)]); return (a + b) % p; } inline void push_down(const int\u0026 l, const int\u0026 r, const int\u0026 node) { if (!lazy[node]) return; lazy[ls(node)] += lazy[node], lazy[rs(node)] += lazy[node]; lazy[ls(node)] %= p, lazy[rs(node)] %= p; int mid = (l + r) \u003e\u003e 1; seg[ls(node)] = (lazy[node] * (mid - l + 1) + seg[ls(node)]) % p; seg[rs(node)] = (lazy[node] * (r - mid) + seg[rs(node)]) % p; lazy[node] = 0; } void build(int l, int r, int node = 1) { if (l == r) { seg[node] = w[l]; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, ls(node)), build(mid + 1, r, rs(node)); seg[node] = op(seg[ls(node)], seg[rs(node)]); } void update(int ql, int qr, ll x, int l = 1, int r = n, int node = 1) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) { lazy[node] = (lazy[node] + x) % p; seg[node] = (seg[node] + (r - l + 1) * x) % p; return; } push_down(l, r, node); int mid = (l + r) \u003e\u003e 1; if (ql \u003c= mid) update(ql, qr, x, l, mid, ls(node)); if (qr \u003e mid) update(ql, qr, x, mid + 1, r, rs(node)); seg[node] = op(seg[ls(node)], seg[rs(node)]); } int get(int ql, int qr, int l = 1, int r = n, int node = 1) { if (ql \u003c= l \u0026\u0026 r \u003c= qr) return seg[node]; push_down(l, r, node); int mid = (l + r) \u003e\u003e 1, res = 0; if (ql \u003c= mid) res = get(ql, qr, l, mid, ls(node)); if (qr \u003e mid) res = op(res, get(ql, qr, mid + 1, r, rs(node))); return res; } /********************************树上操作**********************************/ void update_chain(int x, int y, ll z) {// 将树从 x 到 y 结点最短路径上所有节点的值都加上 z。 while (top[x] != top[y]) { if (dep[top[x]] \u003c dep[top[y]]) swap(x, y); update(dfn[top[x]], dfn[x], z); x = fa[top[x]]; } if (dep[x] \u003e dep[y]) swap(x, y); update(dfn[x], dfn[y], z); } ll get_chain(int x, int y) {//求树从 x 到 y 结点最短路径上所有节点的值之和。 int res = 0; while (top[x] != top[y]) { if (dep[top[x]] \u003c dep[top[y]]) swap(x, y); res = op(res, get(dfn[top[x]], dfn[x])); x = fa[top[x]]; } if (dep[x] \u003e dep[y]) swap(x, y); return op(res, get(dfn[x], dfn[y])); } void update_son(int x, ll z) {// 将以 x 为根节点的子树内所有节点值都加上 z update(dfn[x], dfn[x] + siz[x] - 1, z); } ll get_son(int x) {// 求以 x 为根节点的子树内所有节点值之和 return get(dfn[x], dfn[x] + siz[x] - 1); } /********************************主函数************************************/ int main() { std::ios::sync_with_stdio(false); cout.tie(0), cin.tie(0); init(); int root; cin \u003e\u003e n \u003e\u003e m \u003e\u003e root \u003e\u003e p; for (int i = 1; i \u003c= n; ++i) cin \u003e\u003e v[i]; for (int i = 1; i \u003c n; ++i) { int u, v; cin \u003e\u003e u \u003e\u003e v; add(u, v), add(v, u); } dfs1(root, root), dfs2(root, root); build(1, n); while (m--) { int q, x, y, z; cin \u003e\u003e q \u003e\u003e x; if (q == 1) { cin \u003e\u003e y \u003e\u003e z; update","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:3:11","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"四、图论 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:4:0","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"前置存图 const int N = 1e5 + 10, M = 2e5 + 10; const int INF = 0x3f3f3f3f; int head[N], cnt; //初始化 void init(int n) { fill_n(head, n + 5, -1); cnt = -1; } struct edges { int to, next; int w; void add(int t, int n, int w) { to = t, next = n, this-\u003ew = w; } }edge[N \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v, int w) { edge[++cnt].add(v, head[u], w); head[u] = cnt; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:4:1","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"1. 最短路 dijkstra //顶点数和边数 const int maxn = 1e5 + 10, maxm = 2e5 + 10; const int INF = 0x3f3f3f3f; int head[maxn], cnt, dis[maxn]; bool vis[maxn]; //初始化 void init(int n) { // n个点 fill_n(head, n + 1, -1); cnt = 0; } struct edges { int to, next; int w; edges(int to = 0, int next = -1, int w = 0) : to(to), next(next), w(w) {} }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add_edges(int u, int v, int w) { edge[++cnt] = edges(v, head[u], w); head[u] = cnt; } struct qnode{ int v; int w; qnode(int v = 0, int w = 0) : v(v), w(w) {} bool operator\u003c (const qnode \u0026t) const { return w \u003e t.w; } }; void dij(int n, int s) {//n 为顶点数， m 为边数 for (int i = 0; i \u003c= n; ++i) dis[i] = INF, vis[i] = 0; dis[s] = 0; priority_queue\u003cqnode\u003e heap; heap.push(qnode(s, dis[s])); while (heap.size()) { int u = heap.top().v; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; int w = edge[i].w; if (!vis[v] \u0026\u0026 dis[u] + w \u003c dis[v]) { //松弛 dis[v] = dis[u] + w; heap.push(qnode(v, dis[v])); } } } } bellman-ford const int maxn = 1e5 + 10, maxm = 2e5 + 10, inf = 0x3f3f3f3f; int dis[maxn]; struct edges { int u, v, w; edges(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) {} } edge[maxm]; bool bf(int n, int m, int s) { // n个点， m个边， s为起点 fill_n(dis, n + 1, inf); dis[s] = 0; for (int k = 1; k \u003c n; k++) { int ok = 1; for (int i = 1; i \u003c= m; i++) { if (dis[edge[i].v] \u003e dis[edge[i].u] + edge[i].w) { //松弛 dis[edge[i].v] = dis[edge[i].u] + edge[i].w; ok = 0; } } if (ok) break; // 小优化，无松弛操作 } for (int i = 1; i \u003c= m; i++) { if (dis[edge[i].v] \u003e dis[edge[i].u] + edge[i].w) { return false; // 有负环 } } return true;// 无负环 } spfa const int maxn = 1e5 + 10, maxm = 2e5 + 10, inf = 0x3f3f3f3f; int dis[maxn], num[maxn], head[maxn], cnt; //num 数组是判断是否有负环 bool inq[maxn]; void init(int n) { // n个点 fill_n(head, n + 5, -1); cnt = 0; } struct edges { int to, w, next; edges(int to = 0, int w = 0, int next = -1) : to(to), w(w), next(next) {} } edge[maxm]; inline void add_edges(int u, int v, int w) { edge[++cnt] = edges(v, w, head[u]); head[u] = cnt; } bool spfa(int n, int s) {// n个点， s为起点 for (int i = 0; i \u003c= n; ++i) { dis[i] = inf, num[i] = inq[i] = 0; } queue\u003cint\u003e q; q.push(s); inq[s] = num[s] = 1, dis[s] = 0; while (q.size()) { int u = q.front(); q.pop(); inq[u] = false; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to, w = edge[i].w; if (dis[v] \u003e dis[u] + w) { dis[v] = dis[u] + w; if (!inq[v]) { q.push(v); inq[v] = true, num[v]++; if (num[v] \u003e= n) return false; //如果从1号点到x的最短路中包含至少n个点（不包括自己），则存在环 } } } } return true; } floyd const int M = 2e2; int n, m; //顶点数和边数 int dis[M][M]; void floyd() { for (int k = 0; k \u003c n; k++) { for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j++) { if (dis[i][j] \u003e dis[i][k] + dis[k][j]) { dis[i][j] = dis[i][k] + dis[k][j]; } } } } } void init() { memset(dis, 0x3f, sizeof dis); for (int i = 0; i \u003c M; ++i) dis[i][i] = 0; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:4:2","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"2. 生成树 kruskal 适合稀疏图 #define ll long long using namespace std; #include \u003ccctype\u003einline long long IO() {} //省略快读 const int M = 2e5 + 10, N = 5e5 + 5; int fa[M]; struct edges { int u, v; ll w; } e[N]; bool cmp(edges\u0026 i, edges\u0026 j) { return i.w \u003c j.w; } int findset(int x) { return x == fa[x] ? x : fa[x] = findset(fa[x]); } bool un(int a, int b) { int fa1 = findset(a), fa2 = findset(b); if (fa1 == fa2) return false; fa[fa1] = fa2; return true; } ll kruskal(int n, int m) { sort(e, e + m, cmp); for (int i = 0; i \u003c= n; ++i) fa[i] = i; int cnt = 0; ll ans = 0; for (int i = 0; i \u003c m; ++i) { if (un(e[i].u, e[i].v)) { ans += e[i].w; if (++cnt == n - 1) break; } } return n - 1 == cnt ? ans : -1; } int main() { int n = IO(), m = IO(); for (int i = 0; i \u003c m; ++i) e[i].u = IO(), e[i].v = IO(), e[i].w = IO(); printf(\"%lld\\n\", kruskal(n, m)); return 0; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:4:3","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"3. tarjan ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:4:4","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"4. 网络流 Edmonds-Karp算法，速度较慢 #define ll long long #include \u003ccctype\u003einline long long IO() // 快读略 const int N = 205, M = 1e4 + 5; struct edges{ int to, next; ll cap, flow;// flow为记录当前路径流的流量，cap为容量 void add(int a, int b, ll c) { to = a, next = b; cap = c, flow = 0; } }; struct EK{ edges e[M]; const ll inf = 1e18; int head[N], cnt, n = 0, vis[N], pre[N];// vis记录是否在队内, pre记录前驱内存池编号 ll minc[N]; // 记录增广路的最小流 void init(int n) { this-\u003en = n, cnt = -1; fill_n(head, n + 1, -1); } void add(int u, int v, ll cap, int f = 1) { e[++cnt].add(v, head[u], cap); head[u] = cnt; if (f) add(v, u, 0, 0); } int bfs(int s, int t) { queue\u003cint\u003e q; for (int i = 0; i \u003c= n; ++i) vis[i] = 0, pre[i] = -1; q.push(s), vis[s] = 1, minc[s] = inf;// 初始化minc为无穷大 while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (vis[v] || e[i].cap == e[i].flow) continue; vis[v] = 1, pre[v] = i; minc[v] = min(minc[u], e[i].cap - e[i].flow);// 更新最小流 if (v == t) return 1;//找到了终点（汇点） q.push(v); } } return 0; } ll ek(int s, int t) { ll ans = 0, \u0026dif = minc[t]; while (bfs(s, t)) { ans += dif; for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { e[i].flow += dif; // 正向边flow+ e[i ^ 1].flow -= dif; // 反向边flow- } } return ans; } void clearflow() { // 清空流 for (int i = 0; i \u003c= cnt; ++i) e[i].flow = 0; } }ek; int main() { int n = IO(), m = IO(), s = IO(), t = IO(); ek.init(n); for (int i = 0; i \u003c m; ++i) { int u = IO(), v = IO(), cap = IO(); ek.add(u, v, cap); } printf(\"%lld\", ek.ek(s, t)); return 0; } dinic, 当前弧优化+多路增广优化+炸点优化(模板题),复杂度$O(n^2m)$ inline long long IO() // 快读略 const int N = 205, M = 1e4 + 5; struct edges{ int to, next; ll cap, flow;// flow为记录当前路径流的流量，cap为容量 void add(int a, int b, ll c) { to = a, next = b; cap = c, flow = 0; } }; struct Dinic { edges e[M]; const ll inf = 1e18; int head[N], cnt, n = 0, deep[N], cur[N]; void init(int n) { this-\u003en = n, cnt = -1; fill_n(head, n + 1, -1); } void add(int u, int v, ll cap, int f = 1) { e[++cnt].add(v, head[u], cap); head[u] = cnt; if (f) add(v, u, 0, 0); } // bfs求增广路，一次求出多条增广路 int bfs(int s, int t) { queue\u003cint\u003e q; fill_n(deep, n + 1, 0); deep[s] = 1, q.push(s); while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (deep[v] || e[i].cap == e[i].flow) continue; deep[v] = deep[u] + 1; q.push(v); } } return deep[t] != 0; } ll dfs(int u, int t, ll flow) { if (u == t) return flow; ll nowflow = 0; for (int i = cur[u]; ~i; i = e[i].next) { cur[u] = i;// 当前弧优化 int v = e[i].to; if (deep[v] != deep[u] + 1 || e[i].cap == e[i].flow) continue; if (ll low = dfs(v, t, min(flow - nowflow, e[i].cap - e[i].flow))) { e[i].flow += low, e[i ^ 1].flow -= low; nowflow += low;// 多路增广优化 if (nowflow == flow) break; } } if (!nowflow) deep[u] = -2;// 炸点优化 return nowflow; } ll dinic(int s, int t) { ll ans = 0; while (bfs(s, t)) { for (int i = 0; i \u003c= n; ++i) cur[i] = head[i];// 预处理，方便当前弧优化 ans += dfs(s, t, inf);// 进过多路增广优化可不用循环 } return ans; } void clearflow() { // 清空流 for (int i = 0; i \u003c= cnt; ++i) e[i].flow = 0; } }dinic; int main() { int n = IO(), m = IO(), s = IO(), t = IO(); dinic.init(n); for (int i = 0; i \u003c m; ++i) { int u = IO(), v = IO(); ll c = IO(); dinic.add(u, v, c); } printf(\"%lld\", dinic.dinic(s, t)); return 0; } 最小费用最大流，将ek算法中的bfs换成spfa inline long long IO() // 快读代码略 const int N = 410, M = 2e5 + 5; struct edges { int to, next; ll cap, cost, flow; void add(int a, int b, ll c, ll d) { to = a, next = b; cap = c, cost = d, flow = 0; } }; struct MCMF{ const ll inf = 1e15; int head[N], pre[N], cnt, n, inq[N]; ll maxflow, mincost, dist[N]; edges e[M]; void add(int u, int v, ll cap, ll cost, int f = 1) { e[++cnt].add(v, head[u], cap, cost); head[u] = cnt; if (f) add(v, u, 0, -cost, 0);// 建立反向弧，费用相反 } int spfa(int s, int t) {// 利用spaf找最小费用的路，即最短路 for (int i = 0; i \u003c= n; ++i) inq[i] = 0, dist[i] = inf, pre[i] = -1; queue\u003cint\u003e q; inq[s] = 1, q.push(s), dist[s] = 0; while (q.size()) { int u = q.front(); q.pop(); inq[u] = 0; for (int i = head[u]; ~i; i = e[i]","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:4:5","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"5. 二分图 匈牙利算法，时间复杂度$O(ev)$ int match[M]; bool vis[M]; bool dfs(int u) { for (int \u0026v : gp[u]) { if (vis[v]) continue; vis[v] = true; if (!match[v] || dfs(match[v])) { match[u] = v, match[v] = u; return true; } } return false; } // 主函数里 fill_n(match, n + 1, 0); // n是点的个数 for (int i = 1; i \u003c= n; ++i) { if (match[i]) continue; fill_n(vis, n + 1, false); dfs(i); } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:4:6","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"五、字符串 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:5:0","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"1. KMP const int M = 1e6 + 5; //普通版本 void getnext(char *x, int len, int *nxt) { int i = 0, j; j = nxt[0] = -1; while (i \u003c len) { while(j != -1 \u0026\u0026 x[i] != x[j]) j = nxt[j]; nxt[++i] = ++j; } } //略微优化版本 void getNext(char *x, int len, int *nxt) { int i = 0, j; j = nxt[0] = -1; while (i \u003c len) { while (j != -1 \u0026\u0026 x[i] != x[j]) j = nxt[j]; if (x[++i] == x[++j]) nxt[i] = nxt[j]; else nxt[i] = j; } } // y是主串 int nxt[M]; int kmpCount(char *y, int n, char *x, int m) { int i = 0, j = 0, ans = 0; getnext(x, m, nxt); while (i \u003c n) { while (j != -1 \u0026\u0026 y[i] != x[j]) j = nxt[j]; ++i, ++j; if (j \u003e= m) ++ans, j = nxt[j]; } return ans; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:5:1","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"2. 字符串Hash unsigned int DJBHash(const char *str) { unsigned int hash = 5381; while (*str) hash += (hash \u003c\u003c 5) + (*str++); return (hash \u0026 0x7fffffff); //7个f } unsigned int BKDRHash(const char *str) { unsigned int seed = 131; // 31 131 1313 13131 131313... unsigned int hash = 0; while (*str) hash = hash * seed + (*str++); return (hash \u0026 0x7fffffff); } #define ull unsigned long long ull strhash(const char *s) { ull seed = 1313, res = 0; // 31 131 1313 13131 while (*s) res = res * seed + (*s++); return res; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:5:2","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"3. 马拉车 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:5:3","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"4. exkmp void pre_exkmp(char x[], int m, int next[]) { next[0] = m; int j = 0; while (j + 1 \u003c m \u0026\u0026 x[j] == x[j + 1]) j++; next[1] = j; int k = 1; for (int i = 2; i \u003c m; i++) { int p = next[k] + k - 1; int L = next[i - k]; if (i + L \u003c p + 1) next[i] = L; else { j = max(0, p - i + 1); while (i + j \u003c m \u0026\u0026 x[i + j] == x[j]) j++; next[i] = j; k = i; } } } void exkmp(char x[], int m, char y[], int n, int next[], int extend[]) { pre_exkmp(x, m, next); int j = 0; while (j \u003c n \u0026\u0026 j \u003c m \u0026\u0026 x[j] == y[j]) j++; extend[0] = j; int k = 0; for (int i = 1; i \u003c n; i++) { int p = extend[k] + k - 1; int L = next[i - k]; if (i + L \u003c p + 1) extend[i] = L; else { j = max(0, p - i + 1); while (i + j \u003c n \u0026\u0026 j \u003c m \u0026\u0026 y[i + j] == x[j]) j++; extend[i] = j; k = i; } } } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:5:4","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"六、 计算几何 二维几何（未完善） #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003ccmath\u003e#include \u003cvector\u003e /** * 本板子属于半成品，有些功能并没有验证 * 函数说明： * 关于点的函数 * 点的Point(double, double) 构造函数 * + 向量加法 * - 向量减法 * == 判断两个点是否相等 * *(Point) 向量点乘 * *(double) 向量伸长(没有除法，要用除法直接乘倒数) * ^ 向量叉乘 * \u003c 点对点的比较 * double len() 向量的长度，也可以用来求两个点的距离 * double len2() const; 向量长度的平方 * double dist(Point); 判断p点到这个点的距离 * double angle(Point, Point); // 传入两个点a b， 返回 角apb 的弧度 * Point rotate(double angle) 向量逆时针旋转angle弧度 * Point rotate(Point, double) 点让点p逆时针旋转angle弧度 * void print() 将点输出 * int init() 输入点的坐标 返回值和scanf相同 * 其他非结构体函数 * angle(Point\u0026, Point\u0026) 计算两个向量的夹角 * * 关于线的函数 * Line(Point, Point) 构造函数 * Line(Point, double) 根据一个点和一个倾斜角 0 \u003c= angle \u003c PI确定直线 （未验证） * double len() 返回线段的长度 * Point vec(); 获取该线的向量 * double point(double t) 返回距离点p向前t倍向量的点 * double angle() 返回直线的倾斜角 范围[0, PI) (未验证) * int PointAndLine(Point); // 点和直线的关系，1 点在线左边，2 右边， 3 线上面 * double disPointToLine(const Point\u0026) 点到这条直线的距离 * double disPointToSeg(const Point\u0026) 点到这条线段的距离（未验证） * Point getPro(const Point\u0026) 点在这条线上的投影 （未验证） * Point getSym(const Point\u0026) 点关于这条线的对称点 （未验证） * bool isOnLine(const Point\u0026) 验证该点是否在这条直线上（未验证） * bool isOnSeg(const Point\u0026) 验证该点是否在这条线段上（未验证） * Point cross(Line\u0026) 直线和这条直线的交点，前提是相交 * void print() 输出这条线段 * * 其他非结构体 * int LineAndLine(Line\u0026, Line\u0026) 直线和直线的关系 0平行 1重合 2相交 （未验证） * Point getLineInter(const Line\u0026, const Line\u0026) 求两直线的交点,必须相交才能调用 （此函数有问题） * int SegAndSeg(const Line\u0026 l1, const Line\u0026 l2) 两个线段的关系 0不相交 1非规范相交(其中一个线段的端点和另一个线段相交) 2规范相交 （未验证） * int LineAndSeg(const Line\u0026 line, const Line\u0026 seg) 直线和线段的关系，0不相交 1非规范相交 2规范相交 （未验证） * * 关于圆的函数 * Circle(Point, double) 构造函数 * Circle(Point, Point, Point) 过三点的圆 * double area() const; 返回圆的面积 * double circum() const 返回圆的周长 * int PointAndCircle(Point\u0026) 点和圆的关系 返回 0圆外 1圆上 2圆内 * int LineAndCircle(Point\u0026) 点和圆的关系 返回 0不相交 1相交 2相交两个点（未验证） * int CircleAndCircle(Circle\u0026) 圆和圆的关系 返回 0内含 1内切 2相交两点 3外切 4外离 （未验证） * * 关于三角形的函数 * Triangle(Point, Point, Point) 构造函数 * double area() const 返回三角形函数 * Circle outerCircle() 获取三角形的外接圆 * * 关于多边形的函数 * Polygon(vector\u003cPoint\u003e\u0026) 构造函数 * double circum(); 求凸包的周长 * void graham(Polygon\u0026) 求凸包 传入值为需要求出的凸包的点集 * int PointAndPolgon(Point\u0026) 判断点与多边形的关系，0外 1内 2边上 3点上 （未实现） * double minRectCover() 点集的最小矩形覆盖，自己必须是（逆时针）凸包才能调用 （未实现） * Circle minCircleCover() 点集的最小圆覆盖 */ using namespace std; const double eps = 1e-8, PI = acos(-1.0); int dcmp(double x) { if (fabs(x) \u003c eps) return 0; return x \u003e 0 ? 1 : -1; } /******************************点*******************************/ /* 除了结构体内部函数还有 angle(Point\u0026 a, Point\u0026 b) // 两个向量的夹角 */ struct Point { double x, y; Point(double x = 0, double y = 0) : x(x), y(y) {} Point operator + (const Point\u0026) const; Point operator - (const Point\u0026) const; double operator * (const Point\u0026) const; // 点乘 double operator ^ (const Point\u0026) const; // 叉乘 bool operator == (const Point\u0026) const; bool operator \u003c (const Point\u0026) const; // 排序需要 Point operator * (double); //向量伸长b倍 double len() const; // 向量的长度 double len2() const; // 向量长度的平方 double dist(Point); // 判断p点到这个点的距离 double angle(Point, Point); // 传入两个点a b， 返回 角apb 的弧度 Point rotate(double); // 向量逆时针旋转a弧度后 Point rotate(Point\u0026, double); // 点绕p点顺时针旋转a弧度后 void print() { printf(\"%.2f %.2f\", x, y); } int init() { return scanf(\"%lf%lf\", \u0026x, \u0026y); } }; Point Point::operator + (const Point\u0026 b) const { return Point(x + b.x, y + b.y); } Point Point::operator - (const Point\u0026 b) const { return Point(x - b.x, y - b.y); } // 点乘 double Point::operator * (const Point\u0026 b) const { return x * b.x + y * b.y; } // 叉乘 double Point::operator ^ (const Point\u0026 b) const { return x * b.y - y * b.x; } bool Point::operator == (const Point\u0026 b) const { return !dcmp(x - b.x) \u0026\u0026 !dcmp(y - b.y); } bool Point::operator \u003c (const Point\u0026 b) const { return (!dcmp(x - b.x)) ? dcmp(y - b.y) \u003c 0 : x \u003c b.x; } // 向量的长度 double Point::len() const { return hypot(x, y); } // 向量长度平方 double Point::len2() const { return x * x + y * y; } // 判断p点到这个点的距离 double Point::dist(Point p) { return hypot(x - p.x, y - p.y); } // 向量伸长b倍 Point Point::operator * (do","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:6:0","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"七、动态规划 ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:7:0","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"1. 树形dp 树的最大独立集 /* Loj 10160 每个点都有一个快乐值，子结点和父节点不能同时被选，问你最大的快乐值 dp[i][0]表示第i号结点不选时最大的快乐值 dp[i][1]表示第i号结点选时的最大的快乐值 */ #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccctype\u003e#include \u003ccstring\u003eusing namespace std; const int M = 6e3 + 5; inline long long IO() {} // 快读略 struct es{ int to, nxt; }e[M \u003c\u003c 1]; int head[M], cnt; inline void init() { memset(head, -1, sizeof head); cnt = 0; } inline void add(int u, int v) { e[++cnt] = {.to = v, .nxt = head[u]}; head[u] = cnt; } int n, h[M], vis[M], dp[M][2]; void dfs(int u) { dp[u][1] = h[u]; for (int i = head[u]; ~i; i = e[i].nxt) { int v = e[i].to; dfs(v); dp[u][0] += max(dp[v][0], dp[v][1]); dp[u][1] += dp[v][0]; } } int main() { int n = read(); for (int i = 1; i \u003c= n; ++i) h[i] = read(); int u = read(), v = read(); init(); while (u | v) { add(v, u); vis[u] = true; u = read(), v = read(); } int root = 0; for (int i = 1; i \u003c= n; ++i) { if (!vis[i]) root = i; } dfs(root); printf(\"%d\\n\", max(dp[root][0], dp[root][1])); return 0; } 树的最小支配集 /* Loj 10157 每个点都有点权，一个点可以看守连着他的边上的点，选一些点出来，使他们能够看守整颗树上所有的点 问你最小选出来的权值 dp[0][i]表示i点被选上，则其 += min({dp[0][son], dp[2][son], dp[1][son]}) dp[1][i]表示i点没被选上，但是其父亲被选上了，则其 += min(dp[0][son], dp[2][son]) dp[2][i]表示i点没被选上，但是去其中某几个儿子被选上了，注意这个比较难转移，转移方式如下 先求出所有儿子min(dp[0][son], dp[1][son])的总和，然后在递归完后选出最小是那个儿子的dp[0][son] 即dp[2][u] = min(dp[2][u], sum - min(dp[2][v], dp[0][v]) + dp[0][v]);这行 */ #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; #define ll long long #include \u003ccctype\u003einline long long IO() {} // 快读略 const int maxn = 1e5, maxm = 1e5; const int INF = 0x3f3f3f3f; int head[maxn], cnt, dis[maxn]; //初始化 void init() { memset(head, -1, sizeof head); // memset(vis, false, sizeof vis); cnt = 0; } struct edges { int to, next; int w; edges(int to = 0, int next = -1, int w = 0) : to(to), next(next), w(w) {} }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v, int w = 0) { if (cnt == 0) init(); edge[++cnt] = edges(v, head[u], w); head[u] = cnt; } const int M = 1e4, inf = 0x3f3f3f3f; int n, m, dp[3][M], vis[M], c[M]; void dfs(int u, int fa) { dp[0][u] = c[u], dp[2][u] = inf; int sum = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; dfs (v, u); dp[0][u] += min({dp[0][v], dp[2][v], dp[1][v]}); if (fa != -1) dp[1][u] += min(dp[2][v], dp[0][v]); sum += min(dp[2][v], dp[0][v]); } for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; dp[2][u] = min(dp[2][u], sum - min(dp[2][v], dp[0][v]) + dp[0][v]); } } int main() { n = IO(); init(); for (int i = 0; i \u003c n; ++i) { int u = IO(), w = IO(), k = IO(); c[u] = w; while (k--) { int v = IO(); add(u, v), add(v, u); } } dfs(1, -1); printf(\"%d\", min(dp[0][1], dp[2][1])); return 0; } 树的最小点覆盖 /* Loj10156 每个点都能看到他所连着的边，问你选出最少的点使树上所有的边都能被看到 dp[0][i]表示不选i点的最小选择数 则其 += dp[1][son] dp[1][i]表示选i点的最小选择数，则其 += min(dp[0][son], dp[1][son]) */ #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; #define ll long long #include \u003ccctype\u003einline long long IO() {} // 快读略 const int maxn = 1e5, maxm = 1e5; const int INF = 0x3f3f3f3f; int head[maxn], cnt, dis[maxn]; //初始化 void init() { memset(head, -1, sizeof head); // memset(vis, false, sizeof vis); cnt = 0; } struct edges { int to, next; int w; edges(int to = 0, int next = -1, int w = 0) : to(to), next(next), w(w) {} }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v, int w = 0) { if (cnt == 0) init(); edge[++cnt] = edges(v, head[u], w); head[u] = cnt; } const int M = 1e4; int n, m, dp[2][M], vis[M]; void dfs(int u, int fa) { dp[1][u] = 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; dfs(v, u); dp[1][u] += min(dp[0][v], dp[1][v]); dp[0][u] += dp[1][v]; } } int main() { n = IO(); for (int i = 0; i \u003c n; ++i) { int u = IO(), k = IO(); while (k--) { int v = IO(); add(u, v), add(v, u); } } dfs(0, -1); // printf(\"%d\\n\", ans); printf(\"%d\", min(dp[0][0], dp[1][0])); return 0; } 树的直径","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:7:1","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结","模板"],"content":"最长上升子序列 朴素动态规划 dp[N], ans = 1; for (int i = 1; i \u003c= n; ++i) { dp[i] = 1; for (int j = 1; j \u003c i; ++j) { if (a[j] \u003c a[i]) { // 严格上升用 \u003c , 否则用 \u003c= dp[i] = max(dp[i], dp[j] + 1); } } ans = max(ans, dp[i]); } 贪心 // 坑（未补） 树状数组（或线段树）优化动态规划（直接优化） inline long long IO() {} using namespace std; const int N = 1e5 + 5, M = 1e6 + 5, inf = 1e9; int a[M]; unordered_map\u003cint, int\u003e mp; void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } #define lb(x) (x \u0026 (-x)) int bit[M], n; int get(int i) { int res = 0; while (i) { res = max(res, bit[i]), i -= lb(i); } return res; } void update(int i, int v, int\u0026 len) { while(i \u003c= len) { bit[i] = max(bit[i], v), i += lb(i); } } void problem() { int n = IO(); vector\u003cint\u003e arr; for (int i = 0; i \u003c n; ++i) a[i] = IO(), arr.push_back(a[i]); sort(arr.begin(), arr.end()); arr.erase(unique(arr.begin(), arr.end()), arr.end()); int cnt = 0, res = 0, len = arr.size(); for (int x : arr) mp[x] = ++cnt; for (int i = 0; i \u003c n; ++i) { int ans = get(mp[a[i]] - 1) + 1; res = max(ans, res); update(mp[a[i]], ans, len); } print(res); } int main() { int n = 1; while (n--) { problem(); } return 0; } 树状数组（或线段树）优化（将值排序，求下标的最长上升子序列） #define ll long long #define all(x) x.begin(), x.end() inline long long IO() {} using namespace std; const int N = 1e5 + 5, M = 1e6 + 5, inf = 1e9; int num[N], sum[410]; ll a[210]; void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } struct pii{ int x, indx; }p[N]; #define lb(x) (x \u0026 (-x)) int bit[N], n; int get(int i) { int res = 0; while (i) { res = max(res, bit[i]), i -= lb(i); } return res; } void update(int i, int v) { while(i \u003c= n) { bit[i] = max(bit[i], v), i += lb(i); } } void problem() { n = IO(); for (int i = 0; i \u003c n; ++i) p[i].x = IO(), p[i].indx = i + 1; sort(p, p + n, [] (pii \u0026i, pii \u0026j) { if (i.x == j.x) return i.indx \u003e j.indx; return i.x \u003c j.x; }); int res = 0; for (int i = 0; i \u003c n; ++i) { int ans = get(p[i].indx - 1) + 1; res = max(ans, res); update(p[i].indx, ans); } print(res); } int main() { int n = 1; while (n--) { problem(); } return 0; } ","date":"2021-07-22","objectID":"/2021/07/%E6%A8%A1%E6%9D%BF/:7:2","tags":null,"title":"我的模板（整合版）","uri":"/2021/07/%E6%A8%A1%E6%9D%BF/"},{"categories":["总结"],"content":"数学公式小总结 ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:0:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"质数 算术基本定理：$N = {P_1}^{k_1} \\times{P_2}^{k_2} \\times {P_3}^{k_3} \\cdots \\times {P_n}^{k_n} \\ \\ , \\ \\ P_1 \u003c P_2 \u003c P_3 \u003c \\cdots \u003c P_n$ 一个数N约数个数：$(k_1 + 1) \\times (k_2 + 1) \\times (k_3 + 1) \\times \\cdots \\times (k_n + 1)$，k是算术基本定理中的k 一个数N的所有正因数的和：$({P_1} ^ {0} + {P_1} ^ {1} + {P_1} ^ {2} \\cdots + {P_1} ^ {k_1})\\times ({P_2} ^ {0} + {P_2} ^ {1} + {P_2} ^ {2} \\cdots + {P_2} ^ {k_2}) \\times \\cdots \\times ({P_n} ^ {0} + {P_n} ^ {1} + {P_n} ^ {2} \\cdots + {P_n} ^ {k_n})$ 费马小定理：$a^{p - 1} \\equiv 1 (modp)$，p是素数 ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:1:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"gcd $gcd(a, b) = gcd(b, a \\bmod b)$ $gcd(a, b) = gcd(a, b - a)$ 由算术基本定理： 假设$N = {P_1}^{a_1} \\times{P_2}^{a_2} \\times {P_3}^{a_3} \\cdots \\times {P_n}^{a_n}$ 而$M = {P_1}^{b_1} \\times{P_2}^{b_2} \\times {P_3}^{b_3} \\cdots \\times {P_n}^{b_n}$ 则$gcd(N, M) = P_1^{min(a_1, b_1)}\\times P_2^{min(a_2, b_2)}\\times P_3^{min(a_3, b_3)}\\times \\dots \\times P_n^{min(a_n, b_n)}$ $lcm(N, M) = P_1^{max(a_1, b_1)}\\times P_2^{max(a_2, b_2)}\\times P_3^{max(a_3, b_3)}\\times \\dots \\times P_n^{max(a_n, b_n)}$ 斐波那契数列$f(1) = 1, f(2) = 1, f(3) = 2\\dots$，则$gcd(f(a), f(b)) = f(gcd(a, b))$ 由第2条性质可推广：$gcd(a_1, a_2, a_3, \\dots a_n) = gcd(a_1, a_2 - a_1, a_3 - a_2\\dots a_n - a_{n- 1})$ $gcd$具区间单调性：对于区间$l_3 \\le l_2 \\le l_1 \\le r_1 \\le r_2 \\le r_3$ $gcd(l_3, r_3)\\le gcd(l_2, r_2) \\le gcd(l_1, r_1)$ $gcd$具有区间反向包含性质：对于$gcd(l_1, r_1)$，$gcd(l_2, r_2)$，$l_1\\le l_2 \\le r_2 \\le r_1$则$gcd(l_1, r_1)$一定是$gcd(l_2, r_2)$的因子 ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:2:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"卡特兰 公式一：$f(n) = \\sum_{i = 0}^{n - 1}{f(i) \\times f(n - i - 1)}$ 公式二：$f(n) = \\frac{f(n - 1) \\times (4n - 2)}{n + 1}$ 公式三：$f(n) = \\frac{C_{2n}^{n}}{n + 1}$ 公式四：$f(n) = C_{2n}^{n} - C_{2n}^{n - 1}$ 变形：给你$n$个1和$m$个0组合$n \\ge m$，求一个组合满足前k个中1的个数不少于0的个数的方案数：$C_{n + m}^{n} - C_{n + m}^{n - 1}$ ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:3:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"组合数 通项公式：$C_{n}^{m} = \\frac{n!}{m!(n - m)!} = \\frac{n\\times(n - 1)\\times \\dots \\times (n - m + 1)}{m!}$ 递推公式：$C_{n}^{m} = C_{n - 1}^{m - 1} + C_{n - 1}^{m} = \\frac{n - m + 1}{m}\\times C_{n}^{m - 1}$ 有重复元素的全排列：有k个元素，取其中第i个元素有$n_i$个，全排列的个数：$\\frac{n!}{n_1!n_2!n_3!\\dots n_k!}$，其中$n = \\sum{n_i}$ 可重复选择的组合：有n个不同元素，每个元素可以选多次，一共选k个元素，方案数：$C_{k + n - 1}^{n - 1}$ 性质1：$C_{n + m + 1}^{m} = \\sum_{i = 0}^{m}{C_{n + i}^{i}}$ 性质2：$C_{n}^{m}\\times C_{m}^{i} = C_{n}^{i}\\times C_{n - i}^{m - i}$ 性质3：$\\sum_{i = 0}^{n}{C_{n}^{i}} = 2 ^ n$ 性质4：$\\sum_{i = 0}^{n}{C_{n}^{i}\\times x^i} = (x + 1)^n$ 性质5：$C_{n}^{0} - C_{n}^{1} + C_{n}^{2} - \\dots \\pm C_{n}^{n} = 0$ 性质6：$C_{n}^{0} + C_{n}^{2} + C_{n}^{4}+\\dots = C_{n}^{1}+C_{n}^{3}+C_{n}^{5}+\\dots = 2^{n - 1}$ 性质7：$C_{n + m}^{i} = C_{n}^{0} \\times C_{m}^{i} + C_{n}^{1} \\times C_{m}^{i - 1} \\times \\dots \\times C_{n}^{i}\\times C_{m}^{0}$ 性质8：$m \\times C_{n}^{m} = n \\times C_{n - 1}^{m - 1}$ 性质9：$\\sum_{i = 1}^{n}{C_{n}^{i}\\times i}= n \\times 2^{n - 1}$ 性质10：$\\sum_{i = 1}^{n}{C_{n}^{i}} \\times i^2 = n \\times (n + 1) \\times 2^{n - 2}$ 性质11：$\\sum_{i = 0}^{n}{(C_{n}^{i})^2} = C_{2n}^{n}$ ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:4:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"斯特林数 ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:5:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"欧拉函数 性质1：若p为质数则$phi(p) = p - 1$ 性质2：若p为质数则$phi(p^a) = (p - 1) \\times p^{a - 1}$ 性质3：当$n$，$m$互质时，则有$phi(nm) = phi(n) \\times phi(m)$ 性质4：若$a$，$m$互质时，则有$a^{phi(m)} \\equiv 1 \\pmod m$ 性质5：若$p$为质数，且$i \\bmod p = 0$，则$phi(i \\times p) = p \\times phi(i)$ 性质6：若$p$为质数，且$i \\bmod p \\ne 0$，则$phi(i \\times p) = phi(i) \\times (p - 1)$ 性质7：若$n$为奇数，则$phi(2n) = phi(n)$ 性质8：若$n$、$p$互质，则$p-n$也与$p$互质，因此小于$p$且与$p$互质的数之和为$phi(n) \\times n / 2$ 性质9：若$n \u003e 1$，则小于$n$且与其互质的所有正整数之和为$phi(n) \\times n / 2$ ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:6:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"概率 假设有一个整数随机变量X，则有$p(X = k) = p(X \\ge k) - p(X \u003e k)$ ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:7:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"期望 期望的线性：$E(X + Y) = E(X) + E(Y)$ 同理，如果$X_1 + X_2 = X$，则$E(X) = E(X_1) + E(X_2)$ 假如X是一个随机正整数变量，则$E(X) = \\sum_{i = 1}^{\\infty}{P(X \\ge i)}$ ","date":"2021-07-21","objectID":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/:8:0","tags":["数学"],"title":"一些有用的数学公式与结论","uri":"/2021/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/"},{"categories":["总结"],"content":"树形dp总结 ","date":"2021-07-20","objectID":"/2021/07/%E6%A0%91%E5%BD%A2dp/:0:0","tags":["dp","树形dp"],"title":"树形dp总结","uri":"/2021/07/%E6%A0%91%E5%BD%A2dp/"},{"categories":["总结"],"content":"树形背包常用思考模型 ","date":"2021-07-20","objectID":"/2021/07/%E6%A0%91%E5%BD%A2dp/:1:0","tags":["dp","树形dp"],"title":"树形dp总结","uri":"/2021/07/%E6%A0%91%E5%BD%A2dp/"},{"categories":["总结"],"content":"模型一 首先对于每个节点我们在dfs中dp转移时可以想象成一个分组背包，每次新遍历一个子树就可以想象成一个分组背包的下一组，转移时利用之前的背包状态进行转移，如果觉得这个模型比较难理解可以看下面的模型二。 ","date":"2021-07-20","objectID":"/2021/07/%E6%A0%91%E5%BD%A2dp/:1:1","tags":["dp","树形dp"],"title":"树形dp总结","uri":"/2021/07/%E6%A0%91%E5%BD%A2dp/"},{"categories":["总结"],"content":"模型二 首先对于每次新遍历一个结点我们都可以想象成是在给这个结点拼接一颗子树如下图 模型图 解释：圆点为树的结点，三角形为一颗子树，线段为边，箭头是拼接方向。蓝色为之前计算好的状态的树，红色为即将拼接上去的一颗子树（这颗子树在dfs时计算好了所有状态） ","date":"2021-07-20","objectID":"/2021/07/%E6%A0%91%E5%BD%A2dp/:1:2","tags":["dp","树形dp"],"title":"树形dp总结","uri":"/2021/07/%E6%A0%91%E5%BD%A2dp/"},{"categories":["总结"],"content":"模型一与模型二的联系 回到模型二，我们可以把蓝色部分想象成是分组背包中的前k - 1个背包状态，红色被第k组背包，子树中的每个方案都是分组背包中的一个物品，可以结合题目进行理解 需要注意的点：当我们在转移时一定要保证状态合法，例如转移时利用到的状态必须是这个树真的有这么多个结点 ","date":"2021-07-20","objectID":"/2021/07/%E6%A0%91%E5%BD%A2dp/:1:3","tags":["dp","树形dp"],"title":"树形dp总结","uri":"/2021/07/%E6%A0%91%E5%BD%A2dp/"},{"categories":["总结"],"content":"【例题1】P3177 树上染色 思路 一道树形dp题，想了好久，最终看了题解发现是突破口不对 突破口：首先思考怎么求一条边被算过的次数，用组合数学方法思考可以想到就是这条边两个方向（定义一个左边，一个右边）的黑点个数的乘积 + 白点个数的乘积 假设左边黑点的个数是x，且其左边节点个数是size， 树的总结点个数为n，则这条边计算次数有下面的公式 $$ tot = x \\times (k - x) + (size - x) \\times (n - size - k + x) $$ 有了这个突破口就可以思考怎么dp了 首先要明白每条边必定会对最终的答案做出贡献，固我们可以这样来定义状态：$dp[u][i]$表示节点u的子树选i个黑点的最大贡献，由树形背包模型(对应博客点这里)可以得到方程，不难得出状态方程这样写 $$ dp[u][i] = max{ dp[son][j] + dp[u][i - j] + tot \\times w } $$ 值得注意的点：$i - j$可能并没有这个状态，即可能这颗树在当前转移之前并没有$i - j$个节点，有一种解决方式就是将dp值初始化为-1，若在转移时dp值变了就证明他是合法的，否则并不合法 但是这种转移经过讨论好像他的复杂度接近$O(n^3)$ 还有一种的转移方式就是 $$ dp[u][i + j] = max{ dp[son][i] + dp[u][j] + tot \\times w} $$ 这样转移的话洛谷是可以拿到100分的，这样就能保证转移时每个子树都只在他们的lca上计算一次，代码如下 int dfs(int u, int fa) { int cnt = 1; // dp[u][1] = dp[u][0] = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v ^ fa) { ll \u0026w = edge[i].w; int son = dfs(v, u); for (int k = min(m, cnt); ~k; --k) { // 还是要反过来遍历 for (int j = min(son, m); ~j; --j) { if (j + k \u003e m) continue; ll tot = j * (m - j) + (son - j) * (n - son - m + j); dp[u][j + k] = max(dp[u][j + k], dp[u][k] + dp[v][j] + tot * w); } } cnt += son; } } return cnt; } 注意到我第8行和之前的代码对应的循环都是反过来遍历的，原因也解释过了，这个是01背包中我们空间优化时利用到的转移方式用来防止转移覆盖的问题，当然还有一种不用担心转移覆盖的方式，贴上学长巨巨的代码，简单易懂 #include\u003cbits/stdc++.h\u003eusing namespace std; #define ll long long #define pii pair\u003cint,int\u003e #define pb push_back #define mp make_pair const int maxn = 2000 + 5; const int mod = 1e9 + 7; ll dp[maxn][maxn]; ll sz[maxn] , n; vector\u003cpii\u003e e[maxn]; ll tmp[maxn] , up; void dfs (int u , int fa) { sz[u] = 1; for (auto g : e[u]){ int v = g.first; ll w = g.second; if (v == fa) continue; dfs(v , u); for (int i = 0 ; i \u003c= sz[u] + sz[v]; i++) tmp[i] = dp[u][i]; for (int i = 0 ; i \u003c= min(sz[u] , up) ; i++){ for (int j = 0 ; j \u003c= min(sz[v] , up) ; j++){ if (i + j \u003e up) continue; ll val = 1ll * j * (up - j) /*黑点*/ + 1ll * (sz[v] - j) * (n - sz[v] - (up - j)); val *= w; tmp[i + j] = max (tmp[i + j] , dp[u][i] + dp[v][j] + val); } } for (int i = 0 ; i \u003c= sz[u] + sz[v] ; i++) dp[u][i] = tmp[i]; sz[u] += sz[v]; } return ; } int main() { ios::sync_with_stdio(false); cin \u003e\u003e n \u003e\u003e up; for (int i = 1 ; i \u003c n ; i++){ int x , y , z; cin \u003e\u003e x \u003e\u003e y \u003e\u003e z; e[x].pb (mp(y , z)); e[y].pb (mp(x , z)); } dfs (1 , 0); cout \u003c\u003c dp[1][up] \u003c\u003c endl; return 0; } 总结：这题是一个基础的树上背包问题，但是找到突破口很重要，不然可能怎么树上dp都不知道，解决方式：多刷题 ","date":"2021-07-20","objectID":"/2021/07/%E6%A0%91%E5%BD%A2dp/:2:0","tags":["dp","树形dp"],"title":"树形dp总结","uri":"/2021/07/%E6%A0%91%E5%BD%A2dp/"},{"categories":["总结"],"content":"【例题2】P1272 重建道路 思路 根据树上背包模型可以想到状态定义：$dp[u][i]$表示以u结点为根结点的子树生成只有i个结点的最少去掉的边数，转移方程如下： $$ dp[u][i + j] = min{ dp[u][i] + dp[son][j]} $$ 这里有一个技巧，为了防止转移时覆盖，固用一个tmp函数存起计算的状态 其余需要注意的细节看代码注释 ac代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } #define ll long long using namespace std; const int M = 2e3 + 5; const int maxn = 2e3 + 5, maxm = 2e3 + 5; const int INF = 0x3f3f3f3f; int head[maxn], cnt; //初始化 void init() { memset(head, -1, sizeof head); cnt = -1; } struct edges { int to, next; }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v) { edge[++cnt] = {.to = v, .next = head[u]}; head[u] = cnt; } int dp[M][M], siz[M], tmp[M]; int n, m; void dfs(int u, int fa) { // 初始化，根据树形背包模型，一开始的只保留一个结点去掉的边数为0， 保留0个的去掉的边数是1，即拼接上去的那条边 siz[u] = 1, dp[u][1] = 0, dp[u][0] = 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; dfs(v, u); for (int j = 1; j \u003c= siz[u] + siz[v]; ++j) tmp[j] = INF; // 用一个tmp存计算的状态，防止转移覆盖原来需要用到的dp值 for (int j = 1; j \u003c= siz[u]; ++j) { // 当前树保证必须选一个 for (int k = 0; k \u003c= siz[v]; ++k) { // 子树从0开始 tmp[j + k] = min(tmp[j + k], dp[u][j] + dp[v][k]); } } siz[u] += siz[v]; for (int j = 1; j \u003c= siz[u]; ++j) dp[u][j] = tmp[j]; } } int main() { n = IO(), m = IO(); init(); for (int i = 1; i \u003c n; ++i) { int u = IO(), v = IO(); add(u, v), add(v, u); } memset(dp, 0x3f, sizeof dp); // 所有都初始化为最大值 dfs(1, -1); int ans = dp[1][m]; for (int i = 2; i \u003c= n; ++i) if(siz[i] \u003e= m) ans = min(ans, dp[i][m] + 1); // 最终的答案不一定是在1号结点上去边， +1是因为要加上去除连接父亲结点的边 printf(\"%d\", ans); return 0; } 总结：树上背包dp的时候无论是初始化还是转移的时候都需要树上背包模型为基础来考虑 ","date":"2021-07-20","objectID":"/2021/07/%E6%A0%91%E5%BD%A2dp/:3:0","tags":["dp","树形dp"],"title":"树形dp总结","uri":"/2021/07/%E6%A0%91%E5%BD%A2dp/"},{"categories":["总结"],"content":"【例题3】P1273 有线电视网 思路 这题想了好久，唯一想到比较有用的就是假设$dp[u][j]$表示以u为根结点的子树花费j元最多可以提供多少用户，然后就没有然后了，都不知道怎么转移，看了学长巨巨的思路后发现新大陆，原来还可以利用换意的方式进行dp，即转台这样定义：$dp[u][i]$表示以u为根结点的子树提供j个用户最多能赚多少钱，这样转移又方便，最后的答案就是$dp[1][i]$中大于等于0的最大i 转移方程： $$ dp[u][i + j] = max{ dp[u][i] + dp[son][j] - w} $$ 其余细节看代码注释 ac代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } #define ll long long using namespace std; const int M = 3e3 + 5; const int maxn = 3e3 + 5, maxm = 3e3 + 5; const ll inf = 0xffffffff; int head[maxn], cnt; //初始化 inline void init() { memset(head, -1, sizeof head); cnt = -1; } struct edges { int to, next; ll w; }edge[maxm \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v, ll w) { edge[++cnt] = {.to = v, .next = head[u], .w = w}; head[u] = cnt; } ll mon[M], sum, dp[M][M], son[M], tmp[M]; int n, m; void dfs(int u) { if (u \u003e n - m) son[u] = 1, dp[u][1] = mon[u]; // 如果是叶子节点则赚的钱就是他自己， 且叶子个数为1 dp[u][0] = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; dfs(v); for (int j = 1; j \u003c= son[u] + son[v]; ++j) tmp[j] = -inf; // 防止转移时覆盖，初始化tmp为负无穷，当然用01背包的方式逆向循环也可以 for (int j = 0; j \u003c= son[u]; ++j) { for (int k = 0; k \u003c= son[v]; ++k) { ll w = (k == 0 ? 0 : edge[i].w); // 如果子树一个叶子都不选当然不用减去子树的拼接边（回忆述树上背包模型） tmp[j + k] = max(tmp[j + k], dp[u][j] + dp[v][k] - w); } } son[u] += son[v]; for (int j = 1; j \u003c= son[u]; ++j) dp[u][j] = tmp[j]; } } int main() { n = IO(), m = IO(); init(); for (int i = 1; i \u003c= n - m; ++i) { int k = IO(); while (k--) { int a = IO(), c = IO(); add(i, a, c); } } memset(dp, 0xfe, sizeof dp); // 初始化为最小值 for (int i = n - m + 1; i \u003c= n; ++i) mon[i] = IO(); dfs(1); int ans = 0; for (int i = 1; i \u003c= m; ++i) { // printf(\"%lld\\n\", dp[1][i]); if (dp[1][i] \u003e= 0) ans = max(ans, i); // 寻找最大值i } printf(\"%d\", ans); return 0; } 总结：这题需要状态定义有点新奇，当定义状态时发现没办法转移或者是没办法存下这个状态就考虑换意一下 ","date":"2021-07-20","objectID":"/2021/07/%E6%A0%91%E5%BD%A2dp/:4:0","tags":["dp","树形dp"],"title":"树形dp总结","uri":"/2021/07/%E6%A0%91%E5%BD%A2dp/"},{"categories":["总结"],"content":"一、前言 本博客对ACM的常用的函数和c++STL做一个简单的总结 显然善用这些函数，可以对代码做大幅度地简化 本文主要对每个头文件/函数分常用和不常用做总结 注意：本博客只是针对编程竞赛中比较常用的用法，只是浅谈（因为用来打比赛够了），想要深入同学可以移步直接看c++官方提供的详细用法 用法：自己根据目录导航到自己想看的地方 ","date":"2021-07-19","objectID":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/:0:1","tags":["STL"],"title":"ACM常用C++stl总结","uri":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"二、一些非STL的常用函数 1. cstdio头文件 1.1 scanf函数（常用） 一个输入函数 基本形式为(以输入整数int型为例)，一般传入两个参数，第一个是格式化字符串，第二个是变量引用 int a, b, c; scanf(\"%d\", \u0026a);//输入一个 scanf(\"%d%d%d\", \u0026a, \u0026b, \u0026c);//输入多个 其中需要注意的是，逗号后面的必须传入的是需要输入的变量的地址，固一般在变量名前加一个\u0026（取地址符） 由于需要传入的是地址，固我们在输入数组时也可以这样做 int arr[10010]; for (int i = 0; i \u003c 10000; ++i) scanf(\"%d\", \u0026arr[i]);//常规输入 for (int i = 0; i \u003c 10000; ++i) scanf(\"%d\", arr + i);//和上面的是同理的 当然，还有一个特别需要注意的就是输入字符串 char str[110]; scanf(\"%s\", str);//下标从0开始的字符串 scanf(\"%s\", \u0026str[1]);//下标从1开始的字符串 一些小技巧 刷题的时候可能有些新手对下面类似这种输入很头痛 3 a 7 b 8 k 100 常规的做法就是开一个char数组，将字符当初字符串输入 char q[2]; int t, n; scanf(\"%d\", t); while (t--) { scanf(\"%s%d\", q, \u0026n); } 这种做法，在某些情况下可能还需要一个getchar()函数进行辅助（例如吃掉换行符），但下面这种做法，可以发挥出强大的scanf的优势。做法就是，他怎么样，在输入是就当成自己输出时会怎么样 char q; int t, n; scanf(\"%d\\n\", \u0026t);//加个换行符 while (t--) { scanf(\"%c %d\\n\", \u0026q, \u0026n); // 加个空格和回车符 } scanf的强大还远远不止这些，例如下面这个时间输入，做题时用到的只有数字，但题目偏偏有其他字符 12:30:22 和上面的同理，我们可以这样输入 int h, m, s; scanf(\"%d:%d:%d\", \u0026h, \u0026m, \u0026s); scanf函数返回的是输入变量的个数，若是无输入，则返回-1，固我们在遇到不定组输入时，scanf可以这样 int n; while (scanf(\"%d\", \u0026n) != -1) { //循环体 } 其余细节见printf函数内容 1.2 printf函数（常用） 与scanf相对，printf是c的一个输出函数 基本形式为(以整数int型为例)，第一个参数是格式化字符串，第二个是需要输出的变量 printf(\"%d\", n);//注意，没有取地址符号 关于printf的一般形式起始和scanf差不多，下面具体要扩展的是不同类型的格式化字符串（引号里的东东）和常见的输出格式 关于不同类型的格式化字符串（常用） 类型 int float double char char * long long 字符 %d %f %lf %c %s %lld 关于不同类型的格式化字符串（不常用） 类型 unsigned int unsigned long long long double size_t 无符型8进制 无符型16进制 字符 %u %llu %Lf %zu %o %x或%X 一些需要注意的 关于long long 好像对与不同的编译器使用的是不同的，但本人用%lld很少出问题 double 如果使用printf函数输出%lf和%f都是可以的，但是scanf必须严格区分 注意long double 的%Lf是大写的 对于不用的编译器size_t对应不同的类型 如果要输出%则打%%就行了 其实以上问题用c++中的cout和cin都可以解决 关于转义字符只需要知道换行符 \\n 便可以了，需要注意的是如果要输入反斜杠或者引号只需要在符号前多加一个反斜杠便可，例如 \\\\ 常用的输出格式 输出精度，自动四舍五入（常用） double x = 3.141592653; printf(\"%.3f\\n\", x); //输出3.142 printf(\"%.5f\\n\", x); //输出3.14159 输出格式每个整数占w格，右对齐，多得补0或者空格（默认是空格）（不常用） int x = 123; printf(\"%5d\\n\", x); //输出 123，默认补空格 printf(\"%05d\\n\", x); //输出00123, 补0 1.3 sscanf函数（不常用） sscanf函数虽然不怎么常用，但其功能也是十分黑科技，此函数在刷UVA的题时用得比较多，但依然这个函数不重要，知道以下用法便好 首先要知道的是，此函数的功能时将字符串中的数字读入至自己声明变量中去，使用方式和scanf十分类似，第一个参数是需要读的字符串，第二个参数是格式化字符串，第三个参数是需要写的变量引用 char str[] = \"x:200 y:100\"; int x, y; sscanf(str, \"x:%d y:%d\", \u0026x, \u0026y); printf(\"%d %d\\n\", x, y); // 输出200 100 1.4 sprintf函数（不常用） 和sscanf同理，用法和printf十分相似，第一个参数是需要写入的字符串，第二个是参数是格式化字符串，第三个参数是需要读的变量，看下面的例子 double PI = 3.1415926; char str[100]; sprintf(str, \"PI = %.3f\", PI); printf(\"%s\", str); // 输出 PI = 3.142 1.5 gets函数（部分不常用） 此函数由于其安全性低被淘汰了（读取一行字符串，不管自己申请的char字符串空间长度够不够都会一直读，直至遇到\\n换行符，还有就是其读取至换行符\\n停止，但好像Linux和Windows的换行符是不一样的），但是这些工程上的东西关我们打比赛的什么事呢？ 之所以说部分不常用是因为有些oj不给使用该函数了（例如洛谷），但还是有很多oj网站支持的，此函数读取字符串不仅速度快，而且能读一行，还是挺有用的 使用形式，传入需要读入的字符串头指针 char str[100]; gets(str); //读入字符串下标从0开始 gets(\u0026str[1]); //下标从1开始 gets(str + 1); //下标从1开始 还有一件事，此函数若读取成功则返回读入的字符串，否则返回NULL（不定组输入有用） 1.6 fgets函数（不常用） 据说此函数比较适合替代gets函数（个人觉得如果可以用gets用也是可以的），可能由于此函数需要的参数比较多，所以许多人不怎么喜欢在做题时使用他 常见形式，第一个参数是需要读入的字符串，第二个参数是需要读入的字符串的长度，第三个参数若没有特殊（读入文件）一般写stdin char str[110]; fgets(str, 110, stdin); 此函数的返回值和gets一样 2. cstring头文件 这个头文件中其实主要知道常用的函数便可以了，其余的想什么处理字符串拼接之类的，说实话如果不卡常，使用stl中的string巨香 2.1 memset函数（常用） memset通常用来初始化数组，需要注意的是他是按字节赋值的（下面会解释），时间复杂度为$O(n)$ 常见形式，第一个参数是需要初始化的数组首地址，第二个参数是初始化字节值，第三个参数是需要初始化的字节大小 memset(arr, val, sizeof arr); 对于上面的代码，若arr的类型为int，则它将会对arr进行字节赋值，就拿此arr来说，每一个arr元素都是一个int类型的变量，即每个元素占4个字节，memset后其每个元素就会变成val val val val的二进制形式，换句话说，若val = 1，则每个元素的二进制形式就会被初始化成 00000001 00000001 00000001 00000001 ，其最终结果就是16843009而不是1 固推荐刚入手的同学可以只将val设置成0(0), -1(-1)对常见的int、long long赋值，其中括号内表示memset后每个元素的值，对于bool类型，val可以设置成0(false),非0即其他数(true) 对于memset的其他进阶操作 首先要知道0x3f = 63，0x7f = 127，0x表示16进制 int类型（long long类型同理） memset(arr, 0x3f, sizeof arr);//每个元素赋值成0x3f3f3f3f，即1061109567，通常看成int的无穷大 memset(arr, 0x7f, sizeof arr);//每个元素赋值成0x7f7f7f7f，即2139062143，通常也看成int的无穷大，但没有上一条常用，原因在于2139062143过大，再做加法时容易爆int double类型（float类型同理） memset(arr, 0, sizeof arr);//每个元素都为0 memset(arr, 0x3f, sizeof arr); //每个元素都为0.0047,由于没有用处，固没用 memset(arr, 0x7f, sizeof arr); //浮点数的正无穷大，这个有用 那么怎么对一维数组指定个数进行memset呢，如下 memset(arr, val, sizeof(type) * num)","date":"2021-07-19","objectID":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/:0:2","tags":["STL"],"title":"ACM常用C++stl总结","uri":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"三、STL 1. 一些需要提前知道的知识 1.1 迭代器 迭代器是用来访问STL中的容器的工具，初学者把它理解成指针也可以 迭代器一般是c++11前用得比较多，但c++11更新了auto的用法后，迭代器逐渐没用了起来 这里提前利用后面要说到的set容器来演示迭代器的基础使用 #include \u003ccstdio\u003e#include \u003ciostream\u003e#include \u003cset\u003eusing namespace std; int main() { set\u003cint\u003e a = {4, 2, 3, 1, 5}; for (set\u003cint\u003e::iterator it = a.begin(); it != a.end(); ++it) { cout \u003c\u003c *it \u003c\u003c ' '; } return 0; } /* 输出： 1 2 3 4 5 */ 1.2 auto 神器 利用它可以大大简化你遍历STL容器的代码量 他的机制是由编译器自行判断用户定义的变量类型，由于过于香，本文后续访问、遍历、赋值会大量使用到auto，而且不难理解 基础用法，可以将上述迭代器的代码改进一下 #include \u003ccstdio\u003e#include \u003ciostream\u003e#include \u003cset\u003eusing namespace std; int main() { set\u003cint\u003e a = {4, 2, 3, 1, 5}; for (auto it = a.begin(); it != a.end(); ++it) { cout \u003c\u003c *it \u003c\u003c ' '; } return 0; } /* 输出： 1 2 3 4 5 */ 当然对于c++11，对于容器的遍历还提供了一种更加简便的方式（前提是该容器封装了begin和end） 还是上面的set #include \u003ccstdio\u003e#include \u003ciostream\u003e#include \u003cset\u003eusing namespace std; int main() { set\u003cint\u003e a = {4, 2, 3, 1, 5}; for (auto x : a) { cout \u003c\u003c x \u003c\u003c ' '; } } /* 输出： 1 2 3 4 5 */ 1.3 Lambda函数 前言：Lambda即匿名函数，对于匿名函数可能玩python比较熟悉，当然c++也有自己的一套Lambda玩法 一般形式： [] () -\u003e return_type {} 常见用处：最常见是用在sort的函数内（sort用法详见下文algorithm），对sort进行制定如何排序 int arr[5] = {3, 4, 2, 1, 7}; sort(arr, arr + 5, [] (int a, int b) { return a \u003e b; //从大到小排序 }); 下面介绍lambda的基础（其实会上面的就够了） 直接看先代码 #include \u003ccstdio\u003eusing namespace std; int main() { int a = 0, b = 1, c = 2, d = 3, e = 4; auto func = [\u0026, a, c](int x, int \u0026y)-\u003eint { b = 5, x = 6, y = 7; return a + b + c + x + y; }; puts(\"函数运行前：\"); printf(\"a = %d\\nb = %d\\nc = %d\\nd = %d\\ne = %d\\n\", a, b, c, d, e); printf(\"func(d, e) = %d\\n\", func(d, e)); puts(\"运行前：\"); printf(\"a = %d\\nb = %d\\nc = %d\\nd = %d\\ne = %d\\n\", a, b, c, d, e); return 0; } /* 输出： 函数运行前： a = 0 b = 1 c = 2 d = 3 e = 4 func(d, e) = 20 运行后： a = 0 b = 5 c = 2 d = 3 e = 7 */ 下面解释每个符号的含义 [] 是捕捉列表，用于捕捉父级的变量 [var]表示值传递方式捕捉变量var； [=]表示值传递方式捕捉所有父作用域的变量（包括this） [\u0026var]表示引用传递捕捉变量var [\u0026]表示引用传递方式捕捉所有父作用域的变量（包括this） [this]表示值传递方式捕捉当前的this指针 [=,\u0026a,\u0026b]表示以引用传递的方式捕捉变量a和b，以值传递方式捕捉其它所有变量 [\u0026,a,this]表示以值传递的方式捕捉变量a和this，引用传递方式捕捉其它所有变量 () 是传参列表，传入的参数规则和普通函数一样，值得注意的是如果什么都不传则可以省略这个传参列表 -\u003ereturn-type 是函数的返回类型，如果无返回或让编译器自己判断则可以省略 {} 是函数体，没什么好说的 2. vector 最常用的STl容器之一，对于新手你可以把他理解成一个数组，他能使用下标访问，能在尾部$O(1)$时间插入元素，固他是动态开辟空间的 头文件为#include \u003cvector\u003e 2.1 基础声明方式 #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int main() { // 直接声明元素类型为int的vector vector\u003cint\u003e v1; // 利用构造函数声明一个长度为5的vector， vector\u003cint\u003e v2(5); // 利用构造函数声明一个长度为5，所有值为1的vector vector\u003cint\u003e v3(5, 1); // 另一种声明方式 vector\u003cint\u003e v4 = {4, 5, 6, 7}; // 也可以这样 int b[4] = {1, 2, 3, 4}; vector\u003cint\u003e v5(b + 1, b + 4); // v5元素为 2， 3， 4 return 0; } 2.2 访问方式/遍历方式 最常用的访问方式就是下标访问 int main() { vector\u003cint\u003e v = {4, 5, 6, 7}; cout \u003c\u003c v[2] \u003c\u003c endl; // 输出6 return 0; } 遍历方式一般可以直接for int main() { vector\u003cint\u003e v = {4, 5, 6, 7}; for(int i = 0; i \u003c 4; ++i) { cout \u003c\u003c v[i] \u003c\u003c ' '; } // 输出为 4 5 6 7 return 0; } 当然也可以使用迭代器，这里推荐使用c++11提供的遍历方式，缺点就是没办法只得当前元素是第几个元素，但是方便 int main() { vector\u003cint\u003e v = {4, 5, 6, 7}; for (int x : v) { // 这里将 int 换成 auto是一样的，只是auto可以自动识别变量类型罢了 cout \u003c\u003c x \u003c\u003c ' '; } // 输出为 4 5 6 7 return 0; } 2.3 push_back和pop_back函数（常用） 分别用于在vector的尾部插入元素和删除与元素的函数，基本用法如下 int main() { vector\u003cint\u003e v = {4, 5, 6, 7}; v.push_back(3); // 往尾部插入3 v.push_back(2); // 往尾部插入2 for (int x : v) cout \u003c\u003c x \u003c\u003c ' '; // 输出：4 5 6 7 3 2 cout \u003c\u003c endl; v.pop_back(); // 删除最后一个元素 for (int x : v) cout \u003c\u003c x \u003c\u003c ' '; // 输出 4 5 6 7 3 return 0; } 2.4 size函数（常用） 返回当前vector的大小（长度） int main() { vector\u003cint\u003e v = {4, 5, 6, 7}; cout \u003c\u003c v.size() \u003c\u003c endl; // 输出4 v.push_back(3); cout \u003c\u003c v.size(); // 输出5 return 0; } 2.5 clear函数（常用） 将vector清空，时间为$O(1)$ int main() { vector\u003cint\u003e v = {4, 5, 6, 7}; cout \u003c\u003c v.size() \u003c\u003c endl; // 输出4 v.clear(); // 清空 cout \u003c\u003c v.size(); // 输出0 return 0; } 2.6 empty函数（不常用） 写法为v.empty()，若该vector为空则返回true，否则返回false 2.7 front和back函数（不常用） 分别返回vector头部和尾部元素的值 很多人不知道的是，其实他返回的是引用类型，这就意味着我们是可以通过该函数修改值的 vector\u003cint\u003e v = {4, 5, 6, 7}; cout \u003c\u003c v.front() \u003c\u003c ' ' \u003c\u003c v.back() \u003c\u003c endl; // 输出为4 7 v.front() = 1; // 将头部的元素修改为1 v.back() = 2; // 将尾部的元素修改为2 cout \u003c\u003c v.front() \u003c\u003c ' ' \u003c\u003c v.back() \u003c\u003c endl; // 输出为1 2 2.8 erase函数（不常用） 删除vector内部的元素 传入需要删除的起始指针和结束指","date":"2021-07-19","objectID":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/:0:3","tags":["STL"],"title":"ACM常用C++stl总结","uri":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"四、algorithm 1. sort 最最最常用的算法函数之一 其传参有两种 第一种：传入需要排序的数组的头的位置和尾的下一个位置指针 第二种：在第一种的前提下多一个比较函数 具体看代码 bool cmp(int a, int b) { return a \u003e b; } int main() { int arr[10] = {8, 7, 4, 2, 1, 3, 9, 10, 5, 6}; // 形式一 sort(arr, arr + 10); // 排序下标范围 [0, 10) // 形式二 sort(arr + 1, arr + 9, cmp); // 排序下标范围[1, 9), 用cmp函数比较，即降序排序 // 形式三 和形式二等价，只是用来lambda表达式罢了 sort(arr + 1, arr + 9, [](int a, int b) { return a \u003e b; }); // 形式四 和形式二等价，只是用了c++封装好的函数 sort(arr + 1, arr + 9, greater\u003cint\u003e()); // 降序 // 对于vector需要传入迭代器 vector\u003cint\u003e vt(arr, arr + 10); // 赋值为arr的元素 // 和上面的其实差不多 sort(vt.begin(), vt.end()); sort(vt.begin() + 1, vt.end() - 1, cmp); sort(vt.begin(), vt.end(), [](int a, int b) { return a \u003e b; }); sort(vt.begin(), vt.end(), less\u003cint\u003e()); //升序 return 0; } abs 返回一个数的绝对值（int、long long、 double） 2. min和max 用于比较两个同类型（注意是同类型）的最小值和最大值 在c++11中还提供了多个数一起比较大小 cout \u003c\u003c max({100, 99, 10, 1000}) \u003c\u003c endl; // 1000 cout \u003c\u003c min({100, 99, 10, 1000}) \u003c\u003c endl; // 10 3. swap 用于交换两个同类型（注意是同类型）的变量 4. reserve 用来翻转指定范围的数组，传参规则和sort第一种传参形式一样 5. lower_bound 用于查找一个有序序列指定范围内的第一个大于等于给定值的位置，返回的是指针或者迭代器，即如果是数组，找不到返回范围的尾部，容器则返回end() 时间复杂度为$O(logn)$ 如果是自己定义的类型，记得重写小于符号（那还不如自己手写二分呢） vector\u003cint\u003e vt = {0,2,4,6,8,10,12}; cout \u003c\u003c *lower_bound(vt.begin(), vt.end(), 3) \u003c\u003c endl; // 4 cout \u003c\u003c *lower_bound(vt.begin(), vt.end(), 4) \u003c\u003c endl; // 4 6. upper_bound 用于查找一个有序序列指定范围内的第一个大于给定值的位置，返回的是指针或者迭代器，即如果是数组，找不到返回范围的尾部，容器则返回end() 时间复杂度为$O(logn)$ vector\u003cint\u003e vt = {0,2,4,6,8,10,12}; cout \u003c\u003c *upper_bound(vt.begin(), vt.end(), 3) \u003c\u003c endl; // 4 cout \u003c\u003c *upper_bound(vt.begin(), vt.end(), 4) \u003c\u003c endl; // 6 7. unique 用于将去除一个有序序列中指定范围内的重复元素（实际没有去除）,返回去除后的尾指针 vector\u003cint\u003e vt = {0,0,2,2,4,4,6,6,8,8,10,10,10,12,12}; int index = unique(vt.begin(), vt.end()) - vt.begin(); cout \u003c\u003c index \u003c\u003c endl; // 7 8. next_permutation 用于将序列指定范围的序列排成下一个排列 具体用法比较模板化 int arr[3] = {1, 2, 3}; do { for (int i = 0; i \u003c 3; ++i) { cout \u003c\u003c arr[i]; } cout \u003c\u003c endl; } while (next_permutation(arr, arr + 3)); /* 输出： 123 132 213 231 312 321 */ 9. nth_element 一般用于获取序列（有序无序都可以）第n小的数 用法比较奇葩 时间复杂度接近$O(n)$ int arr[10] = {8, 7, 4, 2, 1, 3, 9, 10, 5, 6}; nth_element(arr, arr + 6, arr + 10); // 让 arr + 6这个位置的数就绪，即将第7大的数放到arr[6] // 即执行完后，arr + 6位置前的数都比他小，后面的数都不低于他 for (int x : arr) { cout \u003c\u003c x \u003c\u003c ' '; } cout \u003c\u003c endl; // 输出 6 5 4 2 1 3 7 8 10 9 cout \u003c\u003c arr[6] \u003c\u003c endl; // 获取排第7即位置6的数 输出 7 10. find 暴力查找一个序列中指定范围内的某个值第一次出现的位置，返回其位置的指针，若找不到返回尾指针 时间复杂度$O(n)$ 不重要，不细说 11. random_shuffle 一个用于随机打乱给定范围的序列 传入头指针和尾指针 ","date":"2021-07-19","objectID":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/:0:4","tags":["STL"],"title":"ACM常用C++stl总结","uri":"/2021/07/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"做题时的失误记录 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:0:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"提交前检查 提交之前人肉debug一下，最好自己造一下特殊的样例走一下 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:1:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"考虑dp的转移决策上 dp状态转移时要考虑好具体对应的决策，有时候并不是0和1的简单的两种决策 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:2:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"做图论题或者树论题数记得将邻接表初始化 记得在建边的时候要调用init函数初始化 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:3:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"注意数据范围 有时候wa可能是因为没注意到特殊的数据范围，所以要注意 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:4:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"程序比较大时，报错要从大到小排除找错误 当程序比较大的时候，报错了，可以利用注释法，先将大体的函数进行注释，最后一只缩小范围找出错误 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:5:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"思考问题的时候，当想到了一种解决办法，用纸记录关键的处理方式以免忘记 想到了一种方法不要急着码代码，先用纸记录一下关键处理方式，不然码代码的时候容易忘记 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:6:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"HDU 中 string需要string的头文件 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:7:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"状态转移时，需要滚动时，可以考虑用tmp数组复制再转移，这样就不用滚动了 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:8:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"当有查询操作时，可以优先考虑离线打表 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:9:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"线段树的lazy标记要符合定义，思考如何继承上一个结点的标记 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:10:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"当碰到有时间轴性质的题时，考虑优先利用某时间短或者长的 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:11:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"状态转移的tmp用法有两种，一种覆盖型，一种记录历史性，两种各有好处，哪个方便用哪个 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:12:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"dp利用到的信息必须是无后效性的、全局性的。如果不行则可以尝试开多一维使得转移好转，注意dp定义一般可以从计算当前决策的全局性贡献来思考 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:13:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"先思考最暴力的方式，再来思考怎么优化 ","date":"2021-07-19","objectID":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/:14:0","tags":null,"title":"失误录","uri":"/2021/07/%E5%A4%B1%E8%AF%AF%E5%BD%95/"},{"categories":["总结"],"content":"数位dp总结 ","date":"2021-07-19","objectID":"/2021/07/%E6%95%B0%E4%BD%8Ddp/:0:0","tags":["dp","数位dp"],"title":"数位dp总结","uri":"/2021/07/%E6%95%B0%E4%BD%8Ddp/"},{"categories":["总结"],"content":"数位dp思考形式与套路 对于区间的询问，一般利用的是前缀和的思想来求得答案 在求解答案时，一般是从高位到低位开始对答案进行累计 求解数位dp时，更像是在求解树上的信息 某一位中在未超过限制位的信息可提前预处理出来 值得注意的 大多数时候要记录前几位设置为最高数的信息 若到了最后一位并将其设置为最高数时还需要特判 0要根据题意思考是否需要特判 允许前导0和和非允许前导0是不一样的 一般递归版的数位dp求解代码 int num[100], dp[100]; int dfs(int indx, int limit, /*参数根据题意来添加*/) { if (indx == 0) { return 1;// 根据题意来返回 } int \u0026ref = dp[indx]; if (!limit \u0026\u0026 ref != -1) return ref; int res = 0; int up = (limit ? num[indx] : 9); for (int i = 0; i \u003c= up; ++i) { // 更新res dfs(indx - 1, limit \u0026\u0026 i == up); } if (!limit) ref = res; return res; } int solve(int x) { if (!x) return 1; // 根据题意来决定返回值 int len = 0; while (x) { num[++len] = x % 10; x /= 10; } return dfs(len, 1); } int main() { memset(dp, - 1, sizeof dp); // 此行省略读入 cout \u003c\u003c solve(r) - solve(l - 1) endl; } 一般递推版的数位dp求解代码 void prework() { // 对每一位未超过最高数时的信息进行预处理 } int solve(int x) { int num[10], len = 0, res = 0; // 不同题意res初始化不同，即一般是0算不算的区别 if (!x) return 1;// 返回什么根据题意来 while (x) { // 抠每一位出来 num[++len] = x % 10; x /= 10; } int last = 0; // 记录前几位需要信息，初始化根据题意来 for (int i = len; i \u003e= 1; --i) { for (int j = 0; j \u003c num[i]; ++j) { // 注意如果题目对前导0有要求可在第一位开始从1开始再到25行处处理第一位如果是0的情况 if (/*j 和 last放在一起不符合题意*/) continue; res += // 对每一位填未超过此位的数字时的答案进行累加，一般这里利用到prework预处理出来的东西 } // 来到这一步说明此位填num[i] if (/*此位填num[i]不符合题意*/) break; last += // 更新last if (last /*符合题意*/ \u0026\u0026 i == 1) { // 更新res } } for (int i = len - 1; i \u003e= 1; --i) { // 假设不能有前导0，则枚举从次高位开始到低位 for (int j = 1; j \u003c 10; ++j) { // 枚举每一位都放1~9 res += // 更新res } } return res; } int main() { prework(); // 此行省略读入 cout \u003c\u003c solve(r) - solve(l - 1) endl; } ","date":"2021-07-19","objectID":"/2021/07/%E6%95%B0%E4%BD%8Ddp/:0:1","tags":["dp","数位dp"],"title":"数位dp总结","uri":"/2021/07/%E6%95%B0%E4%BD%8Ddp/"},{"categories":["总结"],"content":"例题 LOJ 10166 数字游戏 递归写法 /* 由于科协里最近真的很流行数字游戏，某人又命名了一种取模数，这种数字必须满足各位数字之和 为 。现在大家又要玩游戏了，指定一个整数闭区间 ，问这个区间内有多少个取模数。 */ #include \u003ciostream\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccstring\u003e#include \u003ccctype\u003e#define ll long long #define pb push_back ll IO() { ll x = 0; int f = 0, c = getchar(); while (!isdigit(c)) { if (c == '-') f = 1; c = getchar(); } while (isdigit(c)) x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + c - '0', c = getchar(); return f ? -x : x; } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } using namespace std; const int N = 1e4 + 5, M = 1 \u003c\u003c 10; const ll mod = 1e9 + 7; int num[N], n; ll dp[20][101]; ll dfs(int x, int limit, int m) { ll \u0026res = dp[x][m]; if (!limit \u0026\u0026 ~res) return res; if (x == 0) return m == 0; ll sum = 0; int up = (limit ? num[x] : 9); for (int i = 0; i \u003c= up; ++i) { sum += dfs(x - 1, limit \u0026\u0026 i == up, (m + i) % n); } if (!limit) res = sum; return sum; } ll solve(ll x) { if (!x) return 1; int len = 0; while (x) num[++len] = x % 10, x /= 10; return dfs(len, 1, 0); } void problem(ll l, ll r) { n = IO(); memset(dp, -1, sizeof dp); print(solve(r) - solve(l - 1)); puts(\"\"); } int main() { int n = 1, l, r; while (~scanf(\"%d %d\", \u0026l, \u0026r)) problem(l, r); return 0; } 递推写法 #include \u003cbits/stdc++.h\u003e#define ll long long ll IO() { ll x = 0; int f = 0; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = 1; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + c - '0'; c = getchar(); } return f ? -x : x; } using namespace std; ll dp[110][110]; int num[110], l, r, n; int f(int x) { return (x % n + n) % n; } int solve(int x) { if (!x) return 1; int len = 0; while (x) { num[++len] = x % 10; x /= 10; } int last = 0, res = 0; for (int i = len; i \u003e= 1; --i) { for (int j = 0; j \u003c num[i]; ++j) { res += dp[i - 1][f(n - last - j)]; } last = (num[i] + last) % n; if (last == 0 \u0026\u0026 i == 1) res += 1; } return res; } void problem() { dp[0][0] = 1; for (int i = 1; i \u003c= 31; ++i) { for (int j = 0; j \u003c n; ++j) { dp[i][j] = 0; for (int k = 0; k \u003c 10; ++k) { // dp[i][j] += dp[i - 1][f(j + k)]; dp[i][j] += dp[i - 1][f(j - k)]; } } } printf(\"%d\\n\", solve(r) - solve(l - 1)); } int main() { #ifndef ONLINE_JUDGE freopen(\"D:/MYCODE/vsCode-c/test.in\", \"r\", stdin); freopen(\"D:/MYCODE/vsCode-c/test.out\", \"w\", stdout); #endif // int t = 1; while (~scanf(\"%d %d %d\", \u0026l, \u0026r, \u0026n)) { problem(); } return 0; } LOJ windy数 递归写法 #include \u003ciostream\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccstring\u003e#include \u003ccctype\u003e#define ll long long #define pb push_back ll IO() { ll x = 0; int f = 0, c = getchar(); while (!isdigit(c)) { if (c == '-') f = 1; c = getchar(); } while (isdigit(c)) x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + c - '0', c = getchar(); return f ? -x : x; } void print(ll x) { if (x \u003c 0) putchar('-'), x = -x; if (x \u003e 9) print(x / 10); putchar(x % 10 + '0'); } using namespace std; const int N = 1e4 + 5, M = 1 \u003c\u003c 10; const ll mod = 1e9 + 7; int num[N], n; ll dp[20][15], len; ll dfs(int x, int limit, int last) { if (x == 0) { return 1; } ll \u0026ref = dp[x][last], sum = 0; if (!limit \u0026\u0026 ~ref) return ref; int up = (limit ? num[x] : 9); for (int i = 0; i \u003c= up; ++i) { if (abs(last - i) \u003c 2) continue; sum += dfs(x - 1, limit \u0026\u0026 up == i, last == 12 \u0026\u0026 i == 0 ? 12 : i); } if (~limit) ref = sum; return sum; } ll solve(ll x) { if (!x) return 1; len = 0; while (x) num[++len] = x % 10, x /= 10; return dfs(len, 1, 12); } void problem(ll l, ll r) { memset(dp, -1, sizeof dp); // print(solve(r)); print(solve(r) - solve(l - 1)); } int main() { int n = 1, l, r; while (~scanf(\"%d %d\", \u0026l, \u0026r)) problem(l, r); return 0; } 递推写法 #include \u003ciostream\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccstring\u003e#include \u003ccctype\u003e#define ll long long #define pb push_back ll IO() { ll x = 0; int f = 0, c = getchar(); while (!isdigit(c)) { if (c == '-') f = 1; c = getchar(); } while (isdigit(c)) x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + c - '0', c = getchar(); return f ? -x : x; } void print(ll x) { if (x \u003c 0) p","date":"2021-07-19","objectID":"/2021/07/%E6%95%B0%E4%BD%8Ddp/:0:2","tags":["dp","数位dp"],"title":"数位dp总结","uri":"/2021/07/%E6%95%B0%E4%BD%8Ddp/"},{"categories":["总结"],"content":"网络流 ","date":"2021-05-26","objectID":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/:0:0","tags":["网络流"],"title":"网络流","uri":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"categories":["总结"],"content":"一、最大流 ","date":"2021-05-26","objectID":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/:1:0","tags":["网络流"],"title":"网络流","uri":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"categories":["总结"],"content":"Ekmonds-Karp 主要思想就是先找增广路，就是一个贪心的过程，注意这是带反悔的贪心，固要建立一个流为0的反边 时间复杂度$O(nm^2)$ bfs记录前驱的寻找增广路 因为要记录一个点的前驱，该方法一次只能找到一条增广路，具体细节看代码 #include \u003cqueue\u003ebool vis[maxn]; // 记录是否在队内 ll minc[maxn]; // 记录增广路的最小流 struct pairs { int u, i; } pre[maxn]; // 用来记录前驱结点 bool bfs(int s, int t, int n) { queue\u003cint\u003e q; for (int i = 0; i \u003c= n; ++i) vis[i] = false; q.push(s), vis[s] = true, minc[s] = inf; // 初始化minc为无穷大 while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (vis[v] || !edge[i].c) continue; vis[v] = true, pre[v] = {.u = u, .i = i}; //记录当前点的前驱点和当前点的内存池编号 minc[v] = min(minc[u], edge[i].c); // 更新最小流 if (v == t) return true; //找到了终点（汇点） q.push(v); } } return false; } EK核心代码 一直找前驱，然后减去增广路中的最小费用 ll EK(int s, int t, int n) { ll ans = 0, \u0026dif = minc[t]; // 引用到达汇点的最小费用 while (bfs(s, t, n)) { ans += dif; for (int i = t; i != s; i = pre[i].u) { edge[pre[i].i].c -= dif; // 正向边- edge[pre[i].i ^ 1].c += dif; // 反向边+ } } return ans; } 完整代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cqueue\u003eusing namespace std; #define ll long long #include \u003ccctype\u003einline long long IO() // 快读略 const int N = 205, M = 1e4 + 5; struct edges{ int to, next; ll cap, flow;// flow为记录当前路径流的流量，cap为容量 void add(int a, int b, ll c) { to = a, next = b; cap = c, flow = 0; } }; struct EK{ edges e[M]; const ll inf = 1e18; int head[N], cnt, n = 0, vis[N], pre[N];// vis记录是否在队内, pre记录前驱内存池编号 ll minc[N]; // 记录增广路的最小流 void init(int n) { this-\u003en = n, cnt = -1; fill_n(head, n + 1, -1); } void add(int u, int v, ll cap, int f = 1) { e[++cnt].add(v, head[u], cap); head[u] = cnt; if (f) add(v, u, 0, 0); } int bfs(int s, int t) { queue\u003cint\u003e q; for (int i = 0; i \u003c= n; ++i) vis[i] = 0, pre[i] = -1; q.push(s), vis[s] = 1, minc[s] = inf;// 初始化minc为无穷大 while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (vis[v] || e[i].cap == e[i].flow) continue; vis[v] = 1, pre[v] = i; minc[v] = min(minc[u], e[i].cap - e[i].flow);// 更新最小流 if (v == t) return 1;//找到了终点（汇点） q.push(v); } } return 0; } ll ek(int s, int t) { ll ans = 0, \u0026dif = minc[t]; while (bfs(s, t)) { ans += dif; for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { e[i].flow += dif; // 正向边flow+ e[i ^ 1].flow -= dif; // 反向边flow- } } return ans; } void clearflow() { for (int i = 0; i \u003c= cnt; ++i) e[i].flow = 0; } }ek; int main() { int n = IO(), m = IO(), s = IO(), t = IO(); ek.init(n); for (int i = 0; i \u003c m; ++i) { int u = IO(), v = IO(), cap = IO(); ek.add(u, v, cap); } printf(\"%lld\", ek.ek(s, t)); return 0; } ","date":"2021-05-26","objectID":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/:1:1","tags":["网络流"],"title":"网络流","uri":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"categories":["总结"],"content":"Dinic ek算法比较慢，原因在于每次只能找到一条增广路 dinic算法每次可以利用深度（bfs最近距离）找到多个增广路 复杂度$O(n^2m)$ bfs找多个增广路 利用$deep$数组记录每个点的距离源点的最近距离 #include \u003cqueue\u003eint deep[maxn], cur[maxn]; // bfs求增广路，一次求出多条增广路 bool bfs(int s, int t, int n) { queue\u003cint\u003e q; for (int i = 1; i \u003c= n; ++i) deep[i] = 0; deep[s] = 1; // 源点的深度为1 q.push(s); while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = edge[i].next) { const int \u0026v = edge[i].to; const ll \u0026c = edge[i].c; if (deep[v] || !c) continue; // 如果被遍历过，或者没有流量了 deep[v] = deep[u] + 1; q.push(v); } } return deep[t] != 0; } 递归在多个增广路上计算流 由于一次bfs能找到多条增广路，固可以用dfs对多条增广路同时计算流，这是dinic的核心 几个优化 当前弧优化：对于一条路被计算过后，后面的dfs时这条路就不会再进行对这条路进行计算了，例如$1 \\to 2 \\to 3$中当$1\\to 2$被计算过后，我们可以让$1\\to 3$这样 多路增广优化：普通的dinic一般都是一次bfs多次dfs，而利用多路增广的话就可以做到一次bfs一次dfs，做法就是记录后面的路总共的流再进行return流的总共的大小，这个优化较其他两个优秀 炸点优化：当一个点遍历完他的所有他的下一个节点，发现一条增广路都没有即nowflow = 0，则可以将这个点从图中去掉了，即deep[i] = -2 // 当前弧优化+多路增广优化+炸点优化 ll dfs(int u, int t, ll f) { if (u == t) return f; ll nowflow = 0; for (int i = cur[u]; ~i; i = edge[i].next) { cur[u] = i; // 当前弧优化 int \u0026v = edge[i].to; ll \u0026c = edge[i].c; if (deep[v] != deep[u] + 1 || !c) continue; if (ll low = dfs(v, t, min(f - nowflow, c))) { c -= low, edge[i ^ 1].c += low; nowflow += low;// 多路增广优化 if (nowflow == f) break; // 满流了 } } if (!nowflow) deep[u] = -2; // 炸点优化 return nowflow; } ll dinic(int s, int t, int n) { ll ans = 0; while (bfs(s, t, n)) { for (int i = 1; i \u003c= n; ++i) cur[i] = head[i]; // 预处理，方便当前弧优化 ans += dfs(s, t, inf); // 进过多路增广优化可不用循环 } return ans; } 完整代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cqueue\u003e#define ll long long using namespace std; #include \u003ccctype\u003einline long long IO() // 快读略 const int N = 205, M = 1e4 + 5; struct edges{ int to, next; ll cap, flow;// flow为记录当前路径流的流量，cap为容量 void add(int a, int b, ll c) { to = a, next = b; cap = c, flow = 0; } }; struct Dinic { edges e[M]; const ll inf = 1e18; int head[N], cnt, n = 0, deep[N], cur[N]; void init(int n) { this-\u003en = n, cnt = -1; fill_n(head, n + 1, -1); } void add(int u, int v, ll cap, int f = 1) { e[++cnt].add(v, head[u], cap); head[u] = cnt; if (f) add(v, u, 0, 0); } // bfs求增广路，一次求出多条增广路 int bfs(int s, int t) { queue\u003cint\u003e q; fill_n(deep, n + 1, 0); deep[s] = 1, q.push(s); while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (deep[v] || e[i].cap == e[i].flow) continue; deep[v] = deep[u] + 1; q.push(v); } } return deep[t] != 0; } ll dfs(int u, int t, ll flow) { if (u == t) return flow; ll nowflow = 0; for (int i = cur[u]; ~i; i = e[i].next) { cur[u] = i;// 当前弧优化 int v = e[i].to; if (deep[v] != deep[u] + 1 || e[i].cap == e[i].flow) continue; if (ll low = dfs(v, t, min(flow - nowflow, e[i].cap - e[i].flow))) { e[i].flow += low, e[i ^ 1].flow -= low; nowflow += low;// 多路增广优化 if (nowflow == flow) break; } } if (!nowflow) deep[u] = -2;// 炸点优化 return nowflow; } ll dinic(int s, int t) { ll ans = 0; while (bfs(s, t)) { for (int i = 0; i \u003c= n; ++i) cur[i] = head[i];// 预处理，方便当前弧优化 ans += dfs(s, t, inf);// 进过多路增广优化可不用循环 } return ans; } void clearflow() { for (int i = 0; i \u003c= cnt; ++i) e[i].flow = 0; } }dinic; int main() { int n = IO(), m = IO(), s = IO(), t = IO(); dinic.init(n); for (int i = 0; i \u003c m; ++i) { int u = IO(), v = IO(); ll c = IO(); dinic.add(u, v, c); } printf(\"%lld\", dinic.dinic(s, t)); return 0; } ","date":"2021-05-26","objectID":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/:1:2","tags":["网络流"],"title":"网络流","uri":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"categories":["总结"],"content":"二、最小费用最大流 最小费用最大流，我发现如果是普通的更改dinic会退化到比ek的复杂度还大（可能是我太菜了） 计算mcmf只要将计算最大流中寻找增广路的bfs修改成寻找最短路的就可以了（好像有个公式可以证明的） 注意：存图的反向图的边的流必须是0，同时它的费用必须是正向边的费用的相反数 ","date":"2021-05-26","objectID":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/:2:0","tags":["网络流"],"title":"网络流","uri":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"categories":["总结"],"content":"EK版 直接将ek中的bfs换成spfa就好了 完整代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cqueue\u003eusing namespace std; #define ll long long #include \u003ccctype\u003einline long long IO() // 快读代码略 const int N = 410, M = 2e5 + 5; struct edges { int to, next; ll cap, cost, flow; void add(int a, int b, ll c, ll d) { to = a, next = b; cap = c, cost = d, flow = 0; } }; struct MCMF{ const ll inf = 1e15; int head[N], pre[N], cnt, n, inq[N]; ll maxflow, mincost, dist[N]; edges e[M]; void add(int u, int v, ll cap, ll cost, int f = 1) { e[++cnt].add(v, head[u], cap, cost); head[u] = cnt; if (f) add(v, u, 0, -cost, 0);// 建立反向弧，费用相反 } int spfa(int s, int t) {// 利用spaf找最小费用的路，即最短路 for (int i = 0; i \u003c= n; ++i) inq[i] = 0, dist[i] = inf, pre[i] = -1; queue\u003cint\u003e q; inq[s] = 1, q.push(s), dist[s] = 0; while (q.size()) { int u = q.front(); q.pop(); inq[u] = 0; for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; ll \u0026cost = e[i].cost; if (dist[v] \u003e dist[u] + cost \u0026\u0026 e[i].cap \u003e e[i].flow) { dist[v] = dist[u] + cost; pre[v] = i;//记录当前点的前驱的内存池编号 if (inq[v]) continue; inq[v] = 1 , q.push(v); } } } return pre[t] != -1;// 如果说t没有前驱则说明找不到增广路了 } void mcmf(int s, int t) { maxflow = mincost = 0; while (spfa(s, t)) { ll low = inf; for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { low = min(low, e[i].cap - e[i].flow);//寻找最小流 } for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { e[i].flow += low; e[i ^ 1].flow -= low; mincost += low * e[i].cost; } maxflow += low; } } void init(int n) { cnt = -1, this-\u003en = n; fill_n(head, n + 1, -1); } void clearflow() { for (int i = 0; i \u003c= cnt; ++i) e[i].flow = 0; } }mcmf; int main() { int n = IO(), m = IO(); mcmf.init(n); for (int i = 0; i \u003c m; ++i) { int u = IO(), v = IO(); ll cap = IO(), cost = IO(); mcmf.add(u, v, cap, cost); } mcmf.mcmf(1, n); printf(\"%lld %lld\", mcmf.maxflow, mcmf.mincost); return 0; } ","date":"2021-05-26","objectID":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/:2:1","tags":["网络流"],"title":"网络流","uri":"/2021/05/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"categories":["总结"],"content":"dsu 树上启发式合并 刷题 ","date":"2021-05-12","objectID":"/2021/05/dsu%E5%88%B7%E9%A2%98/:0:0","tags":["dsu"],"title":"树上dsu总结","uri":"/2021/05/dsu%E5%88%B7%E9%A2%98/"},{"categories":["总结"],"content":"套路代码 int son[M], dep[M], siz[M]; // son记录重儿子 // 寻找重儿子 void dfs(int u, int fa) { siz[u] = 1; dep[u] = dep[fa] + 1; // 记录深度，有些题不需要 for (/*遍历下一个结点*/) { v = /*下一个结点*/; if (v == fa) continue; dfs(v, u); siz[u] += siz[v]; if (siz[v] \u003e siz[son[u]]) son[u] = v; } } int flag; void cal(int u, int fa, int k) { // 计算 // 遍历孩子，并利用 flag 避开重儿子 } void dsu(int u, int fa, int keep) { for (/*遍历下一个结点*/) { v = /*下一个结点*/; if (v != fa \u0026\u0026 v != son[u]) dfs(v, u, 0); } if (son[u]) dfs(son[u], u, 1), flag = son[u]; // 如果存在重儿子 cal(u, fa, 1); // 计算 if (flag) flag = 0; if (!keep) cal(u, fa, -1); //删除 } ","date":"2021-05-12","objectID":"/2021/05/dsu%E5%88%B7%E9%A2%98/:1:0","tags":["dsu"],"title":"树上dsu总结","uri":"/2021/05/dsu%E5%88%B7%E9%A2%98/"},{"categories":["总结"],"content":"例题 ","date":"2021-05-12","objectID":"/2021/05/dsu%E5%88%B7%E9%A2%98/:2:0","tags":["dsu"],"title":"树上dsu总结","uri":"/2021/05/dsu%E5%88%B7%E9%A2%98/"},{"categories":["总结"],"content":"CF570D Tree Requests /* 题意： 有一棵 个结点的以 11 号结点为根的有根树。 每个结点都有一个颜色，颜色是以编号表示的，ii 号结点的颜色编号为 cici 如果一种颜色在以 xx 为根的子树内出现次数最多，称其在以 xx 为根的子树中占主导地位。 显然，同一子树中可能有多种颜色占主导地位。 你的任务是对于每一个 i∈[1,n]i∈[1,n]，求出以 ii 为根的子树中，占主导地位的颜色的编号和。 N\u003c=105,ci\u003c=n */ #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#define ll long long #define rep(u, v, e) for (int i = head[u], v = e[i].to; ~i; i = e[i].next, v = e[i].to) using namespace std; const int N = 1e5 + 5, M = 2e5 + 5; int head[N], cnt; //初始化 void init() { memset(head, -1, sizeof head); cnt = -1; } struct edges { int to, next; int w; void add(int t, int n, int w) { to = t, next = n, this-\u003ew = w; } }edge[N \u003c\u003c 1]; //无向图则需要乘2 inline void add(int u, int v, int w = 1) { edge[++cnt].add(v, head[u], w); head[u] = cnt; } int son[N], siz[N]; void dfs(int u, int fa) { siz[u] = 1; rep(u, v, edge) { if (v == fa) continue; dfs(v, u); siz[u] += siz[v]; if (siz[v] \u003e siz[son[u]]) son[u] = v; } } ll col[N], ans[N], flag, num[N], now, sum, tot; void cal(int u, int fa, int k) { num[col[u]] += k; if (k \u003e 0) { if (num[col[u]] == tot) sum += col[u]; else if (num[col[u]] \u003e tot) tot = num[col[u]], sum = col[u]; } rep(u, v, edge) { if (v == fa || v == flag) continue; cal(v, u, k); } } void dsu(int u, int fa, int keep) { rep(u, v, edge) { if (v == fa || v == son[u]) continue; dsu(v, u, 0); } if (son[u]) dsu(son[u], u, 1), flag = son[u]; now = u; cal(u, fa, 1); ans[u] = sum; if (flag) flag = 0; if (!keep) cal(u, fa, -1), tot = 0; } int main() { int n; scanf(\"%d\", \u0026n); init(); for (int i = 1; i \u003c= n; ++i) scanf(\"%lld\", col + i); for (int i = 1; i \u003c n; ++i) { int u, v; scanf(\"%d %d\", \u0026u, \u0026v); add(u, v), add(v, u); } dfs(1, 0); dsu(1, 0, 1); for (int i = 1; i \u003c= n; ++i) printf(\"%lld \", ans[i]); return 0; } 反思：本题第二次做，sum值必须要开全局且是单值，而不是数组（即记录每个节点的答案），而是如代码所示的做法，直接用ans在dsu内复制，用sum值不开数组开全局的好处就是会一直保留重儿子的信息‘ ","date":"2021-05-12","objectID":"/2021/05/dsu%E5%88%B7%E9%A2%98/:2:1","tags":["dsu"],"title":"树上dsu总结","uri":"/2021/05/dsu%E5%88%B7%E9%A2%98/"},{"categories":["总结"],"content":"CF570D Tree Requests /* 给定一个以1为根的n个节点的树，每个点上有一个字母(a−z) 每个点的深度定义为该节点到1号节点路径上的点数. 每次询问 a,b， 查询以 a 为根的子树内深度为 b 的节点上的字母重新排列之后是否能构成回文串. */ ","date":"2021-05-12","objectID":"/2021/05/dsu%E5%88%B7%E9%A2%98/:2:2","tags":["dsu"],"title":"树上dsu总结","uri":"/2021/05/dsu%E5%88%B7%E9%A2%98/"},{"categories":["总结"],"content":"背包问题总结 本文从dp总结中搬出 背包问题是一类非常经典的动规问题，包括了01背包、完全背包、多重背包、混合背包、二维费用背包、分组背包、有依赖的背包问题、背包问题求方案数、背包问题求具体方案（称为背包九讲） 本片博客会在个人觉得比较重要的地方上啰嗦qwq ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:0:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"01背包 最最经典的背包问题，背包九讲中说到：“它包含了背包问题中设计状态、方程的最基本思想。另外，别的类型的背包问题往往也可以转换成01 背包问题求解。”，固01背包的模型是非常重要的 下面的01背包会展示三种空间的优化手段，我发现这三种优化手段都是非常重要的，针对不同场景三种手段各有优势 直接看到最原汁原味的题 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:1:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题1】AcWing 2. 01背包问题 题意不多说，就是原汁原味的01背包题，值得说的是以下内容均以V为容量，W为价值，c为背包总容量 分析1: 对于每个物品有选和不选的两种决策，固我们可以从dfs的角度加上记忆化来思考这道题 可以考虑每一层都代表一个物品，有选和不选两种方案，意味着有两个递归下去的道路 其余细节具体看代码 //调用时直接调用dfs(n, m)就好了 int dfs(int nums, int sum) {//第nums个物品，还剩下sum的容量， if (nums == n + 1) return 0; // 边界 if (vis[nums][sum]) return dp[nums][sum]; // 记忆化 vis[nums][sum] = true; int \u0026ans = dp[nums][sum]; ans = dfs(nums + 1, sum); //不选当前的物品，则容量依旧还剩sum if (sum \u003e= v[nums]) ans = max(ans, dfs(nums + 1, sum - v[nums]) + w[nums]); // 如果容量够，则选当前物品，则容量剩余sum - v[nums] return ans; } 可以看得出来，dfs+记忆化的好处就是简单易懂，似乎完全不用过多说明代码的意义 分析2： 本题递归+记忆化的好处就是易于思考，不需要过多地打草稿 但考虑到01背包经典性和别的背包问题都可以转换成01背包来解决，所以只会递归是不够的 根据上述分析1的内容，可以很容易定义状态：设dp[i][j]为决策到第i个物品时，还剩j容量的储存的最大价值 根据分析1的代码不难得出状态转移方程 $$ dp[i][j] = max\\lbrace dp[i + 1][j], \\ \\ dp[i + 1][j - v[i]] + w[i]\\rbrace \\ \\ (j \u003e= v[i]) $$ 递推部分代码如下，答案为dp[1][m] for (int i = n; i \u003e= 1; i--){ for (int j = 0; j \u003c= m; j++) { dp[i][j] = dp[i + 1][j]; // 不选 if (j \u003e= v[i]) dp[i][j] = max(dp[i][j], dp[i + 1][j - v[i]] + w[i]); // 选，前提是空间够 } } 其实从第1件物品开始也是一样的 输出答案为dp[n][m] for (int i = 1; i \u003c= n; i++) { for (int j = 0; j \u003c= m; j++) { dp[i][j] = dp[i - 1][j]; if (j \u003e= v[i]) dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]); } } 上面这个代码比逆着来递推的好处就是可以边读边计算，剩下了一些空间 for (int i = 1; i \u003c= n; i++) { scanf(\"%d%d\", \u0026v, \u0026w); for (int j = 0; j \u003c= m; j++) { dp[i][j] = dp[i - 1][j]; if (j \u003e= v) dp[i][j] = max(dp[i][j], dp[i - 1][j - v] + w); } } 复杂度都是$O(nm)$ 空间优化1： 不难发现，当遍历到第$i$个物品时（顺着来递推），它利用到的状态只有上一个物品的状态，即第i - 1个物品的状态，则这个第一维完全可以用滚动数组来优化，即优化成$2 * Maxn$的数组 直接看代码 #include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; const int Maxn = 1010; int n, m, dp[2][Maxn] = {0}; int main() { scanf(\"%d%d\", \u0026n, \u0026m); int now = 1, pre = 0; // 一个本状态，一个上一个状态 for (int i = 1; i \u003c= n; i++) { int v, w; scanf(\"%d%d\", \u0026v, \u0026w); fill_n(dp[now], dp[now] + m + 1, 0); // 这句话就01背包而言可以不用加，但在其他动规问题时可能就必须初始化了 for (int j = 0; j \u003c= m; ++j) { dp[now][j] = dp[pre][j]; if (j \u003e= v) dp[now][j] = max(dp[now][j], dp[pre][j - v] + w); } swap(pre, now); // 滚动 } printf(\"%d\", dp[pre][m]); // 答案是推出循环后的pre维数组里的答案 return 0; } 这种写法的好处就是当我们在处理动规时发现他的只和上一个状态有关时就可以用这种优化，注意第19行的初始化有时候是必加的，例如在计数类dp中，我们就必须初始化当前计算的数组（即当前循环的now维数组）为0 下面两种优化个人感觉比本空间优化1要重要 空间优化2 根据空间优化1， 我们再来看他的第二维，它会利用到$j - v[i]$的状态，计算完成后$j - v[i]$的状态就没用了 综上，看图 所以完全可以将二维优化成一维的数组，为了保持$j - v[i]$是上一个物品的状态，第二层递推时要逆着过来递推 状态转移方程如下 $$ dp[j] = max(dp[j],\\ \\ dp[j - v] + w) $$ 上述的状态方程是对应边读边计算的 最终代码如下 #include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; const int Maxn = 1010; int n, m, dp[Maxn] = {0}; int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { int v, w; scanf(\"%d%d\", \u0026v, \u0026w); for (int j = m; j \u003e= v; j--) { dp[j] = max(dp[j], dp[j - v] + w); } } printf(\"%d\", dp[m]); return 0; } 说明：这里的二层循环是m到v，一来是因为j要大于等于v数组才有意义，二来是因为最开始是从c到0时，当$j \u003c v$时只有不选当前物品的选择，则状态就会继承自一个物品此时的容量的状态，而此时代码是m到v默认了$j \u003c v$时的状态时继承自上一个物品同容量的状态 本优化多用于分组背包中空间优化，树形背包（有依赖的背包），记住子问题是01背包时，一维空间优化必须逆着来（有基础的同学可以回忆一下树形背包中的转化 空间优化3 下面介绍个人认为最最有用的空间优化手段 先来说说第一种空间优化的好处：好理解，不必像第二种空间优化那样需要逆着过来更新状态（相信我，考虑循环的顺逆，在比赛时真的可以把自己搞晕） 然而第一种空间优化也是有缺陷的：维度依然没有变化，即本来是二维的还是二维（这样的坏处就是多维时比较折磨人，想想树形背包，我们之所以可以用在定义状态时只开二维，是因为利用到了01背包一维优化的思想，更新时是逆着更新的，若要顺着更新，则可能会退化到三维，哪怕你第三位用滚动数组优化（第一种优化）可能也会被pre和now维度下标弄晕） 而第二种空间优化的好处和缺陷正好是第一种空间优化的缺陷和好处 综上，接下来要推出一个能集合上面两种优化的好处的优化手段 先看代码，感觉看了代码就能秒懂了 #include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; const int Maxn = 1010; int n, m, dp[Maxn] = {0}, tmp[Maxn]; int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { int v, w; scanf(\"%d%d\", \u0026v, \u0026w); for (int j = 0; j \u003c= m; ++j) tmp[j] = dp[j]; // 用tmp数组存起上一次的状态 for (int j = 0; j \u003c= m; ++j) { dp[j] = tmp[j]; // 这句话可以不加，具体问题具体分析吧 if (j \u003e= v) dp[j] = max(dp[j], tmp[j - v] + w); } } printf(\"%d\", dp[m]); return 0; } 当然还有另一种写法 #include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; const int Maxn = 1010; int n, m, dp[Maxn] = {0}, tmp[Maxn]; int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { int v, w; scanf(\"%d%d\", \u0026v, \u0026w); for (int j = 0; j \u003c= m; ++j) tmp[j] = 0; // 用tmp数组来装本次要更新的状态，初始化具体问题具体分析，例如dp找到是最大值","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:1:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"完全背包 紫书是先说完全背包问题的，紫书是从完全背包来引入背包问题的，可能是因为完全背包和硬币模型十分相似，都是DAG模型的题，和硬币模型最明显不同的是硬币模型起点和终点都是固定的，而完全背包是起点固定，终点任意的题 直接看例题 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:2:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题1】AcWing 3. 完全背包问题 完全背包的裸题，题意就不再赘述了 分析方式1： 刚刚说了，完全背包和无限硬币模型（硬币无限个，问你能否组成特定的面值）相似，只不过呢和硬币模型DAG有两个不同的地方，一是硬币模型的起点是要求的面值和，终点是0，而完全背包的DAG的起点是要求的背包总容量，而终点是任意的；二是硬币模型的边权是1，而完全背包问题的边权是对应物品的价值，固之前硬币问题中的“+1”就要变成“+w[i]”了 回忆一下硬币模型的状态定义：dp[i]表示面值为i的最大（最小）凑的数量，转移方程是：$dp[i] = max \\lbrace dp[i - coin[j]] \\rbrace + 1, \\ \\ i \\ge coin[j]$，其中除dp[0]为0外，其余都初始化为$-∞$ 上面说过，硬币模型的DAG终点是0，但完全背包问题的终点是任意的，固完全背包应该对所有dp值都初始化为0（这个和01背包中的不超过容量m和恰好容量是m的道理是一样的），不难得出完全背包的转移方程 $$ dp[i] = max\\lbrace dp[i - v[j]]\\ \\ +\\ \\ w[j]\\rbrace ,\\ \\ i \\ge v[j] $$ 和硬币模型差不多其中dp[i]表示容量为i的背包能装的最大价值，输出答案为dp[m] 代码如下 memset(dp, 0, sizeof dp); for (int i = 0; i \u003c= m; i++) { // 面值 对应完全背包的背包容量 for (int j = 1; j \u003c= n; j++) { // 硬币 对应完全背包的物品 if (i \u003e= v[j]) dp[i] = max(dp[i], dp[i - v[j]] + w[j]); } } 以上代码是仿照凑硬币模型写的，第一层循环和第二层循环是完全可以对调的 memset(dp, 0, sizeof dp); for (int j = 1; j \u003c= n; j++) { for (int i = 0; i \u003c= m; i++) { if (i \u003e= v[j]) dp[i] = max(dp[i], dp[i - v[j]] + w[j]); } } 注意到，上面的代码第二层循环的起点完全可以改成从v[j]到m，然后if语句就可以删去了 至于最终答案也是dp[m] memset(dp, 0, sizeof dp); for (int j = 1; j \u003c= n; j++) { for (int i = v[j]; i \u003c= m; i++) { dp[i] = max(dp[i], dp[i - v[j]] + w[j]); } } 时间复杂度为O(mn) 对于并非第一次接触完全背包的同学，是不是觉得上面的代码很像最终学到的代码呢，没错，上面的代码就是即将进入的分析方式2的最终结论 此时比较乱的同学可能有疑惑，第二重循环能否逆着来呢，答案是不行，细心的同学可能发现了，如果逆着过来就是01背包了 那么为什么不行呢，其实很简单，回到最开始完全背包的代码甚至是硬币模型的代码，我们是从0开始一步一步递推到最终目标m的，这样能推出最终答案，仔细想想也是，怎么可能是先从目标c开始推呢？ 分析方式2： 对于完全背包，上面的分析1完全是够用的，但是就以背包问题而言，这样是不够的 考虑这么一个物品，其重量为v[i]，则它最多只能装m/v[i]个，这个很重要，这个结论意味着完全背包可以转换成01背包来做 将每个无限个的物品看成有限的m/v[i]个，然后当成01背包来做，设dp[i][j]表示对于第i件物品，容量为j转移方程如下 $$ dp[i][j] = max\\lbrace dp[i - 1][j],\\ \\ dp[i - 1][j - k \\times v[i]] + k \\times w[i]\\rbrace \\ \\ k = 1, 2, 3, 4 \\cdots $$ 其中k = 0时就是dp[i - 1][j]，这个转移方程之所以这么写是为了对应01背包的转移方程 相应的代码如下 memset(dp, 0, sizeof dp); for (int i = 1; i \u003c= n; i++) { for (int j = 0; j \u003c= m; j++) { dp[i][j] = dp[i - 1][j]; // 不选 for (int k = 1; k * v[i] \u003c= m; k++) { //选 if (j \u003e= k * v[i]) dp[i][j] = max(dp[i][j], dp[i - 1][j - k * v[i]] + k * w[i]); } } } 时间复杂度为O($m n\\times \\frac{m}{v[i]}$) 很遗憾TLE了，对转移方程做一下变换 $$ dp[i][j] = max\\lbrace dp[i - 1][j], dp[i][j - v[i]] + w[i]\\rbrace $$ 解释：将每种无限的物品看成一个一个的，当不选这种物品时，则决策为上一种物品容量相同时的状态，当选这一种物品的一个时，其由同种物品的$j - v[i]$的容量转移过来 换句话说：如果我选当前物品，则应该是当前物品背包容量还剩$j - v[i]$加上当前物品的价值，即我选了当前物品我还能继续考虑是否选当前物品 状态定义是不变的代码如下 for (int i = 1; i \u003c= n; i++) { for (int j = 0; j \u003c= m; j++) { dp[i][j] = dp[i - 1][j]; // 不选 if (j \u003e= v[i]) dp[i][j] = max(dp[i][j], dp[i][j - v[i]] + w[i]); //选 } } 时间复杂度为O(nm)，这回Ac了 但同样是转换成01背包，为什么这个转移方程复杂度就降得如此低呢？说起来有点绕，如果下面解释完了还没明白可以自己草稿模拟两个代码或者一层一层递推状态方程，找到区别 假设我们考虑到dp[i][j]时，对于复杂度为O(cn)的转移，dp[i][j]由两个状态转移而来 一是dp[i - 1][j]，表示不选当前物品，状态来自上一种物品的同容量状态 二是dp[i][j - v[i]] + w[i]，表示选当前物品，状态来自同种物品，小v[i]容量的状态而来 根据动态规划的原则，上一个状态一定是计算好并且是当前最优解的值 而对于复杂度为O($m n\\times \\frac{m}{v[i]}$)的话，dp[i][j]则由多个状态而来 基本都是由上一种物品对应$j - k \\times v[i]$容量的状态而来，即$dp[i - 1][j - k \\times v[i]] + k \\times w[i]$ 注意到在复杂度为O($m n\\times \\frac{m}{v[i]}$)中计算dp[i][j]时，用到了一个状态就是dp[i - 1][j - 2 $\\times$ v[i]]，而我们在计算dp[i][j - v[i]]时也用到了dp[i - 1][j - k $\\times$ v[i]]这个状态，假设dp[i][j-v[i]]的最终值就是来自于dp[i - 1][j - t $\\times$ v[i]]，则dp[i][j]就相当于也利用到了$dp[i][j - v[i]]$的值，固可以把众多的[i - 1]的状态归纳为[i]，其余的便可以反推归纳为dp[i - 1][j] 真相已经浮出水面了：在复杂度为O(mn)的算法里dp[i][j - v[i]]的值可能本来就包含了（装了）若干个值为v[i]的物品，这就避免了复杂度为O($m n\\times \\frac{m}{v[i]}$)算法中许多的max计算 再来说说完全背包的空间优化 和01背包一样，可以把二维优化成一维的，但值得注意的是：j - v[i]的第一维是i，和01背包的i - 1不同，固它用的不是上一层的数据，而是刚更新的同层的下标在j之前的数据，所以第二层于01背包不同，要顺着遍历，即从小到达遍历 代码与分析1中的最终代码是一样的 memset(dp, 0, sizeof dp); for (int j = 1; j \u003c= n; j++) { for (int i = v[j]; i \u003c= m; i++) { dp[i] = max(dp[i], dp[i - v[j]] + w[j]); } } 一个重要的优化 对于0(mn)的复杂度应该说是非常优秀的了，但是O($m n\\times \\frac{m}{v[i]}$)在不换转移方程的思路下还是有别的优化方式的，能优化到O($nmlog\\frac{m}{v[i]}$) 采用一种二进制的方式优化 考虑这么一个数10，现在要你拆分成几个数，使得能够用这些数自由组合能够组合成和为1~10的数。最简单的方式就是把10拆成10个1，就能将1~10都能凑出来了 但是如果只拆成10个1就没有优化的意义了，现在要你拆分成最少的数使得自由组合能凑成1~10的数，有一种比较优秀的拆分方式，拆分的结果为：1，2，4，3；怎么分的？观察到第一个数是$2^0$，后面除了最后一个数依次是$2^1、2^2$，最后一个数是$10 - 2^0 - 2^1 - 2^2 = 3$得到的 这样做的好处是，这4个数，每个数只有选和不选两种选择，一次对应4个位数的二进制的数，例如0101就是选了2，3，于是就凑成了5 原话是这么说的：“这是二进制的思想。因为，不管最优策略选几件第i 种物品，其件数写成二进制后，总可以表示成若干个","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:2:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"多重背包 和01背包不同，01背包是每个物品都只有一个，但多重背包的每个物品都有若干个 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:3:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题1】AcWing 4. 多重背包问题 I 题意不多讲，但是值得一提的是，多重背包被分为了三种等级，对应的数据范围不同，本题数据范围是三种之中最小的 分析： 当成完全背包里的分析方式2一开始介绍的思路来做，每个物品有$s_i$个，只需改一下第三重循环便可 下面的代码顺便把空间也优化了 #include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; const int Maxn = 110; int n, m, dp[Maxn]; int main () { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { int v, w, s; scanf(\"%d%d%d\", \u0026v, \u0026w, \u0026s); for (int j = m; j \u003e= v; j--) {//01背包逆着来 for (int k = 1; k \u003c= s \u0026\u0026 k * v \u003c= j; k++) { dp[j] = max(dp[j], dp[j - k * v] + k * w); } } } printf(\"%d\", dp[m]); return 0; } 时间复杂度为O(mns)，速度比较慢，对于本题物品个数不超过100个，足够跑了 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:3:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题2】AcWing 5. 多重背包问题 II 本题和【例题1】的题意是一样的，只不过数据范围直接大了一位数 分析： 再用刚刚的思想完全是不够用的了，直接TLE了 还记得完全背包的二进制优化吗吗，利用那个思想，就能优化成O($mnlogs$)的复杂度了 具体代码如下 #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; struct goods{ int v, w; goods(int v = 0, int w = 0) : v(v), w(w) {} }; const int M = 2010; int dp[M], m, n; int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { int v, w, s; scanf(\"%d%d%d\", \u0026v, \u0026w, \u0026s); vector\u003cgoods\u003e good; for (int j = 1; j \u003c= s; j \u003c\u003c= 1) {//二进制优化 s -= j; good.push_back(goods(j * v, j * w)); } if (s) good.push_back(goods(s * v, s * w)); for (auto g : good) {//01背包 for (int j = m; j \u003e= g.v; j--) { dp[j] = max(dp[j], dp[j - g.v] + g.w); } } } printf(\"%d\", dp[m]); return 0; } 总结：通过多次用到了01背包的思想可以看出01背包的重要性 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:3:2","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题3】6. 多重背包问题 III 题意和【例题1】也是一样，但这题的数据范围更大，达到了2e5 这题需要用到单调队列优化（单调队列是什么？自学吧） 仔细看下面我截取例题1时的代码的部分 for (int j = m; j \u003e= v; j--) {//01背包逆着来 for (int k = 1; k \u003c= s \u0026\u0026 k * v \u003c= j; k++) { dp[j] = max(dp[j], dp[j - k * v] + k * w); } } 不难发现$j$只会利用到$j - k \\times v$来转化，这就意味着$j$只会和与$j(mod \\ \\ v)$同余的$dp$容量来转移，例如$j = 9, v = 2$则他只可能会利用容量为$7,5,3,1$的$dp$来转移 同时注意到第二重循环的第一个循环条件$k \\le s$，这就意味着$j$利用到的与$j(mod \\ \\ v)$同余的容量的个数是有限的，不超过$s$个，例如$j = 9, v = 2, s = 2$时，则只可能会利用容量为$7,5$的$dp$来转移 综上，是不是觉得很像一个在固定窗口大小里面找一个最大值？ 直接先看代码，然后再解刨 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e using namespace std; const int M = 2e4 + 5, N = 1e3 + 5; int dp[M], tmp[M], q[M]; int main() { int n, m; scanf(\"%d %d\\n\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; ++i) { int v, w, s; scanf(\"%d %d %d\", \u0026v, \u0026w, \u0026s); for (int i = 0; i \u003c= m; ++i) tmp[i] = dp[i]; for (int j = 0; j \u003c v; ++j) { // 枚举余数 int l = 0, r = -1; // 单调队列的左右指针 for (int k = j; k \u003c= m; k += v) { // 枚举容量 if (l \u003c= r \u0026\u0026 q[l] \u003c k - s * v) ++l;// 窗口范围必须是[k - s * v, k - v] if (l \u003c= r) dp[k] = max(tmp[k], tmp[q[l]] + (k - q[l]) / v * w); while (l \u003c= r \u0026\u0026 tmp[q[r]] + (k - q[r]) / v * w \u003c= tmp[k]) --r; q[++r] = k; } } } printf(\"%d\\n\", dp[m]); return 0; } 下面对代码进行解刨 首先，由于我们之前说的$j$在只会利用到比他小的同余数，所以我们转移时必选顺着转移，不能再逆着来了，这时就要用到之前01背包说的第三种空间优化来达到顺着转移的目的了 目光移到第16行代码（枚举余数），把相同余数的容量同时一起转移，固第18行的循环中是k += v这样就保证了每次的余数都是j（当前解说的代码的j） 然后就是第18行循环的内部循环了，首先学过单调队列的同学都知道，我们为了方便处理队列，我们在队列内存的不是对应的值，而是下标（在这题下标就是容量）。前面说到我们窗口的大小是有限制的，不能超过s个，固对应下标的范围就是$[k - s\\times v,k - v]$，固若q[l] \u003c k - s * v则弹出队头元素 然后就是20行的简单易懂的更新操作，用上一个状态和当前选取(k - q[l])/v个当前物品的状态进行对比转移 21和22行都是单调队列的入队操作，队尾弹出的条件就是容量为q[l]的状态加上(k - q[r]) / v * w的价值都没有当前k容量的状态价值大（小于等于） ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:3:3","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"混合背包 混合背包就是有些物品只能选1次，有些物品最多只能选s次，有些物品无限次，分别对应01背包，多重背包，完全背包 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:4:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题】混合背包问题 解决方法很简单，全部转化为01背包就好了，对于本来就是01背包的不作处理，对于多重背包的物品可以用二进制优化变成01背包，完全背包同理可以转化为最多只能选$\\frac{m}{v}$次的多重背包后再用二进制优化 代码略 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:4:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"二维费用背包 就是一个多了体积限制的背包罢了 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:5:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题】二维费用的背包问题 很简单，多加一维体积的数组，转移时和01背包相同 直接看代码就好了 #include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; const int Maxn = 110; int n, V, M, dp[Maxn][Maxn]; int main () { scanf(\"%d%d%d\", \u0026n, \u0026V, \u0026M); for (int i = 1; i \u003c= n; ++i) { int v, m, w; scanf(\"%d%d%d\", \u0026v, \u0026m, \u0026w); for (int i = V; i \u003e= v; i--) for (int j = M; j \u003e= m; j--) dp[i][j] = max(dp[i][j], dp[i - v][j - m] + w); } printf(\"%d\", dp[V][M]); return 0; } ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:5:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"分组背包 分组背包就是有若干组物品，对于每组物品都有若干件物品，每组物品最多选一个物品，问你容量不超过c的能装的最大价值 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:6:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题】AcWing9. 分组背包问题 题意不多说，就是一个赤果果的分组背包问题 分析： 可以把每一组物品看成一个物品，然后当成01背包来做，不同的是对于每种容量的背包，都要考虑每组物品的每一个物品 也可以这么理解，对于每组物品，都假设只有一个物品，这一组物品就是一个物品了，然后不就是01背包了吗 #include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; const int Maxn = 105; int n, m, dp[Maxn]; int main () { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1 ; i \u003c= n; i++) { int v[105], w[105], s; scanf(\"%d\", \u0026s); for (int j = 0; j \u003c s; j++) { scanf(\"%d%d\", \u0026v[j], \u0026w[j]); } for (int j = m; j \u003e= 0; j--) { //01背包 for (int k = 0; k \u003c s; k++) { //假设当前组只有这一个物品 if (j \u003e= v[k]) dp[j] = max(dp[j], dp[j - v[k]] + w[k]); } } } printf(\"%d\", dp[m]); return 0; } 值得注意的是第18行和19行的代码是不可以互换的，因为一维01背包是从大到小遍历的，保持小的下标是之前的数据。若是调换过来就相当于把每件物品都看成了一件物品，而不是隶属于某一组的物品 还有一点很重要的就是分组背包的思想可以迁移到树形背包（有依赖的背包问题）的 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:6:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"有依赖的背包问题 就是一个树形背包，即如果要选一个结点，则其父亲节点必须要被选 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:7:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题】有依赖的背包问题 核心：把一个结点的每个孩子结点看做不同的组，即可以当成分组背包来自，那么组内的物品是什么呢，答案就是每组的一个决策就是一个物品（就这题而言就是每一个dp容量值就是一个物品），注意：这个思想很重要，他是所有（应该是所有）树形背包dp的共同特点 先看代码再解刨 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#define ll long long #define pb emplace_back using namespace std; const int M = 105, N = 1e3 + 5, inf = 1e9; vector\u003cint\u003e mp[M]; int root, n, m, dp[M][M], w[M], v[M], tmp[M]; int dfs(int u) { int sum = v[u]; // 记录本棵树的物品总重量 dp[u][v[u]] = w[u]; for (int\u0026 son : mp[u]) { int siz = dfs(son);// 计算孩子节点的决策，并获取他的物品总重量 for (int i = 0; i \u003c= min(m, sum + siz); ++i) tmp[i] = dp[u][i]; // 还记得01背包的空间优化3吗 for (int i = 0; i \u003c= siz; ++i) { // 这棵孩子子树选取i容量的物品 for (int j = v[u]; j \u003c= sum; ++j) { // 之前组选取的容量j if (i + j \u003e m) break; // 超过背包容量的不用转移 dp[u][i + j] = max(dp[u][i + j], tmp[j] + dp[son][i]); } } sum += siz; } return sum; //返回本树的总容量 } int main() { scanf(\"%d %d\\n\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; ++i) { int p; scanf(\"%d %d %d\\n\", \u0026v[i], \u0026w[i], \u0026p); if (p != -1) mp[p].pb(i);//存树 else root = i; } int ans = dfs(root); printf(\"%d\\n\", dp[root][min(ans, m)]); return 0; } 核心就是dfs内的函数，就直接解刨里面的吧 先来解释dp的含义dp[u][v]表示在u结点这颗子树中选取容量为v的最大价值 13行不解释，14行的话很显然，由于要选本结点的子结点则本结点必选，所以就有了14行的初始化 然后是17行，这是之前在01背包中第三种空间优化的一种手段，这样做的好处有：1、更新本结点的dp时可以顺着来更新（好理解），2、可以防止不必要的转移（具体看第21行dp的第二维转移方式）且保证了整个复杂度不高于$O(nm)$，既保证了每个（点）都只会在题目的LCA上计算一次，否则可能会使复杂度退化到O($nm^2$)，后面会解释 然后就是转移思想可以参考树形背包思考模型 接下来状态转移，先说说为什么这样转移，需要提前知道的是下面两个转移方程会导致复杂度不同 $$ dp[u][j] = max(dp[u][j], \\ \\ dp[son][i] + dp[u][j - i]) \\tag{1} $$ $$ dp[u][i + j] = max(dp[u][i + j],\\ \\ dp[son][i] + dp[u][j]) \\tag{2} $$ 有经验的小伙伴可能知道，式子(1)是填表法，式子(2)是刷表法。对于树形背包问题有个很玄学的优化就是利用刷表法来更新当前结点，这样就能保证复杂度是O($nm$)而不是O($nm^2$)，我的理解就是刷表法保证了本结点的合法性，并且使得所有结点都只会在他们的LCA上被算一次。反观填表法在有些题目上十分难以拿捏本结点的合法性 固以上就是我选择18行到23内部循环的方式的原因 没了 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:7:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"背包问题求方案数 题意就是让我们求01背包最优解的方案 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:8:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题】背包问题求方案数 多建立一个数组f[i][j]表示前i个物品选取容量为j的最优解方案数 注意初始化f[0][j]应当都初始化为1，因为是不超过m容量，所以这样初始化就保证了第一个物品转移有效 直接看代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ciostream\u003e#include \u003ccctype\u003e #define ll long long using namespace std; const int M = 1e3 + 5, N = 1e3 + 5, inf = 1e9, mod = 1e9 + 7; int n, m, dp[M][M]; ll f[M][M]; int main() { scanf(\"%d %d\\n\", \u0026n, \u0026m); for (int i = 0; i \u003c= m; ++i) f[0][i] = 1; for (int i = 1; i \u003c= n; ++i) { int v, w; scanf(\"%d %d\", \u0026v, \u0026w); for (int j = 0; j \u003c= m; ++j) { dp[i][j] = dp[i - 1][j]; // 不选 f[i][j] = f[i - 1][j]; //不选 if (j \u003e= v) { if (dp[i - 1][j - v] + w == dp[i][j]) f[i][j] = (f[i][j] + f[i - 1][j - v]) % mod; //如果相等就相加 if (dp[i - 1][j - v] + w \u003e dp[i][j]) { f[i][j] = f[i - 1][j - v]; // 否则更新值 dp[i][j] = dp[i - 1][j - v] + w; } } } } printf(\"%lld\\n\", f[n][m]); return 0; } 当然此题也可以空间优化 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:8:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"背包问题求具体方案 题意是让我们求01背包最优解的一个具体方案，并且输出字典序最小的那个 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:9:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"【例题】背包问题求具体方案 求解具体方案如果只是随便找，则直接在转移结束后倒过来找就好了，但是题目要求的是字典序最小，那么我们要在转移顺序上做一些改动，即从最后一个物品到第一个物品转移，然后再贪心找字典序最小的方案就好了 一下递归找方案个人比较喜欢 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e #define pb emplace_back using namespace std; const int M = 1e3 + 5, N = 1e3 + 5, inf = 1e9, mod = 1e9 + 7; int n, m, dp[M][M], v[M], w[M]; vector\u003cint\u003e ans; //记录答案 void solve(int num, int m) { if (m == 0 || num == n + 1) { for (int\u0026 v : ans) printf(\"%d \", v); exit(0); //结束程序 } if (m \u003e= v[num] \u0026\u0026 dp[num][m] == dp[num + 1][m - v[num]] + w[num]) { // 如果符合转移 ans.pb(num);//记录答案 solve(num + 1, m - v[num]); ans.pop_back(); // 回溯 } solve(num + 1, m); } int main() { scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; ++i) scanf(\"%d %d\", v + i, w + i); for (int i = n; i; --i) { for (int j = 0; j \u003c= m; ++j) { dp[i][j] = dp[i + 1][j]; if (j \u003e= v[i]) dp[i][j] = max(dp[i][j], dp[i + 1][j - v[i]] + w[i]); } } solve(1, m); return 0; } 注意，这题不能空间优化了 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:9:1","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"结语 写了好久好久，早就有把acwing上的背包总结博客写好的念头了，结果从开始计划到现在过了两三个月参完工，我太懒了。 这篇博客严格上来说其实并不是所有的背包问题的总结，还有其他背包中比较深究的问题，比如说求解背包问题求解次优解，第k优解等等比较深入的问题，太菜了没学。 就这样告一段落吧 ","date":"2021-03-26","objectID":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/:10:0","tags":["背包"],"title":"背包问题","uri":"/2021/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"categories":["总结"],"content":"主席树 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:0:0","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"简介 主席树是用来求区间第k大的一个可持续化数据结构 主要思想就是权值线段树+前缀和思想 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:1:0","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"几个问题 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:2:0","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"1. 用权值线段树+前缀和的原因 首先、如果我们要求一个固定区间的第k大，其中一个可以使用数据结构就是权值线段树 由于题目要我们求的是不定区间的区间第k大，我们可以用前缀和的思想建立和区间同长个数的权值线段树，这样当我们要求$[l, r]$的第k大的时候，我们就可以用第$r$个权值线段树 减去 第$l - 1$个权值线段树得到的权值线段树来求第k大 为了节省空间，我们可以使第$i$个和第$i - 1$个 权值线段树公用一些结点 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:2:1","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"2. 内存池 这个有点像链式前向星的思路，每次要添加新的边就++cnt，并让对应的边的下标为cnt 同理，我们可以在每次新加一个结点时，就++cnt，并让对应的结点的下标为cnt 可以把这里的cnt想象成我们在为新的指针申请地址时的地址号 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:2:2","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"3. 不同版本的权值线段树的存储 显然，我们要找一颗树，只需要找他的根结点就可以了 固我们可以记录每个版本（不同时间线）的权值线段树的根结点的内存池下标 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:2:3","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"4. 离散化 因为我们要建立的是权值线段树，固需要对数据进行离散化，本文的离散化做了预处理打表 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:2:4","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"结构体存放树的结点 利用结构体存放结点的好处就是访问方便，代码好写 const int N = 2e5 + 5; struct nodes{ int l, r, sum; // 左孩子的内存池编号、 右孩子内存池编号、 线段树的结点权值 nodes() : sum(0) {} }hjt[N \u003c\u003c 5]; // 开多点，一边都是32倍管够 int root[N], cnt; // 记录每个根结点的内存池编号， 内存池 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:3:0","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"建树 看AgOH的视频里面并没有加这个建树的操作，但是我觉得还是挺有必要加的，因为后面的一些可持续化数据结构能够用得上 初始建树其实可以想象成我们前缀和的第0项 int build(int l, int r) { int now = ++cnt; // 内存申请 if (l \u003c r) { int mid = (l + r) \u003e\u003e 1; hjt[now].l = build(l, mid); // hjt[now].r = build(mid + 1, r); // } return now; // 返回当前节点的内存池编号 } ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:4:0","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"插入新的权值 插入新的权值即新建一颗权值线段树 但注意，由于要复用之前的一些结点，固有些东西的写法和普通的权值线段树是不一样的，具体看代码 // 插入新节点的操作 int update(int pre, int l, int r, int x) { // 插入一个新的权值为x int now = ++cnt; // 内存申请 hjt[now] = hjt[pre], ++hjt[now].sum; // 继承上一个版本的结点，即复用，因为新加了一个值，所以结点权值+1 if (l \u003c r) { // 寻找拼接点 int mid = (l + r) \u003e\u003e 1; if (x \u003c= mid) hjt[now].l = update(hjt[now].l, l, mid, x); // 如果x在左边，则让当前新节点的左孩子接继承后的左孩子 else hjt[now].r = update(hjt[now].r, mid + 1, r, x); // 否则同理 } return now; } 代码的第4行的第一语句就像是图中一个8号新节点用两个红色的边与连向1号结点的两个孩子 代码的第8行就像是图中将8号结点的右孩子边 “剪掉” 再用一个新的绿色边和下一个新结点相连 ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:5:0","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"询问 查询是最后的操作了，具体做法主要的思想就是前缀和的思想 计算左孩子的$l, r$版本权值和的差，然后再对比 每次查询可以想象成只有一颗线段树上查找第k大 // 返回第qr版本的主席树 - 第ql版本的主席树， 注意返回的是离散化后的值 int get(int ql, int qr, int l, int r, int k) { if (l == r) return l; // 返回权值点上的权值 int mid = (l + r) \u003e\u003e 1; int dif = hjt[hjt[qr].l].sum - hjt[hjt[ql].l].sum; // 计算左孩子的版本权值和的差 if (k \u003c= dif) return get(hjt[ql].l, hjt[qr].l, l, mid, k); // 答案在左孩子上 return get(hjt[ql].r, hjt[qr].r, mid + 1, r, k - dif); // 答案在右孩子上，记得这时是找第k - dif的 } ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:6:0","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"完整代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } using namespace std; /*************************************离散化********************************************/ // vt存放可用于查询原本的数（用离散化值），打表后用于查询离散化表（用下标） vector\u003cint\u003e vt; inline int get_id(const int \u0026x) { return lower_bound(vt.begin(), vt.end(), x) - vt.begin() + 1; } inline void erase_vt() { sort(vt.begin(), vt.end()); vt.erase(unique(vt.begin(), vt.end()), vt.end()); } // 打表, 注意，原数组下标要从1开始，返回离散化后的表大小 inline int id_table(int n, int *a, vector\u003cint\u003e \u0026res) { res.emplace_back(0); for (int i = 1; i \u003c= n; ++i) res.emplace_back(get_id(a[i])); return vt.size(); } /*************************************主席树********************************************/ const int N = 2e5 + 5; struct nodes{ int l, r, sum; nodes() : sum(0) {} }hjt[N \u003c\u003c 5]; int root[N], cnt; // 记录每个根结点的内存池编号， 内存池 int build(int l, int r) { int now = ++cnt; // 内存申请 if (l \u003c r) { int mid = (l + r) \u003e\u003e 1; hjt[now].l = build(l, mid); hjt[now].r = build(mid + 1, r); } return now; } // 插入新节点的操作 int update(int pre, int l, int r, int x) { int now = ++cnt; // 内存申请 hjt[now] = hjt[pre], ++hjt[now].sum; // 继承 if (l \u003c r) { // 寻找拼接点 int mid = (l + r) \u003e\u003e 1; if (x \u003c= mid) hjt[now].l = update(hjt[now].l, l, mid, x); // 如果x在左边，则让当前新节点的左孩子接继承后的左孩子 else hjt[now].r = update(hjt[now].r, mid + 1, r, x); // 否则同理 } return now; } // 返回第qr版本的主席树 - 第ql版本的主席树， 注意返回的是离散化后的值 int get(int ql, int qr, int l, int r, int k) { if (l == r) return l; int mid = (l + r) \u003e\u003e 1; int dif = hjt[hjt[qr].l].sum - hjt[hjt[ql].l].sum; if (k \u003c= dif) return get(hjt[ql].l, hjt[qr].l, l, mid, k); // 左孩子上 return get(hjt[ql].r, hjt[qr].r, mid + 1, r, k - dif); // 右孩子上 } /*************************************主函数********************************************/ int a[N]; int main() { int n = IO(), m = IO(); for (int i = 1; i \u003c= n; ++i) a[i] = IO(), vt.emplace_back(a[i]); erase_vt(); vector\u003cint\u003e id; int siz = id_table(n, a, id); root[0] = build(1, siz); for (int i = 1; i \u003c= n; ++i) root[i] = update(root[i - 1], 1, siz, id[i]); while (m--) { int l = IO(), r = IO(), k = IO(); printf(\"%d\\n\", vt[get(root[l - 1], root[r], 1, siz, k) - 1]); } return 0; } ","date":"2021-03-23","objectID":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/:7:0","tags":["主席树"],"title":"主席树","uri":"/2021/03/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"categories":["总结"],"content":"前言 终于开始刷贪心了，感觉cf很多题都喜欢出贪心，所以决定也练练 贪心貌似也有挺系统的分类和一些经典例题，把这些刷了应该就有提升了把 ","date":"2021-03-23","objectID":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:1:0","tags":["贪心"],"title":"贪心刷题总结","uri":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"总结 贪心是指将问题通过当前最优解来求解得到最终的最优解，即局部最优解可以推出总体最优解。 给我的感觉就是一种思维题，通过一定技巧把题目旁敲侧击地解决了，但是如果没接触过或者想不出来，基本就很难了，但是贪心的代码实现并不长，所以说贪心即使很基础的算法也是很难的算法。 总得来说贪心算法难就难在每道题的贪心策略都不同，是否能贪心也很难看出来。 一般在解决贪心题的时候可以把他放到生活中的例子来，想想如果是生活中碰到这题，你会怎么解决让自己最舒服。 ","date":"2021-03-23","objectID":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:2:0","tags":["贪心"],"title":"贪心刷题总结","uri":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"普通贪心 例题1：HDU 2111 Saving HDU 题意：你有可以装k个宝贝容量的包，现在给你一些宝贝，每个宝贝价值p，有m个，问你最多可以装多少价值的宝贝 思路：将价值排序，先选大的，选到v = 0为止 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003cutility\u003e#include \u003cvector\u003eusing namespace std; int n, v; int main() { while (scanf(\"%d\", \u0026v), v) { scanf(\"%d\", \u0026n); vector\u003cpair\u003cint, int\u003e\u003e q; for (int i = 0; i \u003c n; i++) { int p, m; scanf(\"%d%d\", \u0026p, \u0026m); q.push_back(make_pair(p, m)); } sort(q.begin(), q.end()); int i = n - 1, ans = 0; while (i \u003e= 0 \u0026\u0026 v) { if (q[i].second \u003c v) { ans += q[i].first * q[i].second; v -= q[i].second; } else { ans += q[i].first * v; v = 0; } i--; } printf(\"%d\\n\", ans); } } 例题2：HDU 3348 题意：你有1、5、10、50、100的钞票，给你各个钞票的张数，问你要凑齐某价格最多和最少需要多少张，如果凑不出来输出-1 思路：最少的话就从大面值的钞票开始贪心，如果最后剩余需要凑的钱不为0，则凑不齐，至于最多的话，贪心可以这样想：要凑用得最多，那言外之意就是我剩余得最少，所以可以凑最少的贪心策略去凑所有钞票的总价格 - 需要凑的价格，最后剩下的钞票数就是需要凑的价格，固剩下的钞票数量就是最多的答案 总结：这道题的寻找最多的那个答案，一开始死活想不出来，后来看了大佬的思路恍然大悟，所以有所感悟：有时候一个问题顺着想可能很难，那不妨试试逆着来想，所谓正难则反 代码如下 #include \u003cbits/stdc++.h\u003e using namespace std; int corn[] = {1, 5, 10, 50, 100}, t, n, nums[6] = {0}; int main() { scanf(\"%d\", \u0026t); while (t--) { int tmp = n, indx = 4, Max = 0, Min = 0, sum = 0, csum = 0; scanf(\"%d\", \u0026n); for (int i = 0; i \u003c 5; i++) { scanf(\"%d\", nums + i); sum += nums[i] * corn[i]; csum += nums[i]; } while (tmp \u0026\u0026 indx \u003e= 0) { int num = tmp / corn[indx]; if (num \u003e nums[indx]) { num = nums[indx]; } tmp -= num * corn[indx]; Min += num; indx--; } if (tmp != 0) { printf(\"-1 -1\\n\"); continue; } //需要凑的最大数目 tmp = sum - n, indx = 4; while (tmp \u0026\u0026 indx \u003e= 0) { int num = tmp / corn[indx]; if (num \u003e nums[indx]) { num = nums[indx]; } tmp -= num * corn[indx]; Max += num; indx--; } printf(\"%d %d\\n\", Min, csum - Max); } return 0; } 例题3：cf 230A Dragons 题意：打龙了， 你目前要打n条龙，你的力量是s，你打一个龙的话你的力量必须比龙大，如果你打死一条龙你也可以获得相应的力量，问你是否能把所有的龙都打完 思路：一道很简单的贪心，先从力量小的龙开始打，看看能不能打完就好了 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003cutility\u003e#include \u003cvector\u003e#define all(x) x.begin(), x.end() using namespace std; vector\u003cpair\u003cint, int\u003e\u003e dr; int n, s; int main() { scanf(\"%d%d\", \u0026s, \u0026n); for (int i = 0; i \u003c n; i++) { int x, y; scanf(\"%d%d\", \u0026x, \u0026y); dr.push_back(make_pair(x, y)); } bool win = true; sort(all(dr)); for (int i = 0; i \u003c n; i++) { if (s \u003e dr[i].first) { s += dr[i].second; } else { win = false; puts(\"NO\"); break; } } if (win) puts(\"YES\"); return 0; } 例题4：51Nod - 1117 聪明的木匠 题意：一个木段，现要锯成$L_1, L_2, L_3 …… L_n$的长度，但是据一段木段需要消耗相应的体力，例如要把长为8的木段锯成 3 和 5 的话需要消耗3 + 5 = 8的体力，现在问你最少要消耗多少体力锯好 错误的思路：一开始想不出来，单纯的觉得是一个简短的排序不等式的的贪心题，只要先据出最大的目标值，然后一直据下去就是最优解，但这是不对的，最多也就过个他给的样例。 正确的思路①：仔细想想，如果是没按要求切成题目要求目标长度切，那样的话当然是希望一切下去可以让后面的体力没这么多，比如要分成2 2 3 3，这样的话应该是先 5 5 再 2 3 5 最后就 2 3 2 3这样就是最小的，消耗为20， 如果是按照先前的想法就是21，所以先前的思路显然是不对的。那这个思路怎么实现呢，dfs？显然很难实现 正确的思路②：回忆上上题的总结，正难则反，反过来想，现在把问题改成拼成一个完整的木段，消耗最小，这样的话就是拼当前最小的两小木段，最终的答案就是最小的 代码如下(注释的部分是一开始错误的思路，交上去才发现思路不对) #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cqueue\u003e using namespace std; using ll = long long; int n, arr[50010], sum[50010]; priority_queue\u003cint\u003e heap; int main() { scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; i++) { // scanf(\"%d\", \u0026arr[i]); int x; scanf(\"%d\", \u0026x); heap.push(-x); } int ans = 0; while (heap.size()) { int x = -heap.top(); heap.pop(); int y = -heap.top(); heap.pop(); ans += x + y; if (heap.size()) heap.push(-(x + y)); } printf(\"%d\", ans); /* sort(arr, arr + n); for (int i = 0; i \u003c n; i++) { sum[i + 1] = sum[i] + arr[i]; } ll ans = 0; for (int i = n - 1; i \u003e= 1; i--) { ans = ans + arr[i] + sum[i] - sum[0]; } printf(\"%lld\\n\", ans); */ return 0; } 例题5：HDU 6709 Fishing Master 题意：钓鱼家有一个锅和一个鱼竿，他有 n 条鱼要钓，钓一条鱼需要 k 时间，他的任务就是把这些鱼都钓上来，并且把它们都煮了，第i条鱼的煮熟所需要的时间为$t_i$，他钓鱼的时候不能往锅里放鱼并且要等他掉好k时间才可做下一件事，他可以在煮鱼的时候钓鱼，他可以同时拥有很多鱼，即他钓好后可以放在身边，因为锅一次只能煮一条鱼。现在问你他至少要花多少时间煮好n条鱼。 思路： 一开始看错题，wa了一下午，英语太差的锅。回归正题，显然第一条鱼是钓的时间是不可避免的，全部煮鱼的时间也是不可避免的。可以优化的就只有钓鱼多出来的时间了。 注意到只要我煮的鱼时间足够长，那么我就可以在煮鱼的这个空档里面钓足够多的鱼，即可以钓$t_i / k$条，如果鱼快煮好了，即再过$x(x \u003c k)$的时间就煮好鱼了，不难发现这里的$x = t_i % k$，那么这时候是继续钓鱼呢，还是选择去等鱼煮好然后放下一条（前提是你手上有钓好的鱼） 如果你选择继续钓鱼，那时间就会多花$k - t_i % k$的时间 如果你选择去等待的话，那你手上就必须要有鱼，没鱼怎么办，那只能选择上个选择，即继续钓鱼 画图出来可能比较直观 对于这个配图，即便是$t_i \u003c k$公式依旧成立 显然，根据图，","date":"2021-03-23","objectID":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:3:0","tags":["贪心"],"title":"贪心刷题总结","uri":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"区间贪心 例题1：HDU 2037 今年暑假不AC 题意：给你一些区间，让你选出尽量多的不相交的区间 思路：把所有区间（x, y）根据y来从小到大排序，然后从第一区间开始，排除和他相交的区间，即对比前一个选定的区间的y和当前要对比的区间的x，如果x \u003c y则不选，否则回到上一步 看代码容易懂 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003cutility\u003e#include \u003cvector\u003e using namespace std; int n; int main() { while (scanf(\"%d\", \u0026n), n) { vector\u003cpair\u003cint, int\u003e\u003e coo; int x, y; for (int i = 0; i \u003c n; i++) { scanf(\"%d%d\", \u0026x, \u0026y); coo.push_back(make_pair(y, x)); } sort(coo.begin(), coo.end()); int num = 0, last = -0x3f3f3f3f; for (int i = 0; i \u003c n; i++) { if (last \u003c= coo[i].second) { num++; last = coo[i].first; } } printf(\"%d\\n\", num); } } ","date":"2021-03-23","objectID":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:4:0","tags":["贪心"],"title":"贪心刷题总结","uri":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"领项交换法 例题1：LOJ 加工生产调度 题意：一个物品必须要先在A车间加工，才能在B区间加工个，问你n个物品最短的加工结束时间是多少 思路：一道Johnso不等式的题，不知道也没关系，只要你会邻项交换法就能写 首先假设只有两个产品要加工，其中一种最优解，两个下标分别为$i,j$，则其最终加工的时间为 $$ max(a_i + b_i, a_i + a_j) + b_j $$ 假设调换$i,j$，则最终的加工时间为 $$ max(a_j + b_j, a_j + a_i) + b_i $$ 此时我当然是希望以下等式成立 $$ max(a_i + b_i, a_i + a_j) + b_j \u003c max(a_j + b_j, a_j + a_i) + b_i $$ 固我们直接这样排序就可以了(这就是邻项交换法)，当然网上还有对上式继续化简后的不等式，据说是Johnson不等式（我也不是很懂这个不等式，总之挺有意思的） $$ max(a_i + b_i, a_i + a_j) + b_j \u003c max(a_j + b_j, a_j + a_i) + b_i $$ $$ \\Rightarrow max(b_i,a_j) + a_i + b_j \u003c max(b_j, a_i) + a_j + b_i $$ $$ \\Rightarrow max(b_i,a_j) - a_j - b_i \u003c max(b_j, a_i) - a_i - b_j $$ $$ \\Rightarrow max(-a_j,-b_i) \u003c max(-a_i, -b_j) $$ $$ \\Rightarrow min(a_j, b_i) \u003e min(a_i, b_j) $$ 以上式子均可以放到sort中作为排序的依据 ac代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; #include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } const int M = 1e5 + 5, N = 1000 + 5, inf = 0x3f3f3f3f; int n, m; #define ll long long struct pairs { int i, a, b; }p[N]; int main() { n = IO(); for (int i = 0; i \u003c n; ++i) { p[i].i = i, p[i].a = IO(); } for (int i = 0; i \u003c n; ++i) p[i].b = IO(); sort(p, p + n, [] (pairs \u0026i, pairs \u0026j) { return max(i.b, j.a) + i.a + j.b \u003c max(j.b, i.a) + j.a + i.b; // return min(j.a, i.b) \u003e min(i.a, j.b);//这个也可以 }); int ans = 0, a = 0, b = 0; for (int i = 0; i \u003c n; ++i) { a += p[i].a; b = max(a, b) + p[i].b; } ans = b; printf(\"%d\\n\", ans); for (int i = 0; i \u003c n; ++i) { printf(\"%d\", p[i].i + 1); if (i != n - 1) putchar(' '); } return 0; } ","date":"2021-03-23","objectID":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:5:0","tags":["贪心"],"title":"贪心刷题总结","uri":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"ddl贪心 例题1：智力大冲浪 一种简单型的$ddl$贪心问题，每个任务都是单位时间就能完成 贪心方案：先讲扣的分数降序排序，再从其$ddl$时间开始往前找时间给他完成（因为要尽量空出前面的时间给后面的任务，换句话说就是让当前任务尽可能是接近$ddl$的时间之前完成），若找不到这个时间则扣这个扣款数 ac代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; #include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } const int M = 1e5 + 5, N = 1000 + 5, inf = 0x3f3f3f3f; // int a[M], sum[M]; int n, m; #define ll long long struct pairs { int t, w; }p[N]; bool day[N]; int main() { #ifndef ONLINE_JUDGE freopen(\"D:/MYCODE/vsCode-c/test.in\", \"r\", stdin); freopen(\"D:/MYCODE/vsCode-c/test.out\", \"w\", stdout); #endif m = IO(), n = IO(); int sum = 0; for (int i = 1; i \u003c= n; ++i) p[i].t = IO(); for (int i = 1; i \u003c= n; ++i) sum += p[i].w = IO(); sort(p + 1, p + 1 + n, [](pairs\u0026 i, pairs\u0026 j) { return i.w \u003e j.w; }); for (int i = 1; i \u003c= n; ++i) { for (int j = p[i].t; j; --j) { if (day[j]) continue; day[j] = true; sum -= p[i].w; break; } } printf(\"%d\", m - sum); return 0; } 例题2：家庭作业 这题是一道进阶版的ddl贪心问题，和智力大冲浪一样，只是数据范围大了很多 首先思路和智力大冲浪是一样的，先做了分高的，时间从这个分高的$ddl$后往前遍历，看看有没有时间能做，能就加上这个分，不能就跳过 但是由于这个$ddl$的是长度太长了，两重循环一定会超时的，所以，就要优化一下 优化方案一（线段树） 不难发现，我们上面的思路的第二重循环目的就是为了找从$1$到$ddl$时间里面最靠后的时间是多少 所以可以用一个线段树优化，即查找区间最大值 代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; #include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } const int M = 1e6 + 5, N = 7e5 + 5, inf = 0x3f3f3f3f; int n, m; struct pairs { int t, c; }p[M]; int seg[N \u003c\u003c 2]; void build(int l, int r, int node = 1) { if (l == r) { seg[node] = l; return; } int mid = (l + r) \u003e\u003e 1; build(l, mid, node \u003c\u003c 1), build(mid + 1, r, node \u003c\u003c 1 | 1); seg[node] = max(seg[node \u003c\u003c 1], seg[node \u003c\u003c 1 | 1]); } void update(int index, int l, int r, int node = 1) { if (l == r) { seg[node] = 0; return; } int mid = (l + r) \u003e\u003e 1; if (index \u003c= mid) update(index, l, mid, node \u003c\u003c 1); else update(index, mid + 1, r, node \u003c\u003c 1 | 1); seg[node] = max(seg[node \u003c\u003c 1], seg[node \u003c\u003c 1 | 1]); } int get(int index, int l, int r, int node = 1) { if (r \u003c= index) return seg[node]; int mid = (l + r) \u003e\u003e 1; int res = get(index, l, mid, node \u003c\u003c 1); if (index \u003e mid) res = max(res, get(index, mid + 1, r, node \u003c\u003c 1 | 1)); return res; } int main() { n = IO(); int ans = 0, d = 0; for (int i = 0; i \u003c n; ++i) p[i].t = IO(), p[i].c = IO(), d = max(d, p[i].t); sort(p, p + n, [] (pairs\u0026 i, pairs\u0026 j) { return i.c \u003e j.c; }); build(1, d); for (int i = 0; i \u003c n; ++i) { int maxv = get(p[i].t, 1, d); if (maxv) { ans += p[i].c; update(maxv, 1, d); } } printf(\"%d\", ans); return 0; } 优化方案二 （并查集） 上面用线段树无非就是为了找从$1$到$ddl$的最大值 这个过程其实可以用并查集来做，即初始化从$1$到$ddl$的时间里面最大值都是他们自己，当这个时间被用了之后，就让其父亲指向前一个时间 代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; #include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } const int M = 1e6 + 5, N = 7e5 + 5, inf = 0x3f3f3f3f; int n, m; struct pairs { int t, c; }p[M]; int fa[N]; int findset(int x) { return x == fa[x] ? x : fa[x] = findset(fa[x]); } int main() { n = IO(); int ans = 0, d = 0; for (int i = 0; i \u003c n; ++i) p[i].t = IO(), p[i].c = IO(), d = max(d, p[i].t); sort(p, p + n, [] (pairs\u0026 i, pairs\u0026 j) { return i.c \u003e j.c; }); for (int i = 0; i \u003c= d; ++i) fa[i] = i; for (int i = 0; i \u003c n; ++i) { int maxv = findset(p[i].t); if (maxv) { ans += p[i].c; fa[maxv] = maxv - 1; } } printf(\"%d\", ans); return 0; } 优化方案三（优先队列） 这个优化方案在$loj$不开O2优化依然超时 而且这个优化方案其实不是对上面超时的思路进行优化，但是挺好的，只是被$loj$卡了罢了 ","date":"2021-03-23","objectID":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:6:0","tags":["贪心"],"title":"贪心刷题总结","uri":"/2021/03/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"二分图 ","date":"2021-03-15","objectID":"/2021/03/%E4%BA%8C%E5%88%86%E5%9B%BE/:0:0","tags":["图论"],"title":"二分图","uri":"/2021/03/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["总结"],"content":"判图 利用染色法判 // 未试过 bool dfs(int u, int c) { col[u] = c; for (int \u0026v : gp[u]) { if (!col[v]) dfs(v, 3 - c); else if (col[v] == c) return false; } return true; } for (int i = 1; i \u003c= n; ++i){ if (col[i] == 0) dfs(i, 1); } ","date":"2021-03-15","objectID":"/2021/03/%E4%BA%8C%E5%88%86%E5%9B%BE/:1:0","tags":["图论"],"title":"二分图","uri":"/2021/03/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["总结"],"content":"最大匹配 ","date":"2021-03-15","objectID":"/2021/03/%E4%BA%8C%E5%88%86%E5%9B%BE/:2:0","tags":["图论"],"title":"二分图","uri":"/2021/03/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["总结"],"content":"匈牙利算法 int match[M]; bool vis[M]; bool dfs(int u) { for (int \u0026v : gp[u]) { if (vis[v]) continue; vis[v] = true; if (!match[v] || dfs(match[v])) { match[u] = v, match[v] = u; return true; } } return false; } // 主函数里 fill_n(match, n + 1, 0); // n是点的个数 for (int i = 1; i \u003c= n; ++i) { if (match[i]) continue; fill_n(vis, n + 1, false); dfs(i); } ","date":"2021-03-15","objectID":"/2021/03/%E4%BA%8C%E5%88%86%E5%9B%BE/:2:1","tags":["图论"],"title":"二分图","uri":"/2021/03/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"categories":["总结"],"content":"FHQ Treap ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:0:0","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"简介 fhq treap主要有两个操作：分裂、合并 作为平衡树，他所有的平衡树操作都是基于这两个操作实现的 ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:1:0","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"关于结点的存储与生成新的结点 由于一个结点要维护挺多信息的，所以用结构体来存储一个结点会比较好 如代码，存放的有：结点的权值、左孩子、右孩子、子树的大小、关键值（用随机函数赋值）,其中左右孩子值为0代表是叶子，即无内存池编号 const int N = 4e5 + 10; struct treap{ int val, l, r, size, key; }fhq[N]; 而生成一个新的结点和主席树的动态开点是有点像的，看代码就能懂了 int root, cnt; // 因为只有一棵树，所以只要一个root记录树的根节点就行了，cnt为内存池 mt19937 rnd(233); // 随机函数，头文件 random int new_node(int val) { fhq[++cnt] = {.val = val, .l = 0, .r = 0, .size = 1, .key = rnd()}; return cnt; } 注意，由于我们多维护了一个树的大小，固我们还要写一个更新结点的函数 inline void update(int now) { // 左孩子的大小 + 右孩子的大小 + 1 fhq[now].size = fhq[fhq[now].l].size + fhq[fhq[now].r].size + 1; } ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:2:0","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"分裂 分裂操作有两种 第一种是按照权值分裂，一边分裂成小于等于某个值的，另一边分裂成大于某个值的 具体细节看代码 void split(int now, int val, int \u0026x, int \u0026y) { // 分裂成x y两棵treap树 if (!now) { x = y = 0; return; } // 如果当前结点为空，则不作分裂 // 如果当前结点的值小于等于分裂要求的值，则让x树接上当前结点，并递归下去找当前结点的右孩子和y树应该拼接哪个结点 if (fhq[now].val \u003c= val) x = now, split(fhq[now].r, val, fhq[now].r, y); else y = now, split(fhq[now].l, val, x, fhq[now].l); // 否则同理 update(now); // 因为分裂了，记得更新 } 第二种就是按照数的大小分裂 待补…… ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:3:0","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"合并 合并的话也不难 显然刚刚分裂时分裂出来的x和y，x树上的所有权值都小于y树上的权值 具体细节看代码（以大根堆为例） int merge(int x, int y) { if (!x || !y) return x | y; // 大根堆 if (fhq[x].key \u003e fhq[y].key) { //如果x的key值大于y的key值，则根据堆和平衡树的性质 fhq[x].r = merge(fhq[x].r, y), update(x); // 让x的右子树为（x的右子树和y合并的结果的根）， 记得更新结点 return x; // 返回合并后的根结点的内存池的编号 } // 否则同理 fhq[y].l = merge(x, fhq[y].l), update(y); return y; // 返回合并后的根 } ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:4:0","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"平衡树的基本操作 ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:5:0","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"1、插入 首先先将整棵平衡树分裂成$\\le val$的x子Treap树和$\u003eval$的y子treap树 然后再新建一个权值为$val$的结点 让x和新结点合并，再和y合并 inline void insert(int val) { int x, y; split(root, val, x, y); root = merge(merge(x, new_node(val)), y); } ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:5:1","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"2、按值删除 将整棵树分裂成x、y、z，分别为$\u003cval$、$=val$、$\u003eval$ 然后将y的根结点删除 最后再合并回去 inline void del(int val) { int x, y, z; split(root, val, x, z); // 分裂1 split(x, val - 1, x, y); //分裂2 y = merge(fhq[y].l, fhq[y].r); // 删除y的根结点 root = merge(merge(x, y), z); // 最后合并回去 } ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:5:2","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"3、按值获取排名 将整棵树分裂成x（$\u003c val$）和y（$\\ge val$） $val$的排名就是x的数的大小+1 inline int getrank(int val) { int x, y, ans; split(root, val - 1, x, y); // 分裂 ans = fhq[x].size + 1; // 记录答案 root = merge(x, y); // 合并回去 return ans; } ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:5:3","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"4、按排名获取值 获取一个排名其实就是找一棵子树的左子树大小 + 1为rank 从根结点一直往下找就可以了 inline int getval(int rank) { int now = root; while (now) { if (fhq[fhq[now].l].size + 1 == rank) break; // 找到了 else if (fhq[fhq[now].l].size \u003e= rank) now = fhq[now].l; // 在左子树上 else rank -= fhq[fhq[now].l].size + 1, now = fhq[now].r; // 寻找右子树记得改动排名 } return fhq[now].val;//最后的答案 } ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:5:4","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"5、求一个数的前驱或后继 找$val$的前驱只需要将整棵树分裂成x（$\u003c val$）和y（$\\ge val$） 然后x树中的最大值就是$val$的前驱，一直往右子树找就可以了 后继的找法同理 // 求前驱 inline int pre(int val) { int x, y; split(root, val - 1, x, y); int now = x; while (fhq[now].r) now = fhq[now].r; root = merge(x, y); return fhq[now].val; } // 求后继 inline int nxt(int val) { int x, y; split(root, val, x, y); int now = y; while (fhq[now].l) now = fhq[now].l; root = merge(x, y); return fhq[now].val; } ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:5:5","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"完整代码 // 洛谷板子题 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003crandom\u003e#include \u003ccctype\u003einline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == '-') f = true; c = getchar(); } while (isdigit(c)) { x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (c - '0'); c = getchar(); } return f ? -x : x; } using namespace std; const int N = 4e5 + 10; mt19937 rnd(233); struct treap{ int val, l, r, size, key; }fhq[N]; int root, cnt; inline void update(int now) { fhq[now].size = fhq[fhq[now].l].size + fhq[fhq[now].r].size + 1; } int new_node(int val) { fhq[++cnt] = {.val = val, .l = 0, .r = 0, .size = 1, .key = rnd()}; return cnt; } void split(int now, int val, int \u0026x, int \u0026y) { if (!now) { x = y = 0; return; } if (fhq[now].val \u003c= val) x = now, split(fhq[now].r, val, fhq[now].r, y); else y = now, split(fhq[now].l, val, x, fhq[now].l); update(now); } int merge(int x, int y) { if (!x || !y) return x | y; // 大根堆 if (fhq[x].key \u003e fhq[y].key) { //右下角 fhq[x].r = merge(fhq[x].r, y), update(x); return x; } // 左下角 fhq[y].l = merge(x, fhq[y].l), update(y); return y; } // 插入 inline void insert(int val) { int x, y; split(root, val, x, y); root = merge(merge(x, new_node(val)), y); } // 按值删除 inline void del(int val) { int x, y, z; split(root, val, x, z); split(x, val - 1, x, y); y = merge(fhq[y].l, fhq[y].r); root = merge(merge(x, y), z); } // 按值获取排名 inline int getrank(int val) { int x, y, ans; split(root, val - 1, x, y); ans = fhq[x].size + 1; root = merge(x, y); return ans; } // 按排名获取值 inline int getval(int rank) { int now = root; while (now) { if (fhq[fhq[now].l].size + 1 == rank) break; else if (fhq[fhq[now].l].size \u003e= rank) now = fhq[now].l; else rank -= fhq[fhq[now].l].size + 1, now = fhq[now].r; } return fhq[now].val; } // 求前驱 inline int pre(int val) { int x, y; split(root, val - 1, x, y); int now = x; while (fhq[now].r) now = fhq[now].r; root = merge(x, y); return fhq[now].val; } // 求后继 inline int nxt(int val) { int x, y; split(root, val, x, y); int now = y; while (fhq[now].l) now = fhq[now].l; root = merge(x, y); return fhq[now].val; } int main() { int t = IO(); while (t--) { int q = IO(), val = IO(); if (q == 1) insert(val); else if (q == 2) del(val); else if (q == 3) printf(\"%d\\n\", getrank(val)); else if (q == 4) printf(\"%d\\n\", getval(val)); else if (q == 5) printf(\"%d\\n\", pre(val)); else printf(\"%d\\n\", nxt(val)); } return 0; } ","date":"2021-03-09","objectID":"/2021/03/fhqtreap/:6:0","tags":["平衡树"],"title":"FHQ树","uri":"/2021/03/fhqtreap/"},{"categories":["总结"],"content":"寒假cf刷题 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:0:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf478B Random Teams(*1300) 求参赛员的朋友数 贪心就好，最少的情况就是均分，最多的情况就是其余m-1队都只有1人的情况 总结：找找规律，大胆猜测：最大和最小一定是两个极端。做的时候读不懂题目，后来靠样例猜出的题目的意思。 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:1:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1463B Find The Array(*1400) 给定一个长度为n的数组a，总和为s，求一个同长的数组b，使其和给定的数组每个对应的数的绝对值即$a_i - b_i$的二倍小于等于s，并且对于每一对相邻的数$b_i$和$b_{i+1}$要么$b_i % b_{i+1} == 0$要么$b_{i+1} % b_i == 0$ 我的思路：不难发现目的就是为了使得$a_i - b_i$尽可能的小，那就很容易想到可以使其直接为0，然后又要满足相邻的可以被除的条件，则可是在奇数（或者偶数）下标取$a_i$，在偶数（或者奇数）下标取1，这样的话只需要求出给定数组的奇数下标的和与偶数下标的和，对比大小来决定到底是奇数放1还是偶数放1了 大佬的思路：对于b数组让每个数都是2的k次幂即$2^k,k\\ge0$，并且保证$2^k \\le a_i$ 总结：回归本质，思考题目设置的限制条件的意义，从那里出发思考，同时可以自己举例子 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:2:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1453B Suffix Operations(*1400) 给一个数组，有操作：选取一个下标i，将i（包括i）之后的所有数加一或者减一，你有一次可以把任何数变换的机会，问你将所有数变成一样的最小操作数（不包括变换的那个操作） 去除那个变换的机会，（大胆猜测）不难发现如果要将所有数变成一样的，所需要的操作顺序是任意的，其最小的操作次数就是相邻两个数的差值的绝对值之和。对于那个把任意数变换的一次机会我们可以将一个数变成其前面的数或者后面的数以减小差值绝对值。做法求一下差值的绝对值的和，之后再暴力遍历每一个数，要么变成前面的数，要么变成后面的数，最后取一个最小值就行了 总结：将问题分解一步一步地找到解决问题的方法，还可以大胆猜想出一个结论出来，证明无误后，利用这个结论来解题 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:3:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1408B Arrays Sum(*1400) 给一个单调不减且数组a，求一个数组组，数组组中的每个数组的也要是单调不减且不同数的个数不超过k，并且数组的下标i的总和正好为$a_i$，输出最小的数组组的大小，无解输出-1 纸上模拟，反向推演找数组组，不难发现若要个数不超过k，除了第一次，之后的每次最多能使k - 1个数变为0，而第一次能使k个数变为0（包括本来的0）。所以最终得到的公式就是$k + (k - 1) * num \\ge dif$，其中dif为a数组不同数的个数，num为答案。不难发现若$dif \u003e k$则无解 总结：想清楚题目要我干嘛，寻找规律，大胆猜想，纸上推演，理清思路，排除不必要的干扰，防止思维混乱。 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:4:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1393B Applejack and Storages(*1400) 起初你有n根木棍，有q询问，每次询问都添加一根或者去除一根，同时你要回答每次添加或者去除后能否组成一个正方形和一个长方形（正方形也是长方形） 正难则反，不难发现要一个正方形必须要4根同长的木棍，一个长方形要1对2根同长的木棍;我的做法：用三个set分别存放个数为1，个数为2和3的，个数为不低于4的，剩下的就是模拟了。大佬的做法：用两个变量记录个数是2的倍数的two，和个数为4的倍数的four，无论是询问还是原本有的木棍，假设成一根一根添加，一旦添加到为2的倍数则two自增，一旦添加到为4的倍数则four自增，最终答案就是$four \\ge 2$或者$four \\ge 1 \u0026\u0026 two \\ge 3$就能达到目的 总结：我的思路是比较贴近现实生活中遇到此问题时我们会怎么解决来思考的，大佬的做法是在此基础上加上更加妙的实现做法 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:5:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1365C Rotation Matching(*1400) 给你两个长度相等为n的排列数组a和b，问题经过平移后最多有多少个相等的数下标能对应上 仔细思考不难发现：假设平移b数组，并且只能向一个方向平移，若$a_i$和$b_j$相等，要使其位置对应，则平移的位置就是$(i - j + n) % n$，最终就是求相同平移量的个数最大值 总结：从本质出发，不用考虑太多算法，就是纯思维 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:6:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1144D Equalize Them All(*1400) 给你一个数组，你能选择相邻的两个数$a_i$和$a_{i+1}$进行操作:$a_i = a_i + |a_i - a_{i+1}|$或者$a_i = a_i - |a_i - a_{i+1}|$，问你最小的操作数使得数组所有数都相等，输出方案 贪心就好，首先纸上推演，题中给的操作能够实现将一个数变成另一个数，然后就是大胆贪心，最小的操作次数一定是数组中所有的数最终变成原本数组的众数，利用发现的规律来使得所有数都变成那个数便可以了 总结：大胆猜想，然后验证，目前主要障碍就是读题，还有码代码时候优先选择思路清晰的码代码方式，基本内存可能很大，wa了之后人肉跑一遍代码检查，还是查不出就举反例 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:7:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1355D Game With Array(*1400) 请你求一个长度为n的数组，其总和为s，输出一个k，使得你求的数组没有一个子数组的总和为k，若无解输出NO，否则输出YES和数组和k 仔细思考一下，贪心，最极端的就是n-1个1，设剩下一个就是x = s - (n - 1)，不难啊发现x到s范围的都可以组合出来，若$n - 1 \\ge x - 1$，则说明1到n-1都能组合出来，即无解，否则有解 大佬思路：让所有数都大于等于2，最后k = 1，便可。至于无解情况就是$s \u003c n * 2$ 总结：大胆猜想，贪心，从极端情况考虑 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:8:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1348B Phoenix and Beauty(*1400) 给你一个长度为n的数组a，求一个数组b，数组a是数组b的子序列，数组b的所有长度为k的连续子序列的和总是一样，有解输出数组b，无解输出-1 不难发现，要让b数组的长度为k的连续子数组和总是相等，其实只要让其一直循环长度为k的数组就好了，对于数组a是数组b的子序列也不难处理，显然若要有解就是a数组中的不同个数不得超过k 总结：这题不是很难，但是要注意细节，有些时候检查代码人肉跑一次是非常必要的，在一定不会超时的前提下怎么方便怎么来，stl放心用 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:9:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1316B String Modification(*1400) 给你一个字符串，你可以操作：从左到右遍历，每k个就进行翻转。让你计算一个最小的k，操作后字典序最小 观察不难这样的操作，其实就是把从下标为k - 1开始到最后的子串平移到最前面，然后就是将0到k-2下标的补到后面，若k-1之后的个数为奇数，则需要将0到k-2的子串进行翻转再补到后面 总结：这题不难，但是字符串的处理有点麻烦，同上题一样，不超时放心用stl的东西 ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:10:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1270C Make Good(*1400) 给你一个数组a，让你添加不超过3个数，使得$a_1 + a_2 … a_n = 2\\times(a_1 \\bigoplus a_2 … \\bigoplus a_n)$ 纸上推演，利用异或的特性可以推出第一次异或本来的异或和使等式右边为0，再来就是异或左边加上刚刚的异或值的和，便是答案，可见这个方法只要加两个数便可以了 总结：本题不难，思考问题从位运算的特性中思考，还有就是注意此题会爆int ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:11:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["总结"],"content":"cf1266C Diverse Matrix 你需要求出以个$r\\times c$的矩阵，并且对于矩阵的每一行每一列的最大公因数都不一样，让你求最小化这个矩阵中行列的最大公因数的矩阵 此题有点偏数学，在纸上推理，不难发现：最小的最大公因数一定是r + c，然后就是反向推演，不难发现对列和行从1到r+c编号，然后对于矩阵上的一个数要满足题意只需要求出对应编号的最小公倍数即可，但需要注意的是编号优先从行数和列数中小的开始，例如行数比列数少，则编号需要从行开始 总结：纸上推演，大胆猜想，然后简单验证和人肉debug ","date":"2021-01-12","objectID":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/:12:0","tags":null,"title":"寒假cf刷题","uri":"/2021/01/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98%E5%BD%95/"},{"categories":["紫书刷题录-ch9"],"content":"Color Length 题意：给你两个长度分别为$n、m(1 \\le n, m \\le 5000)$的字符串，让你求出组成新串的最小$l(c)$（具体组成方式看原题） 个人感觉这题很难，一度怀疑自己的能力和紫书题目的难易分布，最后费了九牛二虎之力终于想通为什么了，所以本文可能会花大篇幅来解释这题是怎么想的 思路：一开始看着有点LCS的影子，想着想着就写出了DP的递归函数，但是却死活想不出下一步怎么递归，即如下代码的$[]$片段 int DP(int a, int b) { if (vis[a][b]) return dp[a][b]; vis[a][b] = true; int \u0026res = dp[a][b]; return res = min(DP(a - 1, b) + [], DP(a, b - 1) + []); } 显然，可以猜测dp方程是 $$ dp[i][j] = min(dp[i - 1][j] + ?_1, dp[i][j - 1] + ?_2) $$ 想了好久终于还是去看了别人的博客题解，没怎么看懂，于是看了许多人的博客题解，大概知道了一件事：这题的难点就在于求 $?_1 和 \\ \\ ?_2$，即需要预处理就出这个 $?_1 和 \\ \\ ?_2$ 先来说说这个 $?_1 和 \\ \\ ?_2$到底是什么东西 首先，如果我们暴力直接来求这个 $?_1 和 \\ \\ ?_2$，，即每转移一次就求一次 $?_1 和 \\ \\ ?_2$，这样的话不仅麻烦，而且还不好想，最重要的是时间复杂度太大了 那么如何来理解这个转移所需要的 $?_1 和 \\ \\ ?_2$呢？这需要先了解dp代表的是什么意思： $dp[i][j]$代表的是：从字符串1中选取了前i个字符和字符串2中选取了前j个字符拼接成的字符产生的总$l(c)$值的最小值 举个例子，拿题目中给的GBBY和YRRGB，如果在字符串1中选取了G，从字符串2中选取了Y的话，则$dp[1][1]$就是1，代表G和Y在这种情况下（注意这个“这种情况下”，意味着如果换了两个只有第一个字符相同的字符串的话$dp[i][j]$的值可能就会不一样，这个很重要，现在先不说明，下面在解释 $?_1 和 \\ \\ ?_2$时会用上）的最小总$l(c)$为1 解释一下为什么是1，因为Y和G都还没有全部从字符串1和2中全部拿出来，即在字符串1和2中都还有未拿出来拼接的Y和G，则当前拼接成的字符串YG对未来拼接影响$l(c)$最小是$1(Y) + 0(G) = 1$（拼成GY的dp也是一样的值，即$1(G) + 0(Y) = 1$） 如果字符串2是选取了前3个即YRR的话，则最小的总$l(c)$值就是4，即$dp[1][3] = 4$，具体拼接方式是YRRG，因为R字母已经全部抽取了出来所以其$l(c) = 1$，总值就是$4 = 1(R) + 3(Y) + 0(G)$ 可能很难懂，没关系，当理解了 $?_1 和 \\ \\ ?_2$后可以再回来看这个dp的含义 说了这么多还是每开始说明 $?_1 和 \\ \\ ?_2$是什么东西，别着急，还需要几个要理解的： 用紫书上的说法就是：“当把一个颜色移到最终序列前，需要把所有“已经出现但还没结束”的颜色的$l(c)$值加1。更进一步地，因为并不关心每个颜色的$l(c)$，所以只需要知道有多少种颜色已经开始但尚未结束。” 一开始我就是一直在纠结怎么记录每种颜色在之前的拼接中放的位置，卡了很久 举个例子来说明紫书上的意思：还是那个题目中给的GBBY和YRRGB，假如现在已经拼接成了GY，则$dp[1][1] = 1$，接下来再从字符串2中抽出个R，则拼成的结果的$dp[1][2] = 3$（假如拼接成的是GYR），则分别加的两个值就是G加了1，和Y加了1，因为加了一个字母R导致字符串的长度加了1并且G和Y都没全部抽取出来，固都需要加一 若再从字符串2中抽取出R来的话，$dp[1][3] = 4$，可能有人会疑惑为什么是4而不是6，因为R和Y和G都要加1，总加的值就是3，所以答案不应该是$3 + 3 = 6$吗?，先冷静，还记得吗，dp的含义。我们拼接的应该是YRRG的样子才是最小值，这个时候R已经全部抽出来了，所以R值不用加1，完全可以计算他本身的$l(c)$值，所以总的$dp[1][3] = 3(Y) + 1(R) + 0(G) = 4$ 已经懂的可以跳过这一段的，原谅我再啰嗦一下，假如再从字符串2抽取一个G，则$dp[1][4] = 4(Y) + 1(R) + 1(G) = 6$，即G和R都已经全部抽取出来了，要加一的是Y，而G和R只需计算自身的$l(c)$就行了 发现没有至始至终Y的$l(c)$是一直在加一的，而其他的由于中途已经全部抽取出来了，固没有加一而是计算自身的$l(c)$值 到这里就可以解密?是什么了：$add[i][j]$代表从字符串抽取了前i个字符和从字符串抽取了前j个字符中已经出现但还没有全部抽取出来的字符有多少个 因为只有已经出现但还没有全部抽取出来的字符在我们不断地拼接新的字符的时候才要加一 关于$add[i][j]$的预处理转移方式： 首先是要记录每个字符在两个字符串中的开始和结束位置，这个目的是知道当前字符是不是已经出现但还没有全部抽取出来的字符 对于$add[i][j]$当$i \u003e 1$并且$j \u003e 1$时，其可以从两个方面转移过来，即$add[i][j - 1]$和$add[i - 1][j]$，可以这么想：从两个字符串中分别抽取前i、j个字符的前一个状态可以是从前两个字符串中分别抽取前i - 1、j或者前i、j - 1个字符的状态，对应分只要考虑字符串1的第i个字符是不是已经抽取完了或者字符串2的第j个字符是不是已经抽取完了，都是可以的，代码片段只会从一种中计算出来，而不是两种计算方式都用上我要最求速度 如果如果当前新拼接的字符是已经出现但还没有全部抽取出来的字符，则$add[i][j]$就自加一，如果是已经出现并且全部都抽取出来的字符，则$add[i][j]$就自减一 具体结果就是如图： dp前对add的预处理代码： struct strings{ int s, t; strings(int s = INF, int t = 0) : s(s), t(t) {} }; void init(char *a, char *b) { int n = strlen(a + 1), m = strlen(b + 1); strings aa[27], bb[27]; for (int i = 1; i \u003c= n; i++) {//记录每个字符在字符串1中的开始位置和结束位置 strings \u0026t = aa[a[i] - 'A']; t.s = min(t.s, i), t.t = i; } for (int i = 1; i \u003c= m; i++) {//记录每个字符在字符串2中的开始位置和结束位置 strings \u0026t = bb[b[i] - 'A']; t.s = min(t.s, i), t.t = i; } for (int i = 0; i \u003c= n; i++) { for (int j = 0; j \u003c= m; j++) { add[i][j] = 0; bool ok = true;//就计算一次add[i][j] if (i) { add[i][j] = add[i - 1][j]; int x = a[i] - 'A'; if (aa[x].s == i \u0026\u0026 bb[x].s \u003e j) add[i][j]++;//如果是已经出现但还没有全部抽取出来的字符 if (aa[x].t \u003c= i \u0026\u0026 bb[x].t \u003c= j) add[i][j]--;//如果是已经出现并且全部都抽取出来的字符 ok = false; } if (ok \u0026\u0026 j) { add[i][j] = add[i][j - 1]; int x = b[j] - 'A'; if (bb[x].s == j \u0026\u0026 aa[x].s \u003e i) add[i][j]++; if (bb[x].t \u003c= j \u0026\u0026 aa[x].t \u003c= i) add[i][j]--; } // printf(\"%d \", add[i][j]); } // puts(\"\"); } // printf(\"%d\", aa['R' - 'A'].t); } 接下来就是dp的转移方程了 $$ dp[i][j] = min(dp[i - 1][j] + add[i - 1][j], \\ \\ i \u003e 0 \\ \\ ①, dp[i][j - 1] + add[i][j - 1], \\ \\ j \u003e 0 \\ \\ ② ) $$ 注意①式和②式代表的含义是不同的，其中①式代表抽取前i、j个字符的之前状态时抽取前i - 1、j个字符的状态，即第i个字符一定是放在拼接后的最后一位，②式同理，给个转移图体会体会 还不懂的可以草稿纸模拟一下，从上面介绍dp内涵开始重看 最终ac代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e using namespace std; const int M = 5e3 + 10, INF = 0x3f3f3f3f; int add[M][M], dp[M][M]; struct strings{ int s, t; strings(int s = INF, int t = 0) : s(s), t(t) {} }; void init(ch","date":"2020-09-07","objectID":"/2020/09/uva1625/:1:0","tags":["题解","动态规划"],"title":"UVA1625","uri":"/2020/09/uva1625/"},{"categories":["紫书刷题录-ch9"],"content":"Partitioning by Palindromes 题意：给你一个字符串，让你求分割成最少回文串的数量，比如racecar最少就是1，fastcar就是7，aaadbccb就是3 思路： 说实话，不放到动态规划的专题我可能都不知道怎么做 提供一种比较好想的思路：记一个长度为$l$的字符串最大的分割数量就是$l$，如果说第$l$个字符和第$l - 1$个字符拼成的字符串是回文串，则分割数量就可以减少，即将$l - 1$ ~ $l$的字符串看成一个字符，固分割数减一，以此类推往前找能够看成单个字符的回文串来求出长度为$l$的字符串的最小的分割数 设dp[i]为从0~i的字符串的最小分割数，当j + 1 ~ i是回文串时，其分割数就为dp[j] + 1，设isp[i][j]表示字符串下标从i~j是否为回文串，状态转移方程为 $$ dp[i] = min{dp[j] + 1},\\ \\ isp[j + 1][i] = true $$ 代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e using namespace std; int dp[1005], len; bool isp[1005][1005]; char str[1005]; void check() { len = strlen(\u0026str[1]) + 1; for (int i = 1; i \u003c len; i++) { isp[i][i] = true; } for (int i = 1; i + 1 \u003c len; i++) { isp[i][i + 1] = (str[i] == str[i + 1]); } for (int i = 2; i \u003c len; i++) { for (int j = 1; j + i \u003c len; j++) { if (str[j] == str[j + i] \u0026\u0026 isp[j + 1][j + i - 1]) isp[j][j + i] = true; } } } void solve(){ memset(isp, 0, sizeof isp); memset(dp, 0x3f, sizeof dp); scanf(\"%s\", \u0026str[1]); check(); dp[0] = 0; for (int i = 1; i \u003c len; i++) { for (int j = i; j \u003e 0; j--) { if(!isp[j][i]) continue; dp[i] = min(dp[i], dp[j - 1] + 1); } } printf(\"%d\\n\", dp[len - 1]); } int main() { int T; scanf(\"%d\", \u0026T); while(T--) solve(); return 0; } ","date":"2020-08-31","objectID":"/2020/08/uva11584/:1:0","tags":["题解","动态规划"],"title":"UVA11584","uri":"/2020/08/uva11584/"},{"categories":["紫书刷题录-ch9"],"content":"Lighting System Design 题意：你要设计一个一共需要n种不同电压灯泡的照明系统，不同种类的灯泡用不同的电源，同一种灯泡必须要用同一个电源，现在为了省钱，在亮度不减的前提下，可以用电压高的灯泡来换电压低的灯泡减小费用，现给你每种灯泡的电压V，电源费用K，每个灯泡的费用C，每种灯泡所需要的数量L，问你计算出最优的方案的费用 思路： 为了减少电压之间的比较可以对灯泡进行从小到大的排序，这样的话就可以默认是下标大的换下标小的 注意到对于一种灯泡，要不就全换掉，要不就全部都不换，不可能说最优的方案是当前这种灯泡只换一部分 设dp[i]表示当决策到第i种灯泡时的最优方案 将sum[i]表示前i种灯泡需要的总数量，相当于一个前缀和，则转移方程为 $$ dp[i] = max{dp[j] + (sum[i] - sum[j]) * c[i] + k[i]} $$ 解释：相当于是dp[i]的最优方案是第j + 1 ~ i种的灯泡都用第i种灯泡，然后再加上前j种灯泡中的最优方案，即dp[j] 因为每种灯泡的电压都是不一样的，所以这个方程的转移不用担心出现两种的灯泡的使用电压是一样但是电源或者灯泡的单价不一样的情况 再来就是第i种的灯泡在将前面的灯泡替换时一定是连续的，即j + 1 ~ i种是连续的不会出现断续的情况，因为如果出现断续的k（j + 1 ~ k - 1 和 k + 1 ~ i）的情况，则第k种灯泡替换成j + 1 ~ k的方案一定会比替换成i要优 代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e using namespace std; int n, dp[1010], sum[1010]; struct lamps{ int v, k ,c, l; lamps(){} lamps(int v, int k, int c, int l) : v(v), k(k), c(c), l(l) {} }lamp[1010]; int main() { while (scanf(\"%d\", \u0026n), n) { for (int i = 1; i \u003c= n; i++) scanf(\"%d%d%d%d\", \u0026lamp[i].v, \u0026lamp[i].k, \u0026lamp[i].c, \u0026lamp[i].l); memset(dp, 0x3f, sizeof dp); sum[0] = 0, dp[0] = 0; sort(lamp + 1, lamp + n + 1, [](lamps a, lamps b) { return a.v \u003c b.v; }); for (int i = 1; i \u003c= n; i++) { sum[i] = lamp[i].l + sum[i - 1]; } for (int i = 1; i \u003c= n; i++) { for (int j = 0; j \u003c= i; j++) { dp[i] = min(dp[i], dp[j] + lamp[i].c * (sum[i] - sum[j]) + lamp[i].k); } } printf(\"%d\\n\", dp[n]); } return 0; } ","date":"2020-08-31","objectID":"/2020/08/uva11400/:1:0","tags":["题解","动态规划"],"title":"UVA11400","uri":"/2020/08/uva11400/"},{"categories":["紫书刷题录-ch9"],"content":"Jin Ge Jin Qu hao 大致题意：在KTV里，如果还剩下1秒的时间，则可以点一首更长的歌，因为他会播放完最后一首歌才停止，现在给你剩下的时间$m$和$n(n \\le 50)$首歌，每首歌的时长$t_1, t_2, t_3 ……t_n$，现让你算出在剩余的时间内能唱的歌的最大数量，然后利用空出来的时间最后再点一首长为678秒的歌，输出能唱的最大数量，对应的时间 简单的分析： 题目中说最后会点一首678秒的歌来延长时间，则策略就是计算在不超过$m - 1$时间里选最多的歌 读一读上面的一句话，是不是感觉很想01背包？是的就是01背包问题，每个物品的价值默认是1了（一首歌嘛） 题目中说$m \\le 10^9$，其实并没有这么大，~~我一开始也很苦恼这怎么建数组，~~后来发现其实并没有这么大，他说n + 1首歌的时长严格大于剩余的时长，并且每一首歌不会超过3分钟，这么算的话$180 \\times 50 + 678 = 9678$，固数组完全够开 值得注意的是这题计算在选歌的数量多的前提下最后尽量晚地结束KTV，这就需要讨论了，一开始被这个搞得十分地晕，冷静下来后发现一个if是不够的，于是就特判3次 首先如果当前抉择的歌曲数量还没之前算的多，直接跳过 如果当前抉择的歌曲数量严格比之前算的还多，则更新歌曲数量和时间总长度 如果当前抉择的歌曲数量和之前算的一样多，则还要判断当前抉择的时长是严格比上次算还多，则更新时间总长度 具体看代码 #include \u003ccstring\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; int n, t, dp[10010], m, kase = 0, sum[10010]; void solve() { scanf(\"%d%d\", \u0026n, \u0026m); memset(dp, 0, sizeof dp); memset(sum, 0, sizeof sum); for (int i = 0; i \u003c n; i++) { scanf(\"%d\", \u0026t); for (int j = m; j \u003e t; j--) { if (dp[j] \u003e dp[j - t] + 1) continue;//特判1 if (dp[j] \u003c dp[j - t] + 1) { //特判2 dp[j] = dp[j - t] + 1; sum[j] = sum[j - t] + t; } else if (sum[j] \u003c sum[j - t] + t){//特判3 sum[j] = sum[j - t] + t; } } } printf(\"Case %d: %d %d\\n\", ++kase, dp[m] + 1, sum[m] + 678); } int main() { int T; scanf(\"%d\", \u0026T); while (T--) { solve(); } return 0; } ","date":"2020-08-21","objectID":"/2020/08/uva12563/:1:0","tags":["题解","动态规划","01背包"],"title":"UVA12563","uri":"/2020/08/uva12563/"},{"categories":["紫书刷题录-ch9"],"content":"Unidirectional TSP 大致题意：有个$m \\times n$矩阵，对于每个点你可以向直接向右、右上，右下走，第1行的上一行是第m行，第m行的下一行是第1行，问你从第一列的某一行出发，到达最后一列所经历的点的和最小是多少，并且打印出每一列的行号，如果有多解，输出字典序最小的 简单的分析： 可以看出是一个数塔问题的变种 书中说这种问题叫做多阶段决策问题中的一类——多阶段图的最短路问题，所谓多阶段图按书中说法就是图中结点可以划分成若干个阶段 这里我的理解就是原数塔问题也可以说是一个DAG，而这题相当于多个数塔重合的版本，固每一列都有对应着不用的阶段 计算最短路就是简单的数塔解法了 真正让人头疼的是最小字典序这里，一开始我的做法是写一大堆if判断，最后对比了一下刘老师的代码，妙不可言，用了大小为3的数组存下一列的决策行数 代码如下 #include \u003ccstring\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; const int INF = 0x3f3f3f3f; int m, n, g[15][110], ans[15][110], Min, dp[15][110], f; bool vis[15][110]; int DP(int r, int c) { if (c == n) return 0; if (vis[r][c]) return dp[r][c]; int \u0026res = dp[r][c], M = INF, \u0026i = ans[r][c + 1], row[] = {r - 1, r, r + 1}; vis[r][c] = true, res = g[r][c]; if (r == 0) row[0] = m - 1; if (r == m - 1) row[2] = 0; sort(row, row + 3); for (int j = 0; j \u003c 3; j++) if (M \u003e DP(row[j], c + 1)) M = DP(row[j], c + 1), i = row[j]; res += M; return res; } int main() { while (~scanf(\"%d%d\", \u0026m, \u0026n)) { for (int i = 0; i \u003c m; i++) for (int j = 0; j \u003c n; j++) scanf(\"%d\", \u0026g[i][j]); Min = INF; memset(vis, 0, sizeof vis); for (int i = 0; i \u003c m; i++){ int tmp = DP(i, 0); if (Min \u003e tmp) Min = tmp, f = i; } printf(\"%d\", f + 1); for (int i = 1, j = ans[f][i]; i \u003c n; j = ans[j][++i]) printf(\" %d\", j + 1); printf(\"\\n%d\\n\", Min); } return 0; } ","date":"2020-08-21","objectID":"/2020/08/uva116/:1:0","tags":["题解","动态规划"],"title":"UVA116","uri":"/2020/08/uva116/"},{"categories":["紫书刷题录-ch9"],"content":"The Tower of Babylon 题意：给你n种有无数个的立方体，现在让你用这些立方体堆一个塔，每个立方体的底面长宽都要严格小于下面立方体的底面长宽，问你最高能堆多高 简单的分析 能看得出来是一个矩形嵌套的变种问题，用DAG模型建立来做会非常好码代码 一种立方体有三种摆放方式，假设一个立方体的长宽高为a、b、c，则三种摆放方式分别是以a、b、c为高的摆放方式，固一种立方体可以看成三个立方体 下面就是建立DAG了，如果一个立方体的底面长宽严格大于另一个底面长宽的立方体则连一条有向边过去 最后就DP就是求从某个节点出发的最大距离就是答案 注意到，无论是思考还是码代码都不需要再去想状态方程来，直接当成一个图求最远距离来做，为了加速，我用了邻接表来建立图 下面是代码 #include \u003ccstring\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; int n, kase = 0, head[100], cnt = 0, dp[500], vis[500]; struct rect{ int a, b, c; rect(){} rect(int a, int b, int c) : a(a), b(b), c(c) {} }r[100]; struct edges{ int to, next; edges(int to = 0, int next = -1) : to(to), next(next) {} }edge[10010]; bool ok(const rect\u0026 x, const rect\u0026 y) { return (x.a \u003e y.a \u0026\u0026 x.b \u003e y.b) || (x.b \u003e y.a \u0026\u0026 x.a \u003e y.b); } void add_edge(int u, int v) { edge[++cnt] = edges(v, head[u]); head[u] = cnt; } bool read() { scanf(\"%d\", \u0026n); if (!n) return false; int x[3]; for (int i = 0; i \u003c 3 * n;) { for (auto \u0026j : x) scanf(\"%d\", \u0026j); r[i++] = rect(x[0], x[1], x[2]); r[i++] = rect(x[0], x[2], x[1]); r[i++] = rect(x[1], x[2], x[0]); } memset(head, -1, sizeof head); memset(edge, 0, sizeof edge); memset(dp, 0, sizeof dp); memset(vis, 0, sizeof vis); cnt = 0; for (int u = 0; u \u003c 3 * n; u++) { for (int v = 0; v \u003c 3 * n; v++) { if (u == v) continue; if (!ok(r[u], r[v])) continue; add_edge(u, v);//邻接表建图 } } return true; } int DP(int u) { if (u \u003e= 3 * n) return 0; if (vis[u]) return dp[u]; int \u0026res = dp[u], Max = 0; res = r[u].c, vis[u] = true; for (int v = head[u]; ~v; v = edge[v].next) {//它的下一个节点 Max = max(Max, DP(edge[v].to)); } return res += Max; } int main() { while (read()) { int ans = 0; for (int i = 0; i \u003c 3 * n; i++) ans = max(ans, DP(i)); printf(\"Case %d: maximum height = %d\\n\", ++kase, ans); } return 0; } ","date":"2020-08-21","objectID":"/2020/08/uva437/:1:0","tags":["题解","动态规划"],"title":"UVA437","uri":"/2020/08/uva437/"},{"categories":["紫书刷题录-ch9"],"content":"A Spy in the Metro 本篇是由DP总结中搬出的，目的是记录刷题进度 大致题意：一个线性的地铁，有$n(2 \\le n \\le 50)$个站，目标是在$T(0 \\le T \\le 200)$时刻从1号站到n号站，注是规定刚好T时刻，不是在T时刻之前也不是在T时刻之后，从1号点出发，可以在途中转乘，问你最少的中途等车时间 第i站到第i + 1站需要花的时间为$t_i$ 有$M1(M1 \\le 50)$个车从1号站出发，出发时间分别为$d_1, d_2, d_3……, d_{M1}\\ \\ (d_i \u003c d_{i + 1}, d_i \\le 250)$，同样有M2个车从n号站出发，时间格式同上 其余细节看题 简单分析： 就看当先的状态，假设现在的时间是tim，正在第p个站有三种策略 等1分钟，剩下的下一分钟再说 如果有向1号站行的车，乘坐上去 如果有向n号站行的车，乘坐上去 那么这个是怎么建立DAG图的呢，对于每个点，定义它包括的属性有时间和站点，如果当前时间当前站点有开往下个一或者上一个站的车，则将到站的时间和对应的站点连一条有向的边，例如当前时间是15，站点是3，并且有开向第2站点的车，10单位的时间后到达，但没有向下一个站开的车，则在属性为（15，3）的节点连一条有向边到（25，2）的节点， 当然千万别忘了一点就是下1单位时间的同一站点也有一条边，即（15，3）到（16，3）也有一条有向边 然后就可以利用这个DAG图的节点属性来定义状态了，即设dp[p][tim]为在p站点tim时刻的状态，既然是求最小路，则状态就是到当前节点的最短路 对应三种策略的状态转移方式 当前的状态等于下一单位时间的状态加1的等待时间 当前状态等于到站后的时间和站点的状态 同上 最后取一个最小值 边界条件就是如果在T时刻和n站点刚好到达，则返回0，因为不用等了，如果超过了T时间，则说明是从某个站点到另一个站点后时间过了，则返回无穷大表示不用等了，如果刚好到T时刻且没到达n站点，则说明后面再怎么坐车时间也过了，也返回无穷大 说了这么多，却没写状态转移方程是因为打算使用记忆化来做，所有不用转移方程，直接考虑当前递归的来自哪些结果就好了 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e using namespace std; const int INF = 0x3f3f3f3f; int n, T, t[100], kase = 0, dp[110][210]; bool has_train[110][210][2], vis[110][210]; bool read() { int m, x; scanf(\"%d\", \u0026n); if(!n) return false; scanf(\"%d\", \u0026T); for (int i = 1; i \u003c n; i++) scanf(\"%d\", t + i); memset(has_train, 0, sizeof has_train); memset(vis, 0, sizeof vis); scanf(\"%d\", \u0026m); for (int i = 0; i \u003c m; i++) { scanf(\"%d\", \u0026x); has_train[1][x][0] = true; for (int j = 2; j \u003c= n; j++) { has_train[j][x + t[j - 1]][0] = true; x += t[j - 1]; } } scanf(\"%d\", \u0026m); for (int i = 0; i \u003c m; i++) { scanf(\"%d\", \u0026x); has_train[n][x][1] = true; for (int j = n - 1; j \u003e= 1; j--) { has_train[j][x + t[j]][1] = true; x += t[j]; } } return true; } int DP(int p, int tim) { int \u0026d = dp[p][tim]; if (tim \u003e T) return INF; if (tim == T) return p == n ? 0 : INF; if (vis[p][tim]) return d; vis[p][tim] = true, d = INF; d = DP(p, tim + 1) + 1; if (p \u003c n \u0026\u0026 has_train[p][tim][0]) d = min(d, DP(p + 1, tim + t[p])); if (p \u003e 1 \u0026\u0026 has_train[p][tim][1]) d = min(d, DP(p - 1, tim + t[p - 1])); return d; } int main() { while (read()) { int ans = DP(1, 0); if (ans \u003e= INF) printf(\"Case Number %d: impossible\\n\", ++kase); else printf(\"Case Number %d: %d\\n\", ++kase, ans); } return 0; } ","date":"2020-08-20","objectID":"/2020/08/uva1025/:1:0","tags":["题解","动态规划"],"title":"UVA1025","uri":"/2020/08/uva1025/"},{"categories":["总结"],"content":"1. 写在前面的话 之前写了一篇不像总结的动态规划总结，感觉更像是一个成长历程，所以就打算重写一篇。 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:1:0","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"2. 对DP简单的总结 dp的题目特点： 求最大或者最小值（如背包：价值最大、凑硬币：数量最少……） 计数（如：爬楼梯：计算上到n台阶的方法数） 求存在性或者胜负（如：能否胜利……） dp的使用条件 拥有子问题，子问题最优解（即拥有最优子结构），对于一个原问题解最优，其子问题必定也是最优，同时原问题的最优解依赖于其子问题的最优解 子问题重复性，一个子问题可能会影响多个不同的下一阶段的原问题 无后效性，即此时的之前状态无法直接影响未来的决策，换句话说就是之前的每个状态如何得来并不影响未来对此时（当前）状态的利用或者查找，因为我们最后对此时（当前）状态的利用只考虑结果不考虑过程。 dp的思考方式及注意事项 若问题有dp的味道，应当优先从主问题出发来思考，即从末尾（结果）开始思考（例如爬楼梯问题） 接下来，对于一个主问题，应当思考此问题的结果由什么得来（由什么决定、怎么决策等）和有什么因素影响 或者思考此问题类似什么DP题（如:背包、LIS……） 实在想不出可以思考如果是用dfs（或普通递归），应当如何解决问题（个人觉得有时候道理是相同的，记得吗：递归 + 记忆化 = 递推） 注意1：在思考一个状态的得来时，目光应当只集中在此时的状态（无后效性），而不要多想之前的状态变化和未来的状态影响 注意2：状态的定义很重要，要结合题目需求和状态影响因素来定义 关于dp三步走 1.状态定义 → 2.列状态转移方程 → 3.验证方程 对于第一步和第二步主要可以利用上述的思考方式或者是闫氏DP分析法来解决 第三步虽然不难，但是很重要，因为第三步包括：验证状态推理是否合理或者是否是答案最优，并且思考状态是否满足题目条件需求，前者均没问题后再思考边界是什么。对于一般验证发现有问题通常的解决办法有：1、修改状态定义；2、给状态增加维度；3、优化转移方程 补充的话 读了紫书上的动规篇才开始补这篇博客的坑 学到了很多东西，包括用记忆化搜索的优势、刷表法、DAG模型等等 所以有些代码写的不是递推的方式是为了练习记忆化式的递归 阅读了紫书动规篇后彻底抛弃了递推就一定比记忆化递归还快的观念，也使我再一次对自己当年总结的dp思考方式（递推 = 递归 + 记忆化）感到肯定 先来说说记忆化的优势： ①便于思考，有时完全都不用所谓的状态转移方程，只需要考虑当选状态下如何选择下一步的策略来进行码代码，在比赛的时候这个优势是非常大的 ②有些题无法用递推的方式来写，甚至状态都可能是无限的，这时候记忆化的优势将会进一步地放大 ③用记忆化不一定就比递推慢，仔细思考一下，有时候有些状态是不用计算的，而记忆化在这方面会比全部计算出来的递推要好，固速度不必递推差 记忆化的技巧 多开一个数组来做记忆化的操作比将状态数组定义成特殊值来判定是否又有算过好一些，不仅能够增强可读性，还更方便调试操作 如果状态做记忆化用另开数组的方式还是麻烦，不妨试试用map来存被算过的状态 用引用来调用状态数组可以简化代码 刷表法 和刷表法相对的是填表法，所谓填表法我的理解就是传统的利用之前选好的状态来计算当前的状态，书中是这么说的“对于每个状态i，计算f(i)，这需要对于每个状态i都找到f(i)的依赖的所有状态” 正如书中的一句话“在某些时候并不方便”，即找f(i)的所有依赖状态不好找，于是就诞生了刷表法 所谓刷表法，我的理解就是用计算好的状态更新它所影响到的状态，书中原话“对于每个状态i，更新f(i)所影响到的状态，但需要注意的是，只有当每个状态所依赖的状态对它的影响相互独立时才能用刷表法”，后半句话我也不是很理解，以后遇到了能理解的对应的题再说 DAG模型 动态规划能够概括出DAG模型是紫书动态规划篇给我最大的惊喜，巧妙地把我之前总结的那繁多的模型分类大大地再次概括了一遍 DAG模型有点像刷搜索题时一般，将题目抽象成一个有向无环图，然后求解最大距离或者是最小距离 个人感觉由于有时太过抽象，所有很难把它的图给抽象出来 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:2:0","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"3. 几个重要的模型 上图中有很多模型都可以归类为DAG模型（习得紫书后才了解到的），但是有些是完全可以单拿出来作为经典模型的 借用陈峰老师的一句话：子结构状态形成的如果是一棵树，不就是搜索了吗，如果是一个图，不就是动态规划了吗 原话是这个意思，感触很深，确实，有些题遇到了把他抽象出来如果是一颗树，基本应该优先考虑dfs、bfs等搜索操作，如果是一个图，即有重复的子结构，就可以考虑动规了 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:3:0","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"数塔模型 这个模型是许多人动规入门的题，变种不多，但是却很经典 【例题】HDU 2084 数塔 题意：有一个树形的塔，每个节点都有权值，让你求出从根节点到最后一层叶子节点的的最大权值和 简单的分析 这题是不能贪心的，即不能只选出当前最大的叶子权值 假设已经算好了第2层的节点的最大权值和，则第1层的节点（根节点）的最大权值就为第二层的两个节点的最大权值和加上第一层的权值 其余节点也可假设成第一层和第二层来思考 所以设$dp[ i][ j]$为第i层的第j个节点的最大权值和，边界条件就是最后一层的最大权值和就是其本身 状态转移方程如下 $$ dp[i][j] = max(dp[i - 1][j],\\ \\ dp[i - 1][j + 1]) + tree[i][j] $$ 发现空间还是可以优化的，因为当前层数的dp值利用的只有下一层的dp值，而数组的的第二维计算时利用的是后面的（j + 1）的值，所以第二维是下标小的先更新，下标大的后更新，所以完全可以把第一维抛弃掉，但这样的话dp下标循环起来必须是从小到大循环 状态转移方程如下 $$ dp[j] = max(dp[j], dp[j + 1]) + tree[i][j] $$ 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003cvector\u003e using namespace std; int c, n; int main() { scanf(\"%d\", \u0026c); while (c--) { scanf(\"%d\", \u0026n); int tree[110][110] = {0}; for (int i = 0; i \u003c n; i++) for (int j = 0; j \u003c= i; j++) scanf(\"%d\", \u0026tree[i][j]); int *dp = new int[n]; for (int i = 0; i \u003c n; i++) { dp[i] = tree[n - 1][i]; } for (int i = n - 2; i \u003e= 0; i--) for (int j = 0; j \u003c= i; j++) dp[j] = max(dp[j], dp[j + 1]) + tree[i][j]; printf(\"%d\\n\", dp[0]); } return 0; } ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:3:1","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"凑硬币模型 凑硬币模型是一个经典的模型，题目大概就是给你一个目标，你有许多不同的结构，你要用这些结构来组成这个目标，让你求最大组成量、最小组成量或者是组成方法数（组成方法数可以说是爬楼梯模型） 【例题1】leetcode 322 零钱兑换 大致题意：给你不同面额的硬币，让你输出凑成价值n的最小使用数量，若无法凑成则返回-1 这题就是一个凑硬币的板子题 简单分析： 假如你有1 2 5的硬币，假设你已经求出$x$的最小使用数量$y$，则就能算出 $x + 1$ 、$x + 2$ 、$x + 5$ 的最小使用数量，即都为 $y + 1$ 设 $dp[ x]$ 表示价值为x的最小凑的数量，边界的话显然，$x = 0$ 时最小要凑的数量为 $0$，所以边界就是 $dp[ 0] = 0$ 所以不难得出状态转移方程 $$ dp[ x] = min \\lbrace dp[ x - coins[ i]] + 1 \\rbrace ,\\ \\ x \\ge coins[ i],\\ \\ i = 0, 1, 2 \\cdots $$ 代码如下 class Solution { public: int coinChange(vector\u003cint\u003e\u0026 coins, int amount) { vector\u003cint\u003e dp(amount + 1, 0x3f3f3f3f); dp[0] = 0; for (int i = 0; i \u003c= amount; i++) { for (auto c : coins) { if (i \u003e= c) dp[i] = min(dp[i - c] + 1, dp[i]); } } if (dp[amount] == 0x3f3f3f3f) return -1; return dp[amount]; } }; 【例题2】leetcode 279 完全平方数 大致题意：平方数{1, 4, 9, 16 ……}，给你一个数n，让你用平方数组成该数，求最小组成数量 简单的分析： 把平方数看成硬币，然后就是硬币题了 状态转移方程一样的，直接上代码 class Solution { public: int numSquares(int n) { vector\u003cint\u003e dp(n + 1, 0); dp[0] = 0; for (int i = 1; i \u003c= n; i++) { dp[i] = dp[i - 1] + 1; for (int j = 2; i - j * j \u003e= 0; j++) { dp[i] = dp[i] \u003e (dp[i - j * j] + 1) ? dp[i - j * j] + 1 : dp[i]; } } return dp[n]; } }; ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:3:2","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"LIS模型 LIS就是所谓的最长不下降子序列问题，变种不多，但很经典，所以直接看例题 【例题1】leetcode 300 最长上升子序列 题意：给定一个无序的整数数组，找到其中最长上升子序列的长度，注意严格上升 简单的分析： 分享一下一开始我学动规的时候LIS定义的状态是dp[i]表示下标为i的数组之前的最长上升子序列（即可以不选$nums[i]$），但是这样来定义我发现很难进一步地对状态进行转移，后来还是妥协了书中的状态定义方式 这件事现在看来也是有点感慨，因为现在的我明白：状态定义的不同，转移的方式可能也会完全不一样，所以有时候不同的状态定义会影响转移的难易程度，在思考一道动规题时，如果发现状态难以转移，不妨试试换个状态定义 设dp[i]表示选择下标为i的数为结尾的最长子序列，这样做的好处就是方便后面的转移，方便利用当前下标数和之前算好的dp状态的下标数进行对比大小，可以想象成当前状态是和之前算好的状态进行拼接 则转移方程为 $$ dp[i] = max\\lbrace 1,\\ \\ dp[j] + 1 \\ \\ | \\ \\ 0 \\le j \u003c i, nums[j] \u003c nums[i] \\rbrace $$ 不难发现，状态转移需要利用到下标为j的原数组的数，所以这个说明了状态定义就很重要了 最终的答案就是取其中的最大值 这种做法的时间复杂度是O($n^2$)，当然还有更快的速度可以达到O($nlogn$)，这里不再赘述了 dp代码如下 class Solution { public: int lengthOfLIS(vector\u003cint\u003e\u0026 nums) { int len = nums.size(), Max = 0; vector\u003cint\u003e dp(len, 1); for (int i = 0; i \u003c len; i++) { for (int j = 0; j \u003c i; j++) { if (dp[i] \u003c dp[j] + 1 \u0026\u0026 nums[j] \u003c nums[i]) dp[i] = dp[j] + 1; } Max = max(Max, dp[i]); } return Max; } }; ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:3:3","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"LCS模型 LCS就是最长公共子序列，也很经典 【例题1】AcWing 897. 最长公共子序列 题意：给你两个长度分别为n、m的字符串，让你求最长的公共子序列有多长 简单的分析： 设a序列的字符分别为$a_1, a_2,a_3……a_n$，b序列的字符分别为$b_1, b_2, b_3……b_m$ 假如序列a为ab，b为a，则他们的LCS就是1，注意到，如果b序列后面加个b变为ab，则LCS就是2，但如果加的是c变为ac，则LCS则还是1 设$dp[i][j]$表示a序列长度为i，b序列长度为j时的LCS，假设已经求出了之前的状态，则当$a_i = b_j$时，则$dp[i][j] = dp[i - 1][j - 1] + 1$，即LCS长度加一，但如果不相等，则$dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])$，不难看出这个转移方程的意义，下面上一个图更好理解 其中红色是a序列的各个字符，橙黄色是b序列的各个字符，表格中的数字是相对应的LCS 代码如下 #include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; int n, m, dp[1010][1010]; char a[1010], b[1010]; int main() { scanf(\"%d%d%s%s\", \u0026n, \u0026m, \u0026a[1], \u0026b[1]); for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { if (a[i] == b[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } printf(\"%d\", dp[n][m]); return 0; } ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:3:4","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"背包模型 背包问题是经典的一类动规问题 篇幅过长已搬出（传送门） ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:3:5","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"DAG模型 DAG模型是一个概括非常广的模型，它包括凑硬币模型、背包模型等等，但还是要写写，因为我觉得DAG更多的是一种思想，把DP问题抽象成一个DAG的图，便于思考 【例题1】UVA 1025 A Spy in the Metro 大致题意：一个线性的地铁，有$n(2 \\le n \\le 50)$个站，目标是在$T(0 \\le T \\le 200)$时刻从1号站到n号站，注是规定刚好T时刻，不是在T时刻之前也不是在T时刻之后，从1号点出发，可以在途中转乘，问你最少的中途等车时间 第i站到第i + 1站需要花的时间为$t_i$ 有$M1(M1 \\le 50)$个车从1号站出发，出发时间分别为$d_1, d_2, d_3……, d_{M1}\\ \\ (d_i \u003c d_{i + 1}, d_i \\le 250)$，同样有M2个车从n号站出发，时间格式同上 其余细节看题 简单分析： 就看当先的状态，假设现在的时间是tim，正在第p个站有三种策略 等1分钟，剩下的下一分钟再说 如果有向1号站行的车，乘坐上去 如果有向n号站行的车，乘坐上去 那么这个是怎么建立DAG图的呢，对于每个点，定义它包括的属性有时间和站点，如果当前时间当前站点有开往下个一或者上一个站的车，则将到站的时间和对应的站点连一条有向的边，例如当前时间是15，站点是3，并且有开向第2站点的车，10单位的时间后到达，但没有向下一个站开的车，则在属性为（15，3）的节点连一条有向边到（25，2）的节点， 当然千万别忘了一点就是下1单位时间的同一站点也有一条边，即（15，3）到（16，3）也有一条有向边 然后就可以利用这个DAG图的节点属性来定义状态了，即设dp[p][tim]为在p站点tim时刻的状态，既然是求最小路，则状态就是到当前节点的最短路 对应三种策略的状态转移方式 当前的状态等于下一单位时间的状态加1的等待时间 当前状态等于到站后的时间和站点的状态 同上 最后取一个最小值 边界条件就是如果在T时刻和n站点刚好到达，则返回0，因为不用等了，如果超过了T时间，则说明是从某个站点到另一个站点后时间过了，则返回无穷大表示不用等了，如果刚好到T时刻且没到达n站点，则说明后面再怎么坐车时间也过了，也返回无穷大 说了这么多，却没写状态转移方程是因为打算使用记忆化来做，所有不用转移方程，直接考虑当前递归的来自哪些结果就好了 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e using namespace std; const int INF = 0x3f3f3f3f; int n, T, t[100], kase = 0, dp[110][210]; bool has_train[110][210][2], vis[110][210]; bool read() { int m, x; scanf(\"%d\", \u0026n); if(!n) return false; scanf(\"%d\", \u0026T); for (int i = 1; i \u003c n; i++) scanf(\"%d\", t + i); memset(has_train, 0, sizeof has_train); memset(vis, 0, sizeof vis); scanf(\"%d\", \u0026m); for (int i = 0; i \u003c m; i++) { scanf(\"%d\", \u0026x); has_train[1][x][0] = true; for (int j = 2; j \u003c= n; j++) { has_train[j][x + t[j - 1]][0] = true; x += t[j - 1]; } } scanf(\"%d\", \u0026m); for (int i = 0; i \u003c m; i++) { scanf(\"%d\", \u0026x); has_train[n][x][1] = true; for (int j = n - 1; j \u003e= 1; j--) { has_train[j][x + t[j]][1] = true; x += t[j]; } } return true; } int DP(int p, int tim) { int \u0026d = dp[p][tim]; if (tim \u003e T) return INF; if (tim == T) return p == n ? 0 : INF; if (vis[p][tim]) return d; vis[p][tim] = true, d = INF; d = DP(p, tim + 1) + 1; if (p \u003c n \u0026\u0026 has_train[p][tim][0]) d = min(d, DP(p + 1, tim + t[p])); if (p \u003e 1 \u0026\u0026 has_train[p][tim][1]) d = min(d, DP(p - 1, tim + t[p - 1])); return d; } int main() { while (read()) { int ans = DP(1, 0); if (ans \u003e= INF) printf(\"Case Number %d: impossible\\n\", ++kase); else printf(\"Case Number %d: %d\\n\", ++kase, ans); } return 0; } 【例子2】UVA 437 The Tower of Babylon 题意：给你n种有无数个的立方体，现在让你用这些立方体堆一个塔，每个立方体的底面长宽都要严格小于下面立方体的底面长宽，问你最高能堆多高 简单的分析 能看得出来是一个矩形嵌套的变种问题，用DAG模型建立来做会非常好码代码 一种立方体有三种摆放方式，假设一个立方体的长宽高为a、b、c，则三种摆放方式分别是以a、b、c为高的摆放方式，固一种立方体可以看成三个立方体 下面就是建立DAG了，如果一个立方体的底面长宽严格大于另一个底面长宽的立方体则连一条有向边过去 最后就DP就是求从某个节点出发的最大距离就是答案 注意到，无论是思考还是码代码都不需要再去想状态方程来，直接当成一个图求最远距离来做，为了加速，我用了邻接表来建立图 下面是代码 #include \u003ccstring\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; int n, kase = 0, head[100], cnt = 0, dp[500], vis[500]; struct rect{ int a, b, c; rect(){} rect(int a, int b, int c) : a(a), b(b), c(c) {} }r[100]; struct edges{ int to, next; edges(int to = 0, int next = -1) : to(to), next(next) {} }edge[10010]; bool ok(const rect\u0026 x, const rect\u0026 y) { return (x.a \u003e y.a \u0026\u0026 x.b \u003e y.b) || (x.b \u003e y.a \u0026\u0026 x.a \u003e y.b); } void add_edge(int u, int v) { edge[++cnt] = edges(v, head[u]); head[u] = cnt; } bool read() { scanf(\"%d\", \u0026n); if (!n) return false; int x[3]; for (int i = 0; i \u003c 3 * n;) { for (auto \u0026j : x) scanf(\"%d\", \u0026j); r[i++] = rect(x[0], x[1], x[2]); r[i++] = rect(x[0], x[2], x[1]); r[i++] = rect(x[1], x[2], x[0]); } memset(head, -1, sizeof head); memset(edge, 0, sizeof edge); memset(dp, 0, sizeof dp); memset(vis, 0, sizeof vis); cnt = 0; for (int u = 0; u \u003c 3 * n; u++) { for (int v = 0; v \u003c 3 * n; v++) { if (u == v) continue; if (!ok(r[u], r[v])) continue; add_edge(u, v);//邻接表建图 } } return true; } int DP(int u) { if (u \u003e= 3 * n) return 0; if (vis[u]) return dp[u]; int \u0026res = dp[u], Max = 0; res = r[u].c, vis[u] = true; for (int v = head[u]; ~v; v = edge[v].next) {//它的下一个节点 Max = max(Max, DP(edge[v].to)); } return res += Max; } int main() { while (read()) { int ans = 0; for (int i = 0; i \u003c 3 * n; i++) ans = max(ans, DP(i)); printf(\"C","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:3:6","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"4. 分类 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:4:0","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"① 线性DP ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:4:1","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"② 区间DP 区间dp一般是将状态定义成某某区间内的某个解 一般遍历方式 for(int len = 1; i \u003c= n; ++i) { // 先枚举区间长度 for (int i = 1, j = i + len - 1; j \u003c= n; ++j, ++i) { // 再枚举起始节点 // } } for(int i = n; i \u003e= 1; --i) { // 先枚举左端点 for (int j = i; i \u003c= n; ++j) { // 再枚举右端点 // } } ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:4:2","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"③ 树型DP 来自2021.3.22的更新，回来看了一下，以前的写博客也太蠢了吧，不想改了，直接看下面几篇博客[放博客链接] 所谓树状DP（树形DP）就是说一个动态规划的问题他的数据（或者子问题）之间是建立在树的基础上提问的，即父节点的最优是由其子节点的最优来推出来的（大部分是这样）。 【例题1】HDU 1520 Anniversary party 大致题意：一棵树，一共有n个节点，父节点和子节点不能同时选，每个节点都有权值，问怎么选权值总和最大 显然是要用到树DP了废话，给我的感觉有点像是一个变种的01背包问题不清楚 简单的分析： 对于一个节点有两种可能，选或者不选。那么我们就这样定义状态：dp[i][j], $1 \\le i \\le n$、 $0 \\le j \\le 1$，表示i节点的权值总和最大，$j = 0$表示不选择当前节点时的权值总和最大，$j = 1$表示选择当前节点时的权值总和最大 当一个节点选了之后，那么它的所有子节点都不能选（当然它的父节点也不能选，但是考虑到我们这题用dp来解，为了不扰乱思维，我们只看它和它的子节点），看图： 黄色为选，灰色为不选，父亲节点选了后，它下面的2、3、4、5、6……都不能选了（清楚明了），喂喂喂，你可别再想1号节点的父亲的事了，我们正在dp呢，它父亲节点以后它爷爷节点会搞定的，别再多想了，不然会扰乱思维。那么很容易得到这部分的转移方程(son[i]表示i的子节点, w[i]表示当前节点的权值)： $$ dp[i][1] = w[i] + \\sum dp[son[i]][0] $$ 如果这个节点不选呢？不说话，先看图： 还是一样：黄色为选，灰色为不选。可能有人很奇怪：“哎呀，为什么儿子还有不选的情况，既然父亲都不选了，那么他的儿子全选不就总和最大了吗”。别急，且听我慢慢道来，如果这个是一条链，那么你这种想法可能就是对的，但这个是一棵树，之所以会有这个疑惑是因为我的图没上画完呢。 说明：方形内的数字是节点的权值。显然如果要总和最大，那么5号节点就不能选，因为它的5号几点的子节点（8号节点）的权值更大（清楚明了😁）。所以又可以得到相应的转移方程： $$ dp[i][0] = \\sum max(dp[son[i]][1], dp[son[i]][0]) $$ 最后我这题采用的是自顶向下的递归来求的，最后根节点是通过回溯得来，当然如果喜欢自底向上的童鞋可以采用栈来遍历也可以哦。而我们的状态转移方程总结为 $$ dp[i][1] = w[i] + \\sum dp[son[i]][0]，\\ \\ (选择i节点) $$ $$ dp[i][0] = \\sum max(dp[son[i]][1], dp[son[i]][0]) \\ \\ (不选择i节点) $$ 那么最后的答案就是根节点的选和不选两状态的最大值,即 max(dp[root][1], dp[root][0])，（其余细节看注释）。 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cvector\u003e#define debug(n) printf(\"(%d)\", n); using namespace std; const int N = 6e3 + 10; int n, l, k, w[N], dp[N][2]; vector\u003cint\u003e son[N]; void dfs(int r) { dp[r][0] = 0, dp[r][1] = w[r]; //初始化，方便转移时的求和 for (auto s : son[r]) { //遍历所有子节点 dfs(s); //先求子节点的最优 //↓然后回溯↓ dp[r][1] += dp[s][0]; //当前节点选 dp[r][0] += max(dp[s][0], dp[s][1]); //当前节点不选 } } int main() { while (scanf(\"%d\", \u0026n) != EOF) { //不定组输入，输入节点数 vector\u003cint\u003e fa[N]; //记录节点的父亲，用来寻找根节点 for (int i = 1; i \u003c= n; i++) scanf(\"%d\", w + i); //输入节点权值 while (scanf(\"%d%d\", \u0026l, \u0026k) != EOF) { //输入节点之间的关系 if (l == 0 \u0026\u0026 k == 0) break; //结束输入 son[k].push_back(l); fa[l].push_back(k); } //寻找根节点 int root = 1; for (int i = 1; i \u003c= n; i++) { root = fa[i].size() == 0 ? i : root; } //开始转移 dfs(root); int ans = dp[root][1] \u003e dp[root][0] ? dp[root][1] : dp[root][0]; printf(\"%d\\n\", ans); //输出答案 //下面全是清空数组的代码，忽略就好 memset(dp, 0, sizeof dp); memset(w, 0, sizeof w); for (int i = 1; i \u003c= n; i++) { for (auto it = son[i].begin(); it != son[i].end();) it = son[i].erase(it); } } return 0; } 平均时间复杂度应该是O($n$) 空间复杂度是O(n)，，应该不是O($ n ^ 2$),因为用的是vector。 【例题2】HDU 2196 Computer 大致题意：给你一个棵无向树，每个相连的节点之间都有个距离，即边有权，让你求出每个节点距离该节点的最远节点的距离。 又是一道树状DP都放树状DP里了，怎么可能不是呢😂，但是这题是无向的，恰恰是因为这样给了一丝丝方便。 简单的分析 首先既然是无向，为了方便我们把他看作有向的，就设1号节点（1号电脑）是根节点，任性图方便。 每个节点，他只有两种状态（除根节点，和叶子节点），一、要么是从它的子节点过来的距离；二、要么不是从它的子节点过来。如图不画了，自己脑补😂。 那么我们就这样定义状态：dp[i][j], i表示的是节点编号（$1 \\le i \\le n$），而 j（$0 \\le j \\le 1$）的话就是，当 $j = 0$ 时表示 i 节点到其最远从属于它的叶子节点 （即他的子节点过来）的距离， $j = 1$ 时表示不是从它子节点过来的最远距离。 对于从子节点到来本节点的距离，只需要对比大小便可，为了方便思考，我把题目的例子改了一下，如图（这回有图啊！！） 说明：方形里的数字代表距离（边权）。不难看出从2号节点的子节点（7号节点、6号节点、3号节点）到2号节点的最大距离就是子节点到来的最大值（老规矩，别想他的父节点），有点拗口，看方程（son[i]表示 i 节点的子节点, len(son[i])则表示它的子节点到他它自己的距离）： $$ dp[i][0] = max\\lbrace dp[son[i]][0] + len(son[i])\\rbrace $$ 简单吧，下面就来看看比较难的：不是从他的子节点到来的最大距离。先上图（画的好累）： 清楚吧，不用解释了吧，好吧好吧，我们把目光放到3号节点上，如果计算不是从它子节点过来的距离的话，只有两种可能，其中最简单的一条路就是从它的爷爷节点来再到他的父亲节点来的距离（黄色箭头路线），为什么只有一条？因为它肯定只有一个爷爷和父亲，不可能有两个，不可能！！！这个世界还是很美好滴；第二种可能就是从它的兄弟节点来，这个比较多路（蓝色和绿色箭头路线），因为它可以有很多兄弟，也可以没有兄弟（独生子😁）。这样理解的话方程就能出来了（fa[i]表示 i 节点父节点，所以son[fa[i]]就代表 i 节点 的兄弟节点，len的含义和上面一样）： $$ dp[i][1] = max\\lbrace dp[fa[i]][1]+ len(i), dp[son[fa[i]]][0] + len(son[fa[i]]\\rbrace+ len(i)) $$ 化简一下 $$ dp[i][1] = max\\lbrace dp[fa[i]][1], dp[son[fa[i]]][0] + len(son[fa[i]])\\rbrace + len(i) $$ 解释：max内部的前者是上述的第一种可能，后者是第二种可能，是不是简单明了😁，但是对于这个状态还利用到来我们第一个讲的（$j = 0$）状态。所以我们在计算时要先把所有 $j = 0$ 的状态先计算，即做两遍dfs（当然你也可以把他们的dfs放到一起，都一样的，为了方便我不会😂我选择做两遍dfs），注意：这个状态方程的状态，即 $j = 1$ 时的状态一定要自顶向下计算，因为方程中还用到了它父亲的第二（$j = 1$）状态。所以最终的状态转移方程总结为： $$ dp[i][0] = max\\lbrace dp[son[i]][0] + len(son[i])\\rbrace， \\ \\ （第一种状态） $$ $$ dp[i][1] = max\\lbrace dp[fa[i]][1], dp[son[fa[i]]][0] + len(son[fa[i]])\\rbrace + len(i) \\ \\ （第二种状态） $$ 那么最后的答案是什么呢？显然就是每个节点的 $j = 0$ 和 $j = ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:4:3","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"④ 状态压缩DP 状态压缩更像是一种思想，而不是一种方法。当有些问题很可能不存在有效的(多项式级的)算法时，利用状态压缩是可以使得题目简单些。一般情况下状态压缩是把状态压缩成二进制的形式来表示（也有三进制的）一个集合，通过压缩可以把不必要的信息给去掉，从而减少冗余。 常见的二进制使用 都是最基础的：与、或、非、异或 在c++中分别是 \u0026（与）、|（或）、!（非）、^（异或） 左右移：« （左移），例如 5（00000101）« 1 = 10（00001010）； »（右移）,例如 5 （00000101）» 1 = 2 (00000010)。 取反：~（1 变 0，0 变 1），例如 ~ 00000101 = 11111010 查看是否有相邻的 1（状压用得多，多用来去掉不合法的状态）：x \u0026 (x » 1) == 0或者x \u0026 (x « 1) == 0：语句判断为真则没有相邻的1，否则有相邻的 1。例如 88（01011000）\u0026 44 (00101100) = 8 (00001000) $\\ne$ 所以有相邻的 1。（不懂就自己多举几个例子） 检查 a 是否是 b 的子集（状压也用得多）：a \u0026 b == a：语句判断真为是其子集，否则不是。例如 88 是 16 的子集，因为88（01011000）\u0026 16（00010000）= 16（00010000） 判断 a 和 b 是否有相同位的 1：a \u0026 b == 0：语句判断真为没有，否则有，很简单不解释 取末尾的 1：x \u0026 (-x)，例如 88（01011000）^ (-88)（10101000）= 8（00001000）——多用于树状数组 【例题 1】HDU 方格取数（1） 大致题意：给你一个方格，里面有数字，你可以在这些方格里面取数，但是不能取拥有公共边的方格，问你取出来的最大值为多少 一道挺标准的状压dp板子题，一开始用普通dp没做出来，后来发现用状压真的简单一些 简单的分析 对于每个格子只有两种状态：选或者不选，我们定义选中了则在相应的二进制位数为 1，否则为 0。例如5 （000101）表示一行中第一个数和第三个数被选中 对于一行有 n 个格子的总共的选择方式个数为 $2^n$ 既然都说了状压，那直接开压：把列压缩（对于这题行和列相同，压列是个人喜欢，更多情况下是压缩数据范围小的那个，你当然希望$2^n$越小越好啦） 下一步在输入之前把不合法的状态预处理了，只留下合法的，就是本题所说的不能选取拥有公共边的格子，即对于每一行状态不能有相邻的 1 然后是转移方程（很简单，并且不难想） $$ dp[i][now] = max\\lbrace dp[i - 1][pre] + w[now]]\\rbrace $$ 解释：i 表示第 i 行，now 表示当前行的二进制状态，pre 表示上一行的所有不与 now 具有相同位 1 的状态，可以用相与（\u0026）是否等于 0 来判断，若等于 0 则没有相同我位的 1，否则有；w[now]表示当前状态的选取方格的总值 那么最后的答案就是最后一行中的最大值 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; const int maxn = 25; unsigned int nums[maxn][maxn];//用无符型是因为HDU的尿性，不这样可能会超内存 vector\u003cunsigned int\u003e v;//用来存储合法的状态 int n; int val(int r, int v) {//求当前行状态的总价值 int res = 0, i = n; while (v != 0) { if (v \u0026 1) { res += nums[r][i]; } v \u003e\u003e= 1; i--; } return res; } int main() { while (scanf(\"%d\", \u0026n) != EOF) { v.clear(); //清空v数组 int choice = (1 \u003c\u003c n); //最大的状态数 for (int i = 0; i \u003c choice; i++) { if ((i \u0026 (i \u003c\u003c 1)) == 0) v.push_back(i);//预处理，选取合法的状态 } int len = v.size(); vector\u003cvector\u003cunsigned int\u003e\u003e dp(n + 1, vector\u003cunsigned int\u003e(len));//动态开辟数组，防止超内存 for (int i = 1; i \u003c= n; i++) {//输入 for (int j = 1; j \u003c= n; j++) { scanf(\"%d\", \u0026nums[i][j]); } } unsigned int Max = 0; for (int i = 1; i \u003c= n; i++) { for (int now = 0; now \u003c len; now++) { int w = val(i, v[now]); for (int pre = 0; pre \u003c len; pre++) {//枚举上一行的状态值 if ((v[now] \u0026 v[pre]) == 0) dp[i][now] = max(dp[i][now], dp[i - 1][pre] + w);//状态转移 } } } for (int i = 0; i \u003c len; i++) {//最后的结果 Max = max(Max, dp[n][i]); } printf(\"%d\\n\", Max); } return 0; } 表面上时间复杂度：O($n2^n2^n$),先别急，经过预处理，实际比这个小得多得多，每个$2^n$估计会被压到最大也就4000左右，据大佬测试 n 最大是17，不会有n = 20得样例；这下子复杂度就妥妥地能过了 空间复杂度：和时间复杂度同理，最大也就开个约为17 * 4000的数组 【例题2】洛谷 P1879 Corn Fields G 题目大意：给你一个M * N的方格土地，1 表示可以种玉米，0 表示不可以种玉米。拥有公共边的格子不能同时种上玉米，问你有多少种种的方式，什么都不种也算一种，答案对 1e8 取模 一道状压dp计数题，也是一个很好的板子题 简单的分析 M 和 N 的数据范围都很小，所以我还是采用了压缩列来做 要做的准备有：预处理本不合法的状态、把方格土地的01状态转换成十进制的表示，用个数组cor[i]来储存，方便后面判断是否能种、先把第一行合法的状态算了，把能种的且合法的都初始化为 1； 先看状态转移方程 $$ dp[i][now] += dp[i - 1][pre] $$ 解释：i 表示第 i 行，now 和 pre 分别表示当前行的状态和上一行的状态，当然 now 的前提是可以在当前行上种下来，即 now 是 cor[i] 的子集，而 pre 和 now 必须没有同位的 1 例如第 n 行，什么都不种（now = 0）的方法数就是上一行合法状态的和（其实所有和都可算，因为不合法的一定是0），而第 n 行状态 q 的种法的方法数就是上一行与他没有同位 1 状态的和（这里可以多一个判断，判断pre是否能在上一行上种起来，这样可以循环，当然不判断也行，因为不合法的一定为0） 最后的答案就是最后一行的dp和(稍微换了一下码风，可能会舒服点，因为循环和判断有点多) #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; const int M = 15, mod = 1e8; int m, n, nums[M], cor[M]; vector\u003cint\u003e v;//存储合法的状态 int main() { scanf(\"%d%d\", \u0026m, \u0026n); int choice = 1 \u003c\u003c n; for (int i = 0; i \u003c choice; i++) { if ((i \u0026 (i \u003c\u003c 1)) == 0) v.push_back(i); } int len = v.size(); vector\u003cvector\u003cint\u003e\u003e dp(m + 1, vector\u003cint\u003e(len, 0)); for (int i = 1; i \u003c= m; i++) { for (int j = 1; j \u003c= n; j++) { scanf(\"%d\", \u0026nums[j]); if (!nums[j]) continue; cor[i] |= (1 \u003c\u003c (j - 1));//把每一行的方块状态转换成对应的十进制 } } int ans = 0; for (int i = 0; i \u003c len; i++) { //先处理第一行，方便后面计算 if ((v[i] \u0026 cor[1]) != v[i]) continue; dp[1][i] = 1; } for (int i = 2; i \u003c= m; i++) { for (int j = 0; j \u003c len; j++) { if ((v[j] \u0026 cor[i]) != v[j]) continue; for (int k = 0; k \u003c len; k++) { if ((v[j] \u0026 v[k]) != 0) continue; if ((v[k] \u0026 cor[i - 1]) != v[k]) ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:4:4","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"⑤ 数位DP 篇幅过长已搬出，见数位dp ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:4:5","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"5. 优化dp的手段 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:5:0","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"① 矩阵优化 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:5:1","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"② 数据结构优化 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:5:2","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"③ 单调队列优化 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:5:3","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"④ 决策单调性优化 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:5:4","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"⑤ 二进制优化 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:5:5","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"⑥ 斜率优化 ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:5:6","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"⑦ 四边形不等式优化 未完待续（以后有空补充）…… ","date":"2020-08-19","objectID":"/2020/08/dp%E6%80%BB%E7%BB%93/:5:7","tags":["dp"],"title":"DP总结","uri":"/2020/08/dp%E6%80%BB%E7%BB%93/"},{"categories":["紫书刷题录-ch8"],"content":"Bin Packing 题意：给你n个物品，每个物品的重量为$w_i$，你有容量为w的背包，每个背包最多只能装两件物品，问你最少要多少背包来装 贪心就好了，贪心策略：将物品按重量排序，如果最重和最轻的物品一起不超过w就放一起，然后就让次重和次轻的放一起；否则重的单独放在一个背包，然后让次重的背包和最轻的一起，以此循环 代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e using namespace std; const int M = 1e5 + 5; int n, w, wi[M]; int main () { int t; scanf(\"%d\", \u0026t); while (t--) { scanf(\"%d%d\", \u0026n, \u0026w); for (int i = 0; i \u003c n; i++) scanf(\"%d\", wi + i); sort(wi, wi + n); int l = 0, r = n - 1, ans = 0; while (l \u003c= r) { if (wi[l] + wi[r] \u003c= w) l++, r--; else r--; ans++; } if (t) printf(\"%d\\n\\n\", ans); else printf(\"%d\\n\", ans); } return 0; } ","date":"2020-08-18","objectID":"/2020/08/uva1149/:1:0","tags":["题解","贪心"],"title":"UVA1149","uri":"/2020/08/uva1149/"},{"categories":["紫书刷题录-ch8"],"content":"Unique Snowflakes 题意：给你一个长度为$n(n \\le 1000000)$的数组，问你最长有不重复数字的连续子序列有多长 用set和map的速度都差不多，set记录是否重复，map记录当前数字在此之前最近出现的位置，如果没有就是-1 如果嫌set和map慢的话直接用unordered_set或者unordered_map 这里用了上次偶遇了一种很牛逼很简洁的hash方式后就喜欢上这个hash，跑进了100ms 代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e using namespace std; const int M = 1e6 + 10, H = 0xfffff; int n, arr[M], last[M]; struct Hash{ int real[H + 5], val[H + 5]; void clear() { memset(val, -1, sizeof val); }//初始化-1 int\u0026 operator[] (const int \u0026k) { int i = k \u0026 H; while (real[i] != k \u0026\u0026 ~val[i]) i = (i + 1) \u0026 H; real[i] = k; return val[i]; } }h; int main() { int t; scanf(\"%d\", \u0026t); while (t--) { scanf(\"%d\", \u0026n); h.clear(); memset(last, -1, sizeof last); for (int i = 0; i \u003c n; i++) { scanf(\"%d\", arr + i); last[i] = h[arr[i]]; h[arr[i]] = i; } int ans = 0, l = 0, r = 0; while (r \u003c n) { while (r \u003c n \u0026\u0026 last[r] \u003c l) r++; ans = max(ans, r - l); l = last[r] + 1; } printf(\"%d\\n\", ans); } return 0; } ","date":"2020-08-18","objectID":"/2020/08/uva11572/:1:0","tags":["题解","思维"],"title":"UVA11572","uri":"/2020/08/uva11572/"},{"categories":["紫书刷题录-ch8"],"content":"Wine trading in Gergovia 题意：有n个村庄，每个村庄都有对酒的需求，正数代表要送出多少酒，负数代表需要多少酒，把k单位的酒运到相邻的村庄要k单位的体力，让你计算最小需要的体力 对于第一个村庄，他的需求量x无论正负，都需要右边的村庄搬过来或者搬过去右边的村庄，然后把多余的需求继承到下一个村庄，和紫书上讲的思想差不多 代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003ccmath\u003e using namespace std; using ll = long long; const int M = 1e5 + 10; int n; ll arr[M], ans; int main() { while (scanf(\"%d\", \u0026n), n) { ans = 0; for (int i = 0; i \u003c n; i++) { scanf(\"%lld\", arr + i); } for (int i = 0; i \u003c n - 1; i++) { ans += abs(arr[i]), arr[i + 1] += arr[i]; } printf(\"%lld\\n\", ans); memset(arr, 0, sizeof arr); } return 0; } ","date":"2020-08-18","objectID":"/2020/08/uva11054/:1:0","tags":["题解","思维"],"title":"UVA11054","uri":"/2020/08/uva11054/"},{"categories":["紫书刷题录-ch8"],"content":"4 Values whose Sum is 0 题意：给你4个长度为$n(n \\le 4000)$的集合，让你在4个集合里分别取a、b、c、d，使得$a + b + c + d = 0$，问你有多少种取法 按紫书说的“中途相遇法”，从象个不同的方向来解决问题，最终“汇集”在一起 用哈希记录$a + b$，然后再计算$-c - d$的哈希个数就好了，用slt提供的unordered_map足够过这题了，跑了6000ms多，a掉了 后来看了一位大佬自己写的hash，跑了一下，平均650ms，一个很快的哈希表 原理大概和线性探查法差不多，不过这里用的不是取余（取余很慢），这里用的位运算里的与运算，保证了数值在给定的哈希范围内 代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e using namespace std; const int M = 4e3 + 10, H = 0x7fffff; int n, arr[5][M]; struct Hash{ int real[H + 5], val[H + 5] void clear() { memset(val, 0, sizeof val); } int\u0026 operator[] (const int\u0026 num) { int i = num \u0026 H; while (val[i] \u0026\u0026 real[i] != num) i = (i + 1) \u0026 H; real[i] = num; return val[i]; } }h; void solve() { scanf(\"%d\", \u0026n); h.clear(); for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c 4; j++) { scanf(\"%d\", \u0026arr[j][i]); } } for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j++) { h[arr[0][i] + arr[1][j]]++; } } int ans = 0; for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j++) { ans += h[- arr[2][i] - arr[3][j]]; } } printf(\"%d\\n\", ans); } int main() { int T, f = 1; scanf(\"%d\", \u0026T); while (T--) { if (f) f = !f; else puts(\"\"); solve(); } return 0; } ","date":"2020-08-17","objectID":"/2020/08/uva1152/:1:0","tags":["题解","思维","哈希"],"title":"UVA1152","uri":"/2020/08/uva1152/"},{"categories":["紫书刷题录-ch8"],"content":"Building for UN 题意：有一栋楼，有$n(n \\le 50)$个国家要开会，每个国家至少分配一个位置，让你输出一种方案，H层，每层W行L列，使得任意两个国家要能相邻，层数也算相邻 按紫书说的构造一种解出来，只需要两层就好了，每层$n \\times n$的格子，第一层第i行是第i个国家,第二层第j列是第j个国家， 这个模型有点像放筷子，有n双筷子，分别都有左和右，要想让每个左筷子都能接触到其他右筷子的方案就是在第一层筷子横着放，第二层竖着放就行了 代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003eusing namespace std; int n; char str[55]; void solve() { printf(\"%d %d %d\\n\", 2, n, n); for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j++) printf(\"%c\", str[i]); puts(\"\"); } puts(\"\"); for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j++) printf(\"%c\", str[j]); puts(\"\"); } } int main() { for (int i = 0; i \u003c 26; i++) str[i] = 'a' + i; for (int i = 0; i \u003c 26; i++) str[26 + i] = 'A' + i; while (~scanf(\"%d\", \u0026n)) solve(); return 0; } ","date":"2020-08-17","objectID":"/2020/08/uva1605/:1:0","tags":["题解","思维"],"title":"UVA1605","uri":"/2020/08/uva1605/"},{"categories":["紫书刷题录-ch8"],"content":"Stacks of Flapjacks 题意：给你一个序列，每次选一个数k，从序列的后往前数第k个数然后把它及它之前时数都翻转一下，问你一种选法使得序列从小到大排好序 有点像选择排序，不过为了不影响后面的，应该先把排好最大的数，如果已经就位就排第二大的数，具体策略是先把它调到最前面再调到相应的正确位置，一直排到有序为止 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e using namespace std; int cnt, arr[50], tmp[50]; char line[150]; void solve() { memcpy(tmp, arr, sizeof(int) * cnt); sort(tmp, tmp + cnt); int indx = cnt - 1; for (int i = cnt - 1; i \u003e= 0; i--) { if (tmp[indx] == arr[i]) { indx--; } else { int nums = i, k = cnt - i; while (arr[nums] != tmp[indx]) { nums--, k++; } if(nums != 0) { reverse(arr, arr + nums + 1); printf(\"%d \", k); } reverse(arr, arr + i + 1); printf(\"%d \", cnt - i); indx--; } } puts(\"0\"); } bool read() { if (fgets(line, sizeof line, stdin) == nullptr) return false; printf(\"%s\", line); char *tmp = line; cnt = 0; while (1) { sscanf(tmp, \"%d\", \u0026arr[cnt++]); tmp = strchr(tmp, ' '); if (tmp == nullptr) break; tmp++; } return true; } int main() { while (read()) solve(); return 0; } ","date":"2020-08-17","objectID":"/2020/08/uva120/:1:0","tags":["题解","思维"],"title":"UVA120","uri":"/2020/08/uva120/"},{"categories":null,"content":"Egyptian Fractions (HARD version) 题意：埃及分数问题困难版，问你一个真分数$a/b$，在表达成$a/b = 1/c + 1/d ……$，选的分数尽量少，相同情况下自小的分数尽量大，限制有$k(k \\le 5)$个数不能用来做分母，让你求解 思路，IDA*的经典题，和普通埃及分数差不多的写法，就是要加一个限制，即有些数不能用 一开始写了一个分数的结构体，后来发现没必要，直接IDA*就好了 注意几个剪枝的地方， 到达目标层时 判断分子是否为1 判断最后一个分母是否重复 判断最后一个分母是否可用 判断是否是更优解 未达到目标层时 预测选用当前的抉择是否会超出目标层（IDA*的关键剪枝） 判断当前抉择的分母是否可用 代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e using namespace std; using ll = long long; ll kase = 0, can[1005], k, ans[10000], tmp[10000], a, b, x; ll gcd(ll a, ll b) { ll m = 1; while(m) m = a % b, a = b, b = m; return a; } bool dfs(ll now, const ll \u0026h, ll first, ll a, ll b) { if (now == h) { if (a != 1) return false; if (b \u003c 1001 \u0026\u0026 can[b]) return false; if (b == tmp[h - 2]) return false; tmp[h - 1] = b; if (ans[h - 1] == 0) memcpy(ans, tmp, sizeof(ll) * h); for (int i = h - 1; i \u003e= 0; i--) { if (ans[i] == tmp[i]) continue; else if (ans[i] \u003e tmp[i]) memcpy(ans, tmp, sizeof(ll) * h); break; } return true; } bool ok = false; for (ll i = max(first, b / a) + 1; ; i++) { if (a * i \u003e= (h - now + 1) * b) break; if (i \u003c 1001 \u0026\u0026 can[i]) continue; tmp[now - 1] = i; ll g = gcd(b * i, a * i - b); if (dfs(now + 1, h, i, (a * i - b) / g, b * i / g)) ok = true; } return ok; } void solve() { scanf(\"%lld%lld%lld\", \u0026a, \u0026b, \u0026k); printf(\"Case %lld: %lld/%lld=\", ++kase, a, b); while (k--) { scanf(\"%lld\", \u0026x); can[x] = true; } for (ll i = 1; ; i++) { if (dfs(1, i, 0, a, b)) { for (ll j = 0; j \u003c i - 1; j++) printf(\"1/%lld+\", ans[j]); printf(\"1/%lld\\n\", ans[i - 1]); break; } } memset(tmp, 0, sizeof tmp); memset(can, 0, sizeof can); memset(ans, 0, sizeof ans); } int main() { int T; scanf(\"%d\", \u0026T); while (T--) solve(); return 0; } ","date":"2020-08-16","objectID":"/2020/08/uva12558/:1:0","tags":["题解","IDA*","迭代加深搜","DFS"],"title":"UVA12558","uri":"/2020/08/uva12558/"},{"categories":["紫书刷题录-ch7"],"content":"Overlapping Squares 题意：给你个$4 \\times 4$的网格图，问你有没有可能用不超过6张$2 \\times 2$的纸叠成给的样子 一开始想破脑袋都想不出来应该怎么验证是否相同，没办法还是问了下度娘，知道思路后自己写了代码ac了 想不出的是如何验证正确性，一开始想着是否要把被遮住的部分补全然后验证，但这样又怎么验证？看了看别人的思路发现自己是真的蠢，直接模拟用$2 \\times 2$的纸一张一张地放上去不就好了吗 dfs最多也就6层，纸放下去只有9种可能，能想到这里就可以直接dfs模拟了 ac代码如下 #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e using namespace std; char g[10][20], p[10][20]; bool vis[10]; bool init() { for (int i = 0; i \u003c 5; i++) { fgets(g[i], 15, stdin); if (g[i][0] == '0') return false; } memset(p, ' ', sizeof p); memset(vis, 0, sizeof vis); return true; } bool check() { for (int i = 0; i \u003c 5; i++) { for (int j = 0; j \u003c 9; j++) if (p[i][j] != g[i][j]) return false; } return true; } bool dfs(int num) { if (check()) return true; if (num == 6) return false; char tmp[10][20]; memcpy(tmp, p, sizeof p); for (int i = 0; i \u003c 9; i++) { if (vis[i]) continue; vis[i] = true; int r = i / 3, c = (i % 3) * 2; p[r + 1][c] = p[r + 2][c] = p[r + 1][c + 4] = p[r + 2][c + 4] = '|'; p[r][c + 1] = p[r + 2][c + 1] = p[r][c + 3] = p[r + 2][c + 3] = '_'; for (int j = 1; j \u003c 4; j++) p[r + 1][c + j] = ' '; p[r + 2][c + 2] = ' '; if (dfs(num + 1)) return true; vis[i] = false; memcpy(p, tmp, sizeof p);//回溯 } return false; } int main () { int kase = 0; while(init()) { printf(\"Case %d: \", ++kase); if (dfs(0)) puts(\"Yes\"); else puts(\"No\"); } return 0; } ","date":"2020-08-15","objectID":"/2020/08/uva12113/:1:0","tags":["题解","DFS","回溯"],"title":"UVA12113","uri":"/2020/08/uva12113/"},{"categories":["紫书刷题录-ch7"],"content":"Pipeline Scheduling 历经千辛万苦终于a了这题 题意：一台电脑有5个工作单元(unit0 ~ unit4)，有10(0 ~ 9)个程序需要完成，每个程序都要在n$(n \u003c 20\u003e)$的时间片完成，在同一时间里，一个单元只能执行一个程序，开始执行后就要严格按顺序执行完，问你最小的完成10个程序的时间是多少 从读题到思考到ac用了近两天，下面我将会从运行时间慢到运行时间快，tle到ac开始阐释解决这题时的坎坷 首先是这题怎么dfs 一开始想的时候想到了一个最笨的方法：根据时间一步一步地dfs下去，但这样的话绝对不行，因为如果n = 19,最多会递归190层，就算考虑剪枝，如果答案就是上百的，那也受不了 想了很久终于想到一个办法就是根据程序来递归，即递归（0 ~ 9）这样的话最多也就9层 用一个二维的bool数组run[i][j]来储存状态，代表第i个工作单元在j时间时的运行情况，false代表是空闲的，true代表是正在工作 对于一开始第一个程序即程序0肯定就是从0时刻时开始运行是最优的，所以dfs从程序1开始 对于第$k$个程序来说，如果开始的时间是$s$，则它结束的时间一定是$s + n$，则第$k + 1$个程序可以在$s + 1$到$s + n + 1$之间（包括端点）的时间里开始运行 到这里dfs的运行方式就很明朗了，只需要暴力枚举每个$s + 1$到$s + n + 1$的位置开始运行下一个程序就行了 那么剪枝呢？这个dfs的方法直接对比先前算好最小完成时间的和当前程序的结束时间做对比来剪 上述的方法是会tle的，先别急，一步一步走到ac这个开头不能少 上述dfs方法的代码 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e using namespace std; int n, Min; char unit[6][25]; bool run[5][500]; bool check(int s) { for (int i = 0; i \u003c n; i++) for (int j = 0; j \u003c 5; j++) if (unit[j][i] == 'X' \u0026\u0026 run[j][i + s]) return false; return true; } void dfs(int num, int s) { if (s + n \u003e= Min) return; if (num == 10) { Min = s + n; return; } for (int i = s + 1; i \u003c= s + n; i++) { if (!check(i)) continue; for (int j = 0; j \u003c 5; j++) for (int k = 0; k \u003c n; k++) if (unit[j][k] == 'X') run[j][i + k] = true; dfs(num + 1, i); for (int j = 0; j \u003c 5; j++) for (int k = 0; k \u003c n; k++) if (unit[j][k] == 'X') run[j][i + k] = false; } } inline void init(){ memset(run, 0, sizeof run); Min = 0xffff; } int main () { while (scanf(\"%d\", \u0026n), n) { for (int i = 0; i \u003c 5; i++) { scanf(\"%s\", unit[i]); } init(); for (int i = 0; i \u003c n; i++) for (int j = 0; j \u003c 5; j++) if (unit[j][i] == 'X') run[j][i] = true; //程序0开始运行 dfs(1, 0); printf(\"%d\\n\", Min); } return 0; } 上面的代码运行n = 19的时候，要在内心默念三四秒才会出答案，显然是超级慢了 下面阐述我是如何一步一步优化到ac甚至更快的结果的 对于上述的代码，我自己在运行的时候是很绝望的，自己跑都能感觉到很慢。后来就度娘了一下，学到了一种比较聪明的方法 考虑第一个程序运行时哪些工作单元是在工作中的，上面说过对于下一个单元它只能在$s + 1$到$s + n + 1$内开始，但是并不是所有时间都可以开始的，它下一个能开始运行的时间是具有跳跃性的，就比如说题中的样例，他就只能当前程序运行的第2、3、6、7的时间开始，别的时间开始都会有冲突，对于后面的所有程序都是只能在上一个程序的第2、3、6、7的时间开始 把跳跃的时间用数组jump[cnt]记录下来，这样的好处就是可以少枚举一些不必要的程序开始时间，$cnt$是可跳跃的个数 还有一个好处就是可以大大地剪枝，具体的剪枝操作是：假如当前递归到了第$num$个数字，上一个程序的开始时间是$s$,则最少还要$s + jump[0] \\times (10 - num) + n$的时间完成10个程序运行的时间，这样就可以和先前算好的$Min$进行对比剪枝了 优化好的代码如下，在电脑上运行20个$n = 19$的不同数据都能很快地出答案，但很可惜，交上去还是tle了 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e using namespace std; int n, jump[25], Min, cnt = 0; char unit[6][25]; bool run[5][500]; bool check(int s) { for (int i = 0; i \u003c n; i++) for (int j = 0; j \u003c 5; j++) if (unit[j][i] == 'X' \u0026\u0026 run[j][i + s]) return false; return true; } void dfs(int num, int s) { if (s + n \u003e= Min) return; if (s + jump[0] * (10 - num) + n \u003e= Min) return; if (num == 10) { Min = s + n; return; } for (int i = 0; i \u003c cnt; i++) { if (!check(s + jump[i])) continue; for (int j = 0; j \u003c 5; j++) for (int k = 0; k \u003c n; k++) if (unit[j][k] == 'X') run[j][s + jump[i] + k] = true; dfs(num + 1, s + jump[i]); for (int j = 0; j \u003c 5; j++) for (int k = 0; k \u003c n; k++) if (unit[j][k] == 'X') run[j][s + jump[i] + k] = false; } } inline void init(){ memset(run, 0, sizeof run); cnt = 0; Min = 0xffff; } int main () { while (scanf(\"%d\", \u0026n), n) { for (int i = 0; i \u003c 5; i++) { scanf(\"%s\", unit[i]); } init(); for (int i = 0; i \u003c n; i++) for (int j = 0; j \u003c 5; j++) if (unit[j][i] == 'X') run[j][i] = true; for (int i = 1; i \u003c= n; i++) if(check(i)) jump[cnt++] = i; dfs(1, 0); printf(\"%d\\n\", Min); } return 0; } 这个代码还有优化的空间的，就是二进制状态压缩，对于之前设定的run[5][500]的数组可以进行压缩成一维的run[500]，用二进制代表时间i时5个工作单元的状态，0代表空闲，1代表工作中 别忘了，要把输入的最初结果也要二进制压缩 这样进行压缩速度快了不少，少了一重长度为5的循环，可能递归常数大的原因，亦或是上面那个代码就tle了一点点的原因，所以二进制优化后直接ac了 ac代码如下，跑了440ms #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e using namespace std; int n, Min, unit[25], run[500], jump[25], cnt = 0; bool check(int s) { for (int i = 0; i \u003c n; i++) if (unit[i] \u0026 run[i + s]) return false; return true; } void dfs(int num, int s) { if (s + n \u003e= Min) return; if (s + (10 - num) * jump[0] + n \u003e= Min) return; if (num == 10) { Min = s + n; return; } for (int i = 0; i \u003c cnt; i++) { if (!check(jump[i] + ","date":"2020-08-14","objectID":"/2020/08/uva690/:1:0","tags":["题解","DFS","回溯"],"title":"UVA690","uri":"/2020/08/uva690/"},{"categories":["紫书刷题录-ch7"],"content":"The Domino Effect 题意：一个多米诺骨牌有两个面，一共有28个不同的多米诺骨牌，放在那，可能横着，可能竖着，这样就形成了一个$7 \\times 8$的一个数字图，问你所有可能的摆放方式 dfs就好了，一开始没想到怎么dfs，绞尽脑汁，一开始一格一格来，失败，后来采用每一行都用一个二进制状态来描述是横还是竖，还是失败了，最后看了下题解，豁然开朗 也是dfs，但是不能再单纯地一格一格得dfs，要一行一行来，不然可能会像我一开始那样，会遗漏很多格子没递归到，所以要一行一行来，方式就是每行一格一格地递归，递归到最后一列的才换行（代码24行处），最终将28个牌都遍历一遍才能输出 至于骨牌号码的储存方式，考虑到数据小，所以用了压缩来储存起骨牌的号码 代码如下 #include \u003ccstring\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e using namespace std; int domi[10][10], id[400], ans[10][10], nums = 0, kase = 0; bool vis[30]; const int dr[] = {1, 0}, dc[] = {0, 1}; inline int ID(int a, int b) { return (min(a, b) \u003c\u003c 6) | max(a, b); } inline bool check(int r, int c) { return r \u003c 7 \u0026\u0026 c \u003c 8; } void init(){ memset(ans, 0, sizeof ans); memset(vis, 0, sizeof vis); nums = 0; } void dfs(int r, int c, int num) { if (num == 28) { nums++; for (int i = 0; i \u003c 7; i++) { for (int j = 0; j \u003c 8; j++) { printf(\"%4d\", ans[i][j]); } puts(\"\"); } puts(\"\\n\"); return; } if (c == 8) r++, c = 0; if (ans[r][c]) { dfs(r, c + 1, num); return; } for (int i = 0; i \u003c 2; i++) { int newr = r + dr[i], newc = c + dc[i]; int x = ID(domi[r][c], domi[newr][newc]), res = id[x]; if (!check(newr, newc) || vis[res] || ans[newr][newc]) continue; ans[r][c] = ans[newr][newc] = res, vis[res] = true; dfs(r, c + 1, num + 1); ans[r][c] = ans[newr][newc] = 0, vis[res] = false; } } int main () { int cnt = 0; bool ok = true, f = true; for (int i = 0; i \u003c= 6; i++) { for (int j = i; j \u003c= 6; j++) { id[ID(i, j)] = ++cnt; } } while (1) { for (int i = 0; i \u003c 7 \u0026\u0026 ok; i++) { for (int j = 0; j \u003c 8; j++) { if (!~scanf(\"%d\", \u0026domi[i][j])) { ok = false; break; } } } if (!ok) break; if (f) f = !f; else puts(\"\\n\\n\\n\\n\"); printf(\"Layout #%d:\\n\\n\", ++kase); for (int i = 0; i \u003c 7; i++) { puts(\"\"); for (int j = 0; j \u003c 8; j++) printf(\"%4d\", domi[i][j]); } printf(\"\\n\\nMaps resulting from layout #%d are:\\n\\n\\n\", kase); init(); dfs(0, 0, 0); printf(\"There are %d solution(s) for layout #%d.\\n\", nums, kase); } return 0; } ","date":"2020-08-13","objectID":"/2020/08/uva211/:1:0","tags":["题解","DFS","回溯"],"title":"UVA211","uri":"/2020/08/uva211/"},{"categories":["紫书刷题录-ch7"],"content":"Golygons 题意：一个网格图，现在给你图中$k(k \\le 50)$个障碍的坐标（坐标可能为负），不能继续上次的方向继续走也不能后退，这就意味着只能左右走，第$i$次走$i$个单位，从(0, 0)点出发，走了$n(n \\le 20)$次恰好回到(0, 0)点，让你输出所有可能的路线，按字典序输出 因为深度已知，所以我才用了DFS的方法，考虑到坐标可能有负数，所以我把坐标原点移动了一下，将(1000, 1000)记为原点，其余点也一样有同样变化，因为 $n \\le 20$， 所以1000够用 将答案用vector\u003cchar\u003e的一维数组存起来，因为vector里面自带字典序的排序，所以最后可以直接sort(ans, ans + num)排序（详细看代码），当然用vector\u003cstring\u003e来存，这样就不用再而外加多一维数组了，string也有push_back()（用append()也可以）和pop_back()函数，这样最后的排序就必须是sort(ans.begin(), ans.end()); 一个方案中一个坐标不能被访问两次，用个vis的布尔数组来记录是否被访问过 dfs两次，因为最开始是4个方向都可以走的 最后记得回溯 代码如下 #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; const int M = 1e3; int t, k, bn, num; bool isb[M + M][M + M], vis[M + M][M + M]; const char dir[] = \"ewns\"; const int dx[] = {1, -1, 0, 0}; const int dy[] = {0, 0, 1, -1}; vector\u003cchar\u003e ans[1000], tmp; void init() { num = 0; memset(isb, 0, sizeof isb); memset(vis, 0, sizeof vis); for (auto \u0026i : ans) i.clear(); } void dfs(int a, int b, int n, int d) { if (n == k) { if (a != M || b != M) return; ans[num++] = tmp; return; } for (int i = d; i \u003c 4 - 2 + d; i++) { int newx = a, newy = b; bool flag = true; for (int j = 0; j \u003c= n; j++) {//走n+1步 newx += dx[i], newy += dy[i]; if (isb[newx][newy]) { flag = false; break; }//遇到障碍就不行 } if (!flag || vis[newx][newy]) continue; vis[newx][newy] = true; tmp.push_back(dir[i]); dfs(newx, newy, n + 1, 2 - d); tmp.pop_back(); vis[newx][newy] = false; } } int main () { scanf(\"%d\", \u0026t); while (t--) { init(); scanf(\"%d%d\", \u0026k, \u0026bn); while (bn--) { int x, y; scanf(\"%d%d\", \u0026x, \u0026y); isb[x + M][y + M] = true;//障碍 } dfs(M, M, 0, 0); dfs(M, M, 0, 2); sort(ans, ans + num);//排序 for (int i = 0; i \u003c num; i++) { for (auto x : ans[i]) printf(\"%c\", x); puts(\"\"); } printf(\"Found %d golygon(s).\\n\\n\", num); } return 0; } ","date":"2020-08-12","objectID":"/2020/08/uva225/:1:0","tags":["题解","DFS","回溯"],"title":"UVA225","uri":"/2020/08/uva225/"},{"categories":["紫书刷题录-ch7"],"content":"Firetruck 题意：给你一个无向图，让你求出从1号节点到n号节点的所有路径，按顺序输出，具体看样例 DFS和BFS都可以，这里我用了DFS，利用了一个ans的vector数组来储存答案，根据题目要求，优先递归节点权值小的 注意：要先判断1号节点能否到达n号节点，不然会tle，这里我用了一个类似于并查集的思想来判断是否能到达n号节点 代码如下 #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003e#include \u003cqueue\u003e#include \u003cvector\u003e using namespace std; using vi = vector\u003cint\u003e; int t, cnt, Kase = 0, nums, fa[25]; bool vis[25], f, num[25], v[25]; vi nodes[25], ans; void init() { cnt = 0, nums = 0; for (auto \u0026i : nodes) i.clear(); ans.clear(); ans.push_back(1); memset(num, 0, sizeof num); memset(vis, 0, sizeof vis); memset(v, 0, sizeof v); vis[1] = true; for (int i = 1; i \u003c 25; i++) fa[i] = i; } void DFS(int n) { if (n == t) { cnt++, f = true; for (auto i : ans) { if (f) f = !f; else printf(\" \"); printf(\"%d\", i); } puts(\"\"); return; } for (auto x : nodes[n]) { if (vis[x]) continue; vis[x] = true; ans.push_back(x); DFS(x); vis[x] = false; ans.pop_back(); } } bool check(int n = 1) { for (auto i : nodes[n]) { if(!v[i]) { fa[i] = 1, v[i] = true; check(i); } } return fa[t] == 1; } int main () { while (~scanf(\"%d\", \u0026t)) { printf(\"CASE %d:\\n\", ++Kase); int u, v; init(); while (scanf(\"%d%d\", \u0026u, \u0026v), u + v) { nodes[u].push_back(v); nodes[v].push_back(u); } for (auto \u0026i : nodes) sort(i.begin(), i.end()); if(check()) DFS(1); printf(\"There are %d routes from the firestation to streetcorner %d.\\n\", cnt, t); } return 0; } ","date":"2020-08-12","objectID":"/2020/08/uva208/:1:0","tags":["题解","DFS","回溯"],"title":"UVA208","uri":"/2020/08/uva208/"},{"categories":["紫书刷题录-ch7"],"content":"Editing a Book 题意：给你一个排列，你一次能够剪切一段字串，然后在别的地方插入粘贴，让你求最少的剪切粘贴次数使得排列是1~n按顺序的 IDA*的题，每次规定递归的层数，长度为n的排列最多是剪切粘贴n - 1次 剪枝精髓：移动一次最多改变 3 个数字的后继数字，例如从{a，b，c，d}到{a, c, b, d},只有a, c, b（字母均代表区间）三个区间最后一个数的后继改变了 假设当前递归到d层，还有h个数字的后继不正确（最后一个数字的评判依据是是否是最后一个数，即$n - 1$），的最少还要遍历 $d + h / 3$ 层，当前设置了最大层数为Max, 则当 $d + h / 3 \u003e Max$ 即 $3 \\times d + h \u003e 3 \\times Max$ 就剪枝 代码如下，跑了300ms #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e using namespace std; int n, arr[15], tmp[15], kase = 0; bool check() { for (int i = 0; i \u003c n; i++) { if (arr[i] != i + 1) return false; } return true; } int h() { int cnt = 0; for (int i = 0; i \u003c n - 1; i++) { if (arr[i] + 1 != arr[i + 1]) cnt++; } if (arr[n - 1] != n) cnt++; return cnt; } bool DFS(int d, int Max) { if (check()) return true; //完成走人 if (d * 3 + h() \u003e 3 * Max) return false;//剪枝 int old[15], cut[10]; memcpy(old, arr, sizeof arr); for (int i = 0; i \u003c n; i++) { if (i == 0 || old[i] != old[i - 1] + 1) { //剪枝，只选取错误的剪切 for (int j = i; j \u003c n; j++) { int cnt = 0, len = j - i + 1; for (int k = 0; k \u003c n; k++) { if (k \u003c i || k \u003e j) cut[cnt++] = arr[k]; } for (int k = 0; k \u003c= cnt; k++) { memcpy(tmp, cut, sizeof(int) * k); memcpy(\u0026tmp[k], \u0026arr[i], sizeof(int) * (len)); memcpy(\u0026tmp[k + len], \u0026cut[k], sizeof(int) * (cnt - k)); memcpy(arr, tmp, sizeof(int) * n); if (memcmp(arr, old, sizeof(int) * n) == 0) continue;//和之前的一样，剪枝 if (DFS(d + 1, Max)) return true; memcpy(arr, old, sizeof arr); } } } } return false; } int main () { while (scanf(\"%d\", \u0026n), n) { for (int i = 0; i \u003c n; i++) { scanf(\"%d\", arr + i); } if (check()) { printf(\"Case %d: 0\\n\", ++kase); continue; } for (int i = 1; i \u003c n; i++) { if (DFS(0, i)) { printf(\"Case %d: %d\\n\", ++kase, i); break; } } } return 0; } ","date":"2020-08-11","objectID":"/2020/08/uva11212/:1:0","tags":["题解","DFS","回溯","IDA*"],"title":"UVA11212","uri":"/2020/08/uva11212/"},{"categories":null,"content":"The Morning after Halloween 题意：给你一个图，\"#“为障碍物，” “为通路，图里面最多有3个小写字母（a, b, c）和于其对应的大写字母（A, B, C），每次移动每个小写字母都有4个方向和不动5种方案，一次移动可以有多个小写字母一起移动，不能一个空格点不能同时有多个小写字母，问你最少要移动多少次才能让这些小写字母移动到对应的大写字母上 受紫书的启发，了解到了一个规矩图或者迷宫亦或是题目给的不是图（例如上次的倒水题），也能够利用“状态”来简化成一个平时我们更多看到的点对点的图，看来是几个能够相互连接产生关系的状态，就能考虑利用状态图来解 这题的“状态”是对每个坐标的压缩，压缩成一个一维的标志，看起来就好像是给每家每户上一个门牌号一样，因为坐标最大是（16, 16），也就是说最多有256个“门牌号”，这对于一个图来说还是有点多，幸运的是题中说每 $2 \\times 2$ 的格子至少有一个可走的点，这样我们只要考虑可以走的点就行了 按出现顺序给可走的点编上“门牌号”，并记录上字母的门牌号 还要记录每个点能到哪些点，这样就能当成一个有向图来看了 如果题目给的鬼的数量不到3个，那可以假装他给了，为没给的字母强行加个门牌号，并且他们已经到了自己的目的地，即相应的大小写字母在同一个位置 以下代码是单向的BFS, vj上测得是930ms #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cqueue\u003e#include \u003ccstring\u003e#include \u003cvector\u003e#include \u003ccctype\u003e using namespace std; const int M = 210, f = 0xff; char g[M][M]; int w, n, h, s[3], t[3], id[20][20], dir[M][M][M]; const int dx[] = {-1, 0, 1, 0, 0}; const int dy[] = {0, -1, 0, 1, 0}; inline bool check(int x, int y) { return x \u003e= 0 \u0026\u0026 y \u003e= 0 \u0026\u0026 x \u003c= w \u0026\u0026 y \u003c= h; } inline int ID(int a, int b, int c) { return (a \u003c\u003c 16) | (b \u003c\u003c 8) | c; }//状态压缩 inline bool move(int a, int b, int ago, int bgo) {//检车移动是否合法，即不能一步交换位置，不能到同一个位置 return (a == bgo \u0026\u0026 b == ago) || ago == bgo; } struct pos{ int x, y, n, go[5]; } p[200]; void BFS() { memset(dir, -1, sizeof dir); queue\u003cint\u003e q; q.push(ID(s[0], s[1], s[2])); dir[s[0]][s[1]][s[2]] = 0; while (q.size()) { int u = q.front(); q.pop(); int a = u \u003e\u003e 16, b = (u \u003e\u003e 8) \u0026 f, c = u \u0026 f; if (a == t[0] \u0026\u0026 b == t[1] \u0026\u0026 c == t[2]) return; // printf(\"()\"); for (int i = 0; i \u003c p[a].n; i++) { int ago = p[a].go[i]; for (int j = 0; j \u003c p[b].n; j++) { int bgo = p[b].go[j]; if (move(a, b, ago, bgo)) continue; for (int k = 0; k \u003c p[c].n; k++) { int cgo = p[c].go[k]; if (move(a, c, ago ,cgo))continue; if (move(b, c, bgo, cgo))continue; if (dir[ago][bgo][cgo] \u003e= 0) continue; dir[ago][bgo][cgo] = dir[a][b][c] + 1; q.push(ID(ago, bgo, cgo)); } } } } } int main() { while (scanf(\"%d%d%d\", \u0026w, \u0026h, \u0026n), w + h + n) { int cnt = 0; for (int i = 0; i \u003c h; i++) { getchar(); for (int j = 0; j \u003c w; j++) { char c = g[i][j] = getchar(); if (c == '#') continue; p[cnt].x = j, p[cnt].y = i, id[i][j] = cnt; if (islower(c)) s[c - 'a'] = cnt; if (isupper(c)) t[c - 'A'] = cnt; cnt++; } } for (int i = 0; i \u003c cnt; i++) { p[i].n = 0; for (int j = 0; j \u003c 5; j++) { int nowx = p[i].x + dx[j], nowy = p[i].y + dy[j]; if (g[nowy][nowx] == '#' || !check(nowx, nowy)) continue; p[i].go[p[i].n++] = id[nowy][nowx]; } } if (n \u003c= 2) p[cnt].n = 1, p[cnt].go[0] = cnt, s[2] = t[2] = cnt++;//假装给满了3个鬼 if (n \u003c= 1) p[cnt].n = 1, p[cnt].go[0] = cnt, s[1] = t[1] = cnt++; BFS(); printf(\"%d\\n\", dir[t[0]][t[1]][t[2]]); memset(p, 0, sizeof p); } return 0; } 以下代码是双向的bfs，测得是590ms #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cqueue\u003e#include \u003ccstring\u003e#include \u003cvector\u003e#include \u003ccctype\u003e using namespace std; const int M = 210, f = 0xff; char g[M][M]; int w, n, h, s[3], t[3], id[20][20], dir[M][M][M][2], ans; const int dx[] = {-1, 0, 1, 0, 0}; const int dy[] = {0, -1, 0, 1, 0}; inline bool check(int x, int y) { return x \u003e= 0 \u0026\u0026 y \u003e= 0 \u0026\u0026 x \u003c= w \u0026\u0026 y \u003c= h; } inline int ID(int a, int b, int c) { return (a \u003c\u003c 16) | (b \u003c\u003c 8) | c; } inline bool move(int a, int b, int ago, int bgo) { return (a == bgo \u0026\u0026 b == ago) || ago == bgo; } struct pos{ int x, y, n, go[5]; } p[200]; int BFS(queue\u003cint\u003e \u0026q, int st) { int u = q.front(); q.pop(); int a = u \u003e\u003e 16, b = (u \u003e\u003e 8) \u0026 f, c = u \u0026 f; if (dir[a][b][c][1 - st] != -1 \u0026\u0026 dir[a][b][c][st] != -1) {//如果碰头了就是答案了 return dir[a][b][c][1 - st] + dir[a][b][c][st]; } for (int i = 0; i \u003c p[a].n; i++) { int ago = p[a].go[i]; for (int j = 0; j \u003c p[b].n; j++) { int bgo = p[b].go[j]; if (move(a, b, ago, bgo)) continue; for (int k = 0; k \u003c p[c].n; k++) { int cgo = p[c].go[k]; if (move(a, c, ago ,cgo))continue; if (move(b, c, bgo, cgo))continue; if (dir[ago][bgo][cgo][st] \u003e= 0) continue; dir[ago][bgo][cgo][st] = dir[a][b][c][st] + 1; q.push(ID(ago, bgo, cgo)); } } } return -1; } void double_bfs() { queue\u003cint\u003e q[2]; memset(dir, -1, sizeof dir); q[0].push(ID(s[0], s[1], s[2])); q[1]","date":"2020-08-10","objectID":"/2020/08/uva1601/:1:0","tags":["题解","BFS","状态图","双BFS"],"title":"UVA1601","uri":"/2020/08/uva1601/"},{"categories":["紫书刷题录-ch7"],"content":"Fill 题意：给你3个没有刻度的杯子，每个杯子的都有自己的容量，现利用这三个杯子量出体积为d的水，现在问最少的倒水量，如果量不到d，就量和d想接近的d' 按照书中的说法这是一个隐式图，求最短路，最短路的评判标志是倒水量 #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccstring\u003e#include \u003cqueue\u003e using namespace std; const int M = 210; int cap[3], d, ans[M]; bool vis[M][M]; struct nodes{ int v[3], d; nodes(){} nodes(int v0, int v1, int v2, int d) :d(d) { v[0] = v0, v[1] = v1, v[2] = v2; } bool operator \u003c (const nodes\u0026 tmp) const { return d \u003e tmp.d; } }; void init() { memset(ans, -1, sizeof ans); memset(vis, 0, sizeof vis); } void update(nodes \u0026u) { for (int i = 0; i \u003c 3; i++) { if (ans[u.v[i]] \u003c 0 || ans[u.v[i]] \u003e u.d) ans[u.v[i]] = u.d; } } void BFS() { init(); scanf(\"%d%d%d%d\", cap, cap + 1, cap + 2, \u0026d); priority_queue\u003cnodes\u003e q; nodes s(0, 0, cap[2], 0); q.push(s); vis[0][0] = true; while (q.size()) { nodes u = q.top(); q.pop(); update(u); if (ans[d] \u003e 0) break; for (int i = 0; i \u003c 3; i++) { for (int j = 0; j \u003c 3; j++) { if (j == i) continue; if (!u.v[i] || u.v[j] == cap[j]) continue; int pour = min(cap[j], u.v[i] + u.v[j]) - u.v[j]; nodes v = u; v.v[i] -= pour, v.v[j] += pour, v.d += pour; if (vis[v.v[0]][v.v[1]])continue; vis[v.v[0]][v.v[1]] = true; q.push(v); } } } while (ans[d] \u003c 0 \u0026\u0026 d \u003e 0) { d--; } printf(\"%d %d\\n\", ans[d], d); } int main () { int T; scanf(\"%d\", \u0026T); while (T--) BFS(); return 0; } ","date":"2020-08-09","objectID":"/2020/08/uva10603/:1:0","tags":["题解","BFS","状态图"],"title":"UVA10603","uri":"/2020/08/uva10603/"},{"categories":["紫书刷题录-ch7"],"content":"Mobile Computing 题意：有一个房间，有长为1的木棍，用天平的方式放一些物品，让你求出不超过房间的宽度的最长宽度的，如果误解输出-1 做了两天，习得了两种dfs非枚举子集的办法（到时再回头研究刘神方法），只选择了一种学习，当然另一种也看了 自底向上枚举二叉树，思想有点像哈夫曼建树，选择两个节点来合并，然后就是递归回溯的事 dfs(n) ：代表还剩下 n 个节点可以拼接 w[i] ：代表第 i 个节点的重量，w[i] = 0 则表示该节点已经被用了 l[i]、r[i] ：代表第 i 节点的左右宽度的最大值 值得注意的是在求 l[i] 和 r[i] 时同时要考虑当前另一个节点，例如在计算 l[i] 时，不仅要考虑 左子树的左最大宽度 + 当前节点的左宽度，还要考虑 右子树的左最大宽度 - 当前节点的右宽度，前者很好理解，关键是后者：因为有可能右子树的左最大宽度会超过左子树 具体看图，右子树同理 显然橙色节点的距离超过了黄色节点 代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; using vi = vector\u003cint\u003e; double d, Max, l[10], r[10]; int n, cnt, k = 0; vi w; void dfs(int num) { if (num == 1) { for (int i = 0; i \u003c n; i++) { if (!w[i]) continue; if (l[i] + r[i] \u003e d) continue; Max = max(Max, l[i] + r[i]); } return; } for (int i = 0; i \u003c n; i++) { if (!w[i]) continue; for (int j = 0; j \u003c n; j++) { if (!w[j] || i == j) continue; int neww = w[i] + w[j], tmp1 = w[i], tmp2 = w[j]; double newl = (w[j] * 1.0) / (w[i] + w[j]), newr = 1 - newl; w[i] = neww, w[j] = 0; double tmpl = l[i], tmpr = r[i]; l[i] = max(newl + l[i], l[j] - newr); r[i] = max(newr + r[j], r[i] - newl); cnt--; dfs(num - 1); //回溯 cnt++; w[i] = tmp1, w[j] = tmp2; l[i] = tmpl, r[i] = tmpr; } } } void solve() { memset(l, 0, sizeof l); memset(r, 0, sizeof r); scanf(\"%lf%d\", \u0026d, \u0026n); Max = -1, cnt = n; w = vi(n); for (auto \u0026i : w) scanf(\"%d\", \u0026i); if (n == 1) { puts(\"0\"); return; } dfs(n); printf(\"%0.10f\\n\", Max); } int main () { int T; scanf(\"%d\", \u0026T); while(T--) solve(); return 0; } ","date":"2020-08-09","objectID":"/2020/08/uva1354/:1:0","tags":["题解","DFS","回溯"],"title":"UVA1354","uri":"/2020/08/uva1354/"},{"categories":["紫书刷题录-ch7"],"content":"Bandwidth 题意：给你一个无向图，让你输出一种序列使得每个节点到该节点在图中相连的节点的最远距离的最小值，直接看题目比较好懂 dfs遍历所有可能的序列，然后求出一个最小值，我的代码用了邻接表 剪枝的话一种是利用计算好最小带宽的一种来剪枝，第二种就是计算未确定位置的节点的最小带宽来剪 按照紫书的指导，剪了两种枝，但是感觉剪一种的速度差不多，两者交上去都是$0ms$，毕竟节点不多，剪一种枝就行了 以下代码是剪了两种枝的，如果只剪一种，只要把28，60，62注释就行了 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; char str[200]; bool ext[26], ok[26][26]; int head[26], n, indx[26], vis[26], mind, con[26]; struct es{ int to, next; es(int to = 0, int next = -1) : to (to), next(next) {} }; vector\u003ces\u003e e; vector\u003cchar\u003e node, res, ans; void add_edge(int u, int v) { e.push_back(es(v, head[u])); head[u] = e.size() - 1, con[u]++; if (!ext[u]) node.push_back(u + 'A'); ext[u] = true; } bool check(int cur, int u) { if (!cur) return false; if (con[u] \u003e mind) return true; for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (!vis[v]) continue; if (cur - indx[v] \u003e= mind) return true; } return false; } void left(int u, int x = -1) { for (int i = head[u]; ~i; i = e[i].next) { con[e[i].to] += x; } } void dfs(size_t cur) { if (cur == node.size()) { int m = 0; for (int i = cur - 1; i \u003e= 0; i--) { int u = res[i] - 'A'; for (int j = head[u]; ~j; j = e[j].next) { int v = e[j].to; m = max(m, abs(i - indx[v])); } } if (m \u003c mind) { mind = m; ans = res; } return; } for (size_t i = 0; i \u003c node.size(); i++) { int u = node[i] - 'A'; if (vis[u]) continue; if (check(cur, u)) continue; res[cur] = node[i], indx[u] = cur, vis[u] = true; left(u); dfs(cur + 1); left(u, 1); vis[u] = false; } } void init() { memset(head, -1, sizeof head); e.clear(), ans.clear(), res.clear(), node.clear(); memset(vis, 0, sizeof vis); memset(con, 0, sizeof con); memset(ext, 0, sizeof ext); memset(ok, 0, sizeof ok); mind = 100; } int main () { while (scanf(\"%s\", str), str[0] != '#') { init(); char *tmp = str; for (;;) { int u = tmp[0] - 'A'; int len = strlen(tmp); for (int i = 2; tmp[i] != ';' \u0026\u0026 i \u003c len; i++) { int v = tmp[i] - 'A'; if (ok[u][v]) continue; add_edge(u, v); add_edge(v, u); ok[u][v] = ok[v][u] = true; } if (strchr(tmp, ';') == nullptr ) break; tmp = strchr(tmp, ';') + 1; } sort(node.begin(), node.end()); res = vector\u003cchar\u003e(node.size()); dfs(0); for (auto i : ans) printf(\"%c \", i); printf(\"-\u003e %d\\n\", mind); } return 0; } ","date":"2020-08-07","objectID":"/2020/08/uva140/:1:0","tags":["题解","剪枝","DFS"],"title":"UVA140","uri":"/2020/08/uva140/"},{"categories":["紫书刷题录-ch7"],"content":"Krypton Factor 定义一个串是容易串：有相邻的相同的字串；反之就是困难串 让你求只利用前k个大写字母的第n个困难串 dfs模拟一下，值得注意的是剪枝时只看当前串的后缀即可，例如遍历到ABCDEFGH时，就只判断H和G、GH和EF、FGH和CDE、EFGH和ABCD就行了 代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e using namespace std; int n, L, num = 0; bool ok = true; char ans[100], a[50], b[50]; bool check(int len) { if (!len) return false; for (int i = 1; i + i \u003c= len + 1; i++) { memcpy(a, \u0026ans[len - i + 1], sizeof(char) * i); memcpy(b, \u0026ans[len - i - i + 1], sizeof(char) * i); a[i] = '\\0', b[i] = '\\0'; if (strcmp(a, b) == 0) return true; } return false; } void dfs(int cur) { if (num \u003e n) return; if (num == n) { size_t len = strlen(ans), s = 0, l = 0; for (size_t i = 0; i \u003c len; i++) { if (s++ == 4) { if (l != 15) printf(\" \"); s = 1, l++; } if (l == 16) { puts(\"\"); l = 1; } printf(\"%c\", ans[i]); } printf(\"\\n%zu\\n\", len); return; } for (int i = 0; i \u003c L; i++) { ans[cur] = i + 'A', ans[cur + 1] = '\\0'; if (check(cur)) continue; num++; dfs(cur + 1); } } int main() { while (scanf(\"%d%d\", \u0026n, \u0026L), n + L) { num = 0; dfs(0); memset(ans, 0, sizeof ans); } return 0; } ","date":"2020-08-07","objectID":"/2020/08/uva129/:1:0","tags":["题解","回溯","DFS"],"title":"UVA129","uri":"/2020/08/uva129/"},{"categories":["紫书刷题录-ch7"],"content":"Prime Ring Problem 题意：给你一个数n，让你求出所有素数环，素数环：利用 1 ~ n来排列组合成的一个环，相邻的两个数的和必须都是素数 直接dfs遍历所有排列，途中要剪枝，如果当前放的数和前面的数的和不是素数就直接剪了 画出解答树更好懂 代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e using namespace std; int kase = 0, n, arr[30]; bool isp[] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0}; bool vis[30]; void dfs(int cur, int *A) { if (cur == n - 1) { if (!isp[1 + A[n - 1]]) return; bool f = true; for (int i = 0; i \u003c n; i++) { if (f) f = !f; else printf(\" \"); printf(\"%d\", A[i]); } puts(\"\"); return; } for (int i = 2; i \u003c= n; i++) { if (vis[i]) continue; if (isp[A[cur] + i]) { A[cur + 1] = i; vis[i] = true; dfs(cur + 1, A); vis[i] = false; } } } int main() { arr[0] = 1; bool f = true; while (~scanf(\"%d\", \u0026n)) { if (f) f = !f; else puts(\"\"); printf(\"Case %d:\\n\", ++kase); dfs(0, arr); memset(vis, 0, sizeof vis); } return 0; } ","date":"2020-08-06","objectID":"/2020/08/uva524/:1:0","tags":["题解","回溯","DFS"],"title":"UVA524","uri":"/2020/08/uva524/"},{"categories":["紫书刷题录-ch7"],"content":"Fractions Again?! 给你一个k,让你求所有 $1 / k = 1 / x + 1/ y$ 的答案 $x \\ge y$ 计算可以发现 y 最大不会超过2k,最小是k + 1 #include \u003ccstdio\u003e#include \u003cvector\u003e using namespace std; using ll = long long; ll n; int main() { while (~scanf(\"%lld\", \u0026n)) { vector\u003cll\u003e a, b; for (ll i = n + 1; i \u003c= n + n; i++) { if (n * i % (i - n) == 0) { a.push_back(n * i / (i - n)); b.push_back(i); } } printf(\"%zu\\n\", a.size()); for (size_t i = 0; i \u003c a.size(); i++) { printf(\"1/%lld = 1/%lld + 1/%lld\\n\", n, a[i], b[i]); } } return 0; } ","date":"2020-08-06","objectID":"/2020/08/uva10976/:1:0","tags":["题解","暴力美学"],"title":"UVA10976","uri":"/2020/08/uva10976/"},{"categories":["紫书刷题录-ch7"],"content":"Maximum Product 给你一个数组，让你求子字串的最大乘积，如果没有就输出0 暴力解就好了 #include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; using ll = long long; int n, kase = 0; int main () { while(~scanf(\"%d\", \u0026n)) { ll Max = 0; vector\u003cll\u003e arr(n); for (auto \u0026x : arr) scanf(\"%lld\", \u0026x); for (int i = 0; i \u003c n; i++) { ll tmp = arr[i]; Max = max(Max, tmp); for (int j = i + 1; j \u003c n; j++) { tmp *= arr[j]; Max = max(Max, tmp); } } printf(\"Case #%d: The maximum product is %lld.\\n\\n\", ++kase, Max); } return 0; } ","date":"2020-08-06","objectID":"/2020/08/uva11059/:1:0","tags":["题解","暴力美学"],"title":"UVA11059","uri":"/2020/08/uva11059/"},{"categories":["紫书刷题录-ch7"],"content":"Division 题意：给你一个数n，让你求出 $abcde / fghij = n$ 的所有结果，a ~ j 的恰好是 0 ~ 9 的数 暴力遍历分子就好了，然后检查分母是否合法就行了 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003e using namespace std; const int M = 1e5; int n; bool check(int a, int b) { bool num[10] = {0}; if (b \u003c 10000) num[0] = true; while (a || b) { num[a % 10] = true; num[b % 10] = true; a /= 10, b /= 10; } int x = 0; for (auto i : num) if (i) x++; return x == 10; } bool check(int a) { bool num[10] = {0}; if (a \u003c 10000) num[0] = true; while (a) { num[a % 10] = true; a /= 10; } int x = 0; for (auto i : num) if (i) x++; return x == 5; } int main () { bool f = true; while (scanf(\"%d\", \u0026n), n) { if (f) f = false; else puts(\"\"); bool ok = true; for (int i = 11111; i \u003c M; i++) { if (i % n == 0 \u0026\u0026 check(i) \u0026\u0026 check(i / n) \u0026\u0026 check(i, i / n)) { ok = false; printf(\"%05d / %05d = %d\\n\", i, i / n, n); } } if (ok) printf(\"There are no solutions for %d.\\n\", n); } return 0; } ","date":"2020-08-06","objectID":"/2020/08/uva725/:1:0","tags":["题解","暴力美学"],"title":"UVA725","uri":"/2020/08/uva725/"},{"categories":["紫书刷题录-ch6"],"content":"Tree Reconstruction 题意：给你一个DFS和一个BFS遍历的树（具体遍历方式都是小的权值优先），让你求出每个节点的子节点 直接说思路：栈的运用，题目说输出任意可能的答案，所以把树当成一个二叉树来做，bfs本质就是树的一层一层的遍历，当一个节点在bfs序中下标为 $x$，则 $x + 1$可以认为是他的兄弟节点，其后面的都是下层的节点；而dfs的本质是一个链式的深度搜索，也就是说dfs中连续的很可能就是树的一条链式。根据以上性质，用栈来模拟dfs的建造过程，再更具上诉bfs的性质来判断某节点是否是栈顶的一个子节点 代码如下 #include \u003cbits/stdc++.h\u003e using namespace std; int n, x; int main() { for (; ~scanf(\"%d\", \u0026n);) { vector\u003cint\u003e node[1010], dfs(n), bfs(n + 1); for (int i = 1; i \u003c= n; i++) { scanf(\"%d\", \u0026x); bfs[x] = i; } for (auto \u0026i : dfs) scanf(\"%d\", \u0026i); stack\u003cint\u003e st; int root = dfs[0]; st.push(root); for (int i = 1; i \u003c n; i++) { for (;;) { int fa = st.top(); if (bfs[fa] + 1 \u003c bfs[dfs[i]] || fa == root) { node[fa].push_back(dfs[i]); st.push(dfs[i]); break; } else { st.pop(); } } } for (int i = 1; i \u003c= n; i++) { printf(\"%d:\", i); for (auto it : node[i]) { printf(\" %d\", it); } puts(\"\"); } } return 0; } ","date":"2020-08-05","objectID":"/2020/08/uva10410/:1:0","tags":["题解","树"],"title":"UVA10410","uri":"/2020/08/uva10410/"},{"categories":["紫书刷题录-ch6"],"content":"Spatial Structures 类似于计算像素的，读懂题意直接模拟就好了 毒瘤题 #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int n, kase = 0; char g[70][70], m[70][70]; vector\u003cll\u003e ans; void dfs(int r1, int c1, int r2, int c2, ll all, int d, int pos) { if (r1 == r2) { if (m[r1][c1] == '1') ans.push_back(all + pos * pow(5, d - 1)); return; } int sum1 = 0, sum2 = 0, sum3 = 0, sum4 = 0; for (int i = r1; i \u003c= (r2 + r1) / 2; i++) { for (int j = c1; j \u003c= (c2 + c1) / 2; j++) { sum1 += m[i][j] - '0'; } } for (int i = r1; i \u003c= (r2 + r1) / 2; i++) { for (int j = (c1 + c2) / 2 + 1; j \u003c= c2; j++) { sum2 += m[i][j] - '0'; } } for (int i = (r1 + r2) / 2 + 1; i \u003c= r2; i++) { for (int j = c1; j \u003c= (c1 + c2) / 2; j++) { sum3 += m[i][j] - '0'; } } for (int i = (r1 + r2) / 2 + 1; i \u003c= r2; i++) { for (int j = (c1 + c2) / 2 + 1; j \u003c= c2; j++) { sum4 += m[i][j] - '0'; } } int sum = sum1 + sum2 + sum3 + sum4; ll x = 0; if (d) x = all + pos*pow(5, d - 1); if (sum == (r2 - r1 + 1) * (c2 - c1 + 1)) { if (x) ans.push_back(x); if (d == 0) ans.push_back(0); return; } if (sum1 != 0) dfs(r1, c1, (r2 + r1) / 2, (c2 + c1) / 2, x, d + 1, 1); if (sum2 != 0) dfs(r1, (c1 + c2) / 2 + 1, (r2 + r1) / 2, c2, x, d + 1, 2); if (sum3 != 0) dfs((r1 + r2) / 2 + 1, c1, r2, (c1 + c2) / 2, x, d + 1, 3); if (sum4 != 0) dfs((r1 + r2) / 2 + 1, (c1 + c2) / 2 + 1, r2, c2, x, d + 1, 4); } int main() { bool flag = true; for (; scanf(\"%d\", \u0026n), n;) { if (flag) flag = !flag; else puts(\"\"); if (n \u003c 0) { int x; for (int i = 1; i \u003c= -n; i++) for (int j = 1; j \u003c= -n; j++) g[i][j] = '.'; for (; scanf(\"%d\", \u0026x), ~x;) { int tmp[100] = {0}, len; int r1 = 1, c1 = 1 , r2 = -n, c2 = -n; for (len = 0; x; len++) { tmp[len] = x % 5; x /= 5; } for (int i = 0; i \u003c len; i++) { int tp = tmp[i]; if (tp == 1) r2 = (r2 + r1) / 2, c2 = (c2 + c1) / 2; if (tp == 2) c1 = (c1 + c2) / 2 + 1, r2 = (r1 + r2) / 2; if (tp == 3) r1 = (r1 + r2) / 2 + 1, c2 = (c1 + c2) / 2; if (tp == 4) r1 = (r1 + r2) / 2 + 1, c1 = (c1 + c2) / 2 + 1; } for (int i = r1; i \u003c= r2; i++) for (int j = c1; j \u003c= c2; j++) g[i][j] = '*'; } printf(\"Image %d\\n\", ++kase); for (int i = 1; i \u003c= -n; i++) { for (int j = 1; j \u003c= -n; j++){ printf(\"%c\", g[i][j]); } puts(\"\"); } }else { for (int i = 1; i \u003c= n; i++) scanf(\"%s\", \u0026m[i][1]); dfs(1, 1, n, n, 0, 0, 0); int len = ans.size(); sort(ans.begin(), ans.end()); printf(\"Image %d\\n\", ++kase); int h = 0, f = 1; for (int i = 0; i \u003c len; i++) { if (f) f = 0; else printf(\" \"); printf(\"%lld\", ans[i]); if (++h == 12 \u0026\u0026 i != len - 1) { h = 0; f = 1; puts(\"\"); } } if (len != 0) puts(\"\"); printf(\"Total number of black nodes = %d\\n\", len); ans.clear(); } } return 0; } ","date":"2020-08-04","objectID":"/2020/08/uva806/:1:0","tags":["题解","树"],"title":"UVA806","uri":"/2020/08/uva806/"},{"categories":["紫书刷题录-ch6"],"content":"Petri Net Simulation 每个T变迁都有限制，必须是指定的P库有足够的token才行（注意，T指定的P库不一定只有一个），直接模拟就好了 #include \u003cbits/stdc++.h\u003e using namespace std; int p[110], np, nt, kase = 0; struct T { int in[110], out[110]; T() { memset(in, 0, sizeof in); memset(out, 0, sizeof out); } }; int main() { for (; scanf(\"%d\", \u0026np), np;) { for (int i = 1; i \u003c= np; i++) { scanf(\"%d\", p + i); } scanf(\"%d\", \u0026nt); int x; T ts[110]; for (int i = 1; i \u003c= nt; i++) { for (; scanf(\"%d\", \u0026x), x;) { if (x \u003c 0) ts[i].in[-x]++; else ts[i].out[x]++; } } int nf, n; scanf(\"%d\", \u0026nf); bool ok = true; for (n = 0; n \u003c nf \u0026\u0026 ok;) { for (int i = 1; i \u003c= nt; i++) { ok = true; for (int j = 1; j \u003c= np; j++) { if (p[j] \u003c ts[i].in[j]) { ok = false; break; } } if (ok) { for (int j = 1; j \u003c= np; j++) { p[j] -= ts[i].in[j]; p[j] += ts[i].out[j]; } n++; break; } } } vector\u003cint\u003e ans; for (int i = 1; i \u003c= np; i++) { if (p[i] != 0) { ans.push_back(i); } } if (n \u003c nf) printf(\"Case %d: dead after %d transitions\\n\", ++kase, n); else printf(\"Case %d: still live after %d transitions\\n\", ++kase, nf); printf(\"Places with tokens:\"); for (auto i : ans) { printf(\" %d (%d)\", i, p[i]); } puts(\"\\n\"); memset(p, 0, sizeof p); } return 0; } ","date":"2020-08-04","objectID":"/2020/08/uva804/:1:0","tags":["题解","图","模拟"],"title":"UVA804","uri":"/2020/08/uva804/"},{"categories":["紫书刷题录-ch6"],"content":"Equilibrium Mobile 题意：给你一个天平，修改某些节点可以使得天平平衡，让你求出最小的修改数量 竟然是一道思维题，不行，这题要写写题解 思路： 假设这个数是一个满二叉树的，并且每个叶子节点每个叶子节点的重量（权值）都不一样，则最少的修改次数就是：叶子节点数 - 1，具体策略就是找一个叶子节点为基准点，设其重量为$x$，然后把其余的叶子节点的重量都修改成$x$，设数的深度为$h$，则此时整棵树的的重量为 $x \\times 2 ^ {h - 1}$ 对于其他情况，我们可以根据上述的特殊情况来推导，假设以某个叶子节点为基准点，然后计算修改后整棵树的重量（根据公式 $x \\times 2 ^ {h - 1}$） 所以策略就是，计算每个叶子节点以其为基准点修改后的整棵树的重量，这样计算下去，可能会出现计算结果相同的情况，就意味着以该叶子节点为基准点修改时，有不需要修改的叶子节点 那么我们就可以统计以每个叶子节点为基准点修改后的整棵树的重量的值，出现最多次数的就说明以该叶子节点为基准点修改，有最多的叶子节点不需要修改，固需要修改的叶子节点个数最少 剩下的就是代码实现了，由于重量可能很大，固用哈希来存放该重量的数量 代码如下 #include \u003cbits/stdc++.h\u003e using namespace std; using ll = long long; int t, num; char str[1000005]; unordered_map\u003cll, int\u003e myhash; void dfs(int l, int r, ll d) { if (str[l] == '[') { int l_indx = l + 1, p = 0; while (l_indx \u003c r) { if (str[l_indx] == '[') p++; if (str[l_indx] == ']') p--; if (p == 0) break; l_indx++; } int r_indx = strchr(\u0026str[l_indx], ',') - \u0026str[l_indx] + l_indx; dfs(l + 1, l_indx, d + 1); dfs(r_indx + 1, r - 1, d + 1); return; } ll w = 0; sscanf(\u0026str[l], \"%lld\", \u0026w); myhash[w * (1 \u003c\u003c d)]++; num++; } int main () { scanf(\"%d\", \u0026t); while (t--) { myhash.clear(); num = 0; scanf(\"%s\", str); int len = strlen(str), ans = -1; dfs(0, len - 1, 0); for (auto i : myhash) ans = max(ans, i.second); printf(\"%d\\n\", num - ans); } return 0; } ","date":"2020-08-03","objectID":"/2020/08/uva12166/:1:0","tags":["题解","树","思维"],"title":"UVA12166","uri":"/2020/08/uva12166/"},{"categories":["紫书刷题录-ch6"],"content":"Patrol Robot BFS进阶题 题意：有个移动的机器人，从（1， 1）点出发，目标是（m， n）点，0为可以通过的点，1为障碍点，机器人一次最多只能穿越k障碍，问你最少要走多少步到达终点 BFS走，要注意个是要记录到达障碍点的最短穿越障碍个数 #include \u003cbits/stdc++.h\u003e using namespace std; int n, m, g[25][25], t, k; const int dx[] = {-1, 0, 1, 0}; const int dy[] = {0, -1, 0, 1}; inline bool check(int x, int y) { return x \u003e= 1 \u0026\u0026 y \u003e= 1 \u0026\u0026 x \u003c= n \u0026\u0026 y \u003c= m; } struct coo{ int x, y, d, k; coo(){} coo(int x, int y, int d, int k) : x(x), y(y), d(d), k(k){} }; void bfs() { queue\u003ccoo\u003e q; bool vis[25][25][25] = {0}; vis[1][1][0] = g[1][1] == 1; q.push(coo(1, 1, 0, g[1][1] == 1)); while (q.size()) { coo u = q.front(); q.pop(); if (vis[u.y][u.x][u.k]) continue; vis[u.y][u.x][u.k] = true; if (u.x == n \u0026\u0026 u.y == m) { printf(\"%d\\n\", u.d); return; } for (int i = 0; i \u003c 4; i++) { int x = u.x + dx[i], y = u.y + dy[i]; if (!check(x, y)) continue; if (g[y][x]) { if (u.k + 1 \u003e k) continue;//如果穿越障碍个数比之前算的还大就不计入 q.push(coo(x, y, u.d + 1, u.k + 1)); } else { q.push(coo(x, y, u.d + 1, 0)); } } } puts(\"-1\"); } int main () { scanf(\"%d\", \u0026t); while (t--) { scanf(\"%d%d%d\", \u0026m, \u0026n, \u0026k); for (int i = 1; i \u003c= m; i++) for (int j = 1; j \u003c= n; j++) scanf(\"%d\", \u0026g[i][j]); bfs(); memset(g, 0, sizeof g); } return 0; } ","date":"2020-08-03","objectID":"/2020/08/uva1600/:1:0","tags":["题解","图"],"title":"UVA1600","uri":"/2020/08/uva1600/"},{"categories":["紫书刷题录-ch6"],"content":"Knight Moves 题意：在象棋里，给马的起点和终点，计算最小移动步数 #include \u003cbits/stdc++.h\u003e#define mk(a, b) make_pair(a, b) using namespace std; using pii = pair\u003cint, int\u003e; using pdi = pair\u003cpii, int\u003e; int sx, sy, ex, ey; bool vis[10][10]; char a[5], b[5]; const int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2}; const int dy[] = {-1, -2, -2, -1, 1, 2, 2, 1}; inline bool cherk(int x, int y) { return x \u003e 0 \u0026\u0026 y \u003e 0 \u0026\u0026 x \u003c 9 \u0026\u0026 y \u003c 9; } void print(int num) { printf(\"To get from %s to %s takes %d knight moves.\\n\", a, b, num); } void bfs() { queue\u003cpdi\u003e q; q.push(mk(mk(sx, sy), 0)); vis[sx][sy] = true; while (q.size()) { int x = q.front().first.first, y = q.front().first.second; int num = q.front().second; q.pop(); if (x == ex \u0026\u0026 y == ey) { print(num); return;} for (int i = 0; i \u003c 8; i++) { int l = x + dx[i], r = y + dy[i]; if (cherk(l, r) \u0026\u0026 !vis[l][r]) { q.push(mk(mk(l, r), num + 1)); vis[x][y] = true; } } } } int main () { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif while (~scanf(\"%s %s\", a, b)) { sx = a[0] - 'a' + 1, sy = a[1] - '0'; ex = b[0] - 'a' + 1, ey = b[1] - '0'; bfs(); memset(vis, 0, sizeof vis); } return 0; } ","date":"2020-08-02","objectID":"/2020/08/uva439/:1:0","tags":["题解","图"],"title":"UVA439","uri":"/2020/08/uva439/"},{"categories":["紫书刷题录-ch6"],"content":"Tree Recovery 给你一个二叉树的先序和中序遍历，输出对应的后序遍历 #include \u003cbits/stdc++.h\u003e using namespace std; char pre[30], in[30]; void dfs(int a, int b, int c, int d) { if (c \u003e d) return; char tmp = pre[a]; int indx = c; while (in[indx] != tmp) indx++; dfs(a + 1, a + indx - c, c, indx - 1); dfs(a + indx - c + 1, b, indx + 1, d); printf(\"%c\", tmp); } int main () { while (~scanf(\"%s%s\", pre, in)) { int len = strlen(pre); dfs(0, len - 1, 0, len - 1); puts(\"\"); } return 0; } ","date":"2020-08-02","objectID":"/2020/08/uva536/:1:0","tags":["题解","树"],"title":"UVA536","uri":"/2020/08/uva536/"},{"categories":["紫书刷题录-ch6"],"content":"S-Trees 题意：一棵二叉树，每个层节点都有有个逻辑布尔变量，0往左走，1往右走，给你最后一层的结果值，再给你每个变量的取值，问你最后走到的最后一层叶子节点的值 这题有点迷，一开始忘记记录变量的顺序尽然也过了，后来记录了也能过 不考虑变量的顺序 #include \u003cbits/stdc++.h\u003e using namespace std; int n, k, kase = 0;; char res[600], in[10]; void dfs(int indx, int x) { if (indx == n) { printf(\"%c\", res[x - (1 \u003c\u003c n)]); return; } if (in[indx] == '0') dfs(indx + 1, x \u003c\u003c 1); else dfs(indx + 1, x \u003c\u003c 1 | 1); } int main () { while (scanf(\"%d\", \u0026n), n) { char tmp[10]; for (int i = 0; i \u003c n; i++) { scanf(\"%s\", tmp); } scanf(\"%s\", res); printf(\"S-Tree #%d:\\n\", ++kase); scanf(\"%d\", \u0026k); while (k--) { scanf(\"%s\", in); dfs(0, 1); } puts(\"\\n\"); } return 0; } 考虑变量的顺序 #include \u003cbits/stdc++.h\u003e using namespace std; int n, k, num[10], kase = 0;; char res[600], in[10]; void dfs(int indx, int x) { if (indx == n) { printf(\"%c\", res[x - (1 \u003c\u003c n)]); return; } if (in[num[indx]] == '0') dfs(indx + 1, x \u003c\u003c 1); else dfs(indx + 1, x \u003c\u003c 1 | 1); } int main () { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif while (scanf(\"%d\", \u0026n), n) { char tmp[10]; for (int i = 0; i \u003c n; i++) { scanf(\"%s\", tmp); num[i] = tmp[1] - '0' - 1; } scanf(\"%s\", res); printf(\"S-Tree #%d:\\n\", ++kase); scanf(\"%d\", \u0026k); while (k--) { scanf(\"%s\", in); dfs(0, 1); } puts(\"\\n\"); } return 0; } ","date":"2020-08-02","objectID":"/2020/08/uva712/:1:0","tags":["题解","树"],"title":"UVA712","uri":"/2020/08/uva712/"},{"categories":["紫书刷题录-ch6"],"content":"Parentheses Balance 让你判断括号是否合法，栈的经典例题 #include \u003cbits/stdc++.h\u003e using namespace std; int t; int main () { scanf(\"%d\", \u0026t); getchar(); while (t--) { char str[150]; fgets(str, sizeof str, stdin); stack\u003cchar\u003e st; for (int i = 0; str[i] != '\\n'; i++) { if (str[i] == ')' \u0026\u0026 st.size() \u0026\u0026 st.top() == '(') st.pop(); else if (str[i] == ']' \u0026\u0026 st.size() \u0026\u0026 st.top() == '[') st.pop(); else st.push(str[i]); } if (st.empty()) puts(\"Yes\"); else puts(\"No\"); } return 0; } ","date":"2020-08-02","objectID":"/2020/08/uva672/:1:0","tags":["题解","栈"],"title":"UVA672","uri":"/2020/08/uva672/"},{"categories":null,"content":"Abbott’s Revenge 题意：给你起点和终点，每个点面向不同的方向有不用的指定方向，问你从起点到终点最短路 BFS就好，但是要注意的是每个点都有不用的方向，所以要多加一维来保存这些方向，即每个点相当于是4个点 一道值得学习深究的一题 #include \u003cbits/stdc++.h\u003e using namespace std; const char dis[] = \"NESW\", go[] = \"RLF\"; const int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, 1, 0, -1 }; int sx, sy, rx, ry, ex, ey, rd, d[15][15][4]; bool ok[15][15][4][3]; inline int get_dis(char c) { return strchr(dis, c) - dis; } inline int get_go(char c) { return strchr(go, c) - go; } inline bool cherk(int x, int y) { return x \u003e 0 \u0026\u0026 x \u003c= 9 \u0026\u0026 y \u003e 0 \u0026\u0026 y \u003c= 9; } struct nodes{ int x, y, d; nodes(int x = 0, int y = 0, int d = 0) : x(x), y(y), d(d) {} }pre[15][15][4]; nodes work(nodes \u0026node, int i) { int dr = node.d; if (i == 0) dr = (dr + 1) % 4; if (i == 1) dr = (dr + 3) % 4; return nodes(node.x + dx[dr], node.y + dy[dr], dr); } void print(nodes last) { vector\u003cnodes\u003e ans; while (1){ ans.push_back(last); if (d[last.x][last.y][last.d] == 1) break; last = pre[last.x][last.y][last.d]; } ans.push_back(nodes(sx, sy, 0)); reverse(ans.begin(), ans.end()); int k = 0; printf(\" \"); for (auto i : ans) { if (k++ \u0026\u0026 k % 10 == 1) printf(\"\\n\"); printf(\" (%d,%d)\", i.x, i.y); } puts(\"\"); } void bfs() { queue\u003cnodes\u003e q; q.push(nodes(rx, ry, rd)); d[rx][ry][rd] = 1; while (q.size()) { nodes node = q.front(); q.pop(); int x = node.x, y = node.y, dir = node.d; if (x == ex \u0026\u0026 y == ey) { print(node); return; } for (int i = 0; i \u003c 3; i++) { if (!ok[x][y][dir][i]) continue; nodes nxt = work(node, i); if (!cherk(nxt.x, nxt.y) || d[nxt.x][nxt.y][nxt.d] != 0) continue; d[nxt.x][nxt.y][nxt.d] = d[x][y][dir] + 1; pre[nxt.x][nxt.y][nxt.d] = node; q.push(nxt); } } puts(\" No Solution Possible\"); } void init() { memset(ok, 0, sizeof ok); memset(d, 0, sizeof d); } int main() { char str[100], w, ch[100]; int x, y; while (1) { scanf(\"%s\", str); if (strcmp(str, \"END\") == 0) break; puts(str); scanf(\"%d%d %c%d%d\", \u0026sx, \u0026sy, \u0026w, \u0026ex, \u0026ey); rd = get_dis(w); rx = sx + dx[rd], ry = sy + dy[rd]; while (scanf(\"%d\", \u0026x), x) { scanf(\"%d\", \u0026y); while (scanf(\"%s\", ch), ch[0] != '*') { int len = strlen(ch); for (int i = 1; i \u003c len; i++) { ok[x][y][get_dis(ch[0])][get_go(ch[i])] = true; } } } bfs(); init(); } return 0; } ","date":"2020-08-01","objectID":"/2020/08/uva816/:1:0","tags":["题解","图"],"title":"UVA816","uri":"/2020/08/uva816/"},{"categories":null,"content":"Ordering Tasks 题意：给你一堆未知数的大小关系，让你输出可能的总体大小关系 简化了拓扑排序，只因根据题中的意思了解到一定是DAG #include \u003cbits/stdc++.h\u003e using namespace std; const int M = 110; int m, n, vis[M]; bool g[M][M]; vector\u003cint\u003e ans; void dfs(int u) { vis[u] = true; for (int i = 1; i \u003c= m; i++) { if (!vis[i] \u0026\u0026 g[u][i]) { dfs(i); } } ans.push_back(u); } int main() { while (scanf(\"%d%d\", \u0026m, \u0026n), m + n) { int x, y; for (int i = 0; i \u003c n; i++) { scanf(\"%d%d\", \u0026x, \u0026y); g[x][y] = true; } for (int i = 1; i \u003c= m; i++) { if (vis[i]) continue; dfs(i); } reverse(ans.begin(), ans.end()); for (auto i : ans) printf(\"%d \", i); puts(\"\"); ans.clear(); memset(g, 0, sizeof g); memset(vis, 0, sizeof vis); } return 0; } ","date":"2020-08-01","objectID":"/2020/08/uva10305/:1:0","tags":["题解","图","拓扑排序"],"title":"UVA10305","uri":"/2020/08/uva10305/"},{"categories":["紫书刷题录-ch6"],"content":"Oil Deposits 给你一个矩形图，让你求连通的“@”块，一个连通的定义是该点的八个方向都是连通的，dfs就行了 #include \u003cbits/stdc++.h\u003e using namespace std; int m, n, cont[110][110]; char g[110][110]; void dfs(int x, int y, int num) { if (x \u003c 0 || y \u003c 0 || x \u003e= m || y \u003e= n || cont[x][y] || g[x][y] != '@') return; cont[x][y] = num; for (int i = -1; i \u003c= 1; i++) { for (int j = -1; j \u003c= 1; j++) { if (i != 0 || j != 0) dfs(x + i, y + j, num); } } } int main() { while (scanf(\"%d%d\", \u0026m, \u0026n), m \u0026\u0026 n) { for (int i = 0; i \u003c m; i++) { scanf(\"%s\", g[i]); } int num = 0; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (!cont[i][j] \u0026\u0026 g[i][j] == '@') { dfs(i, j, ++num); } } } printf(\"%d\\n\", num); memset(cont, 0, sizeof cont); } return 0; } ","date":"2020-07-31","objectID":"/2020/07/uva572/:1:0","tags":["题解","图"],"title":"UVA572","uri":"/2020/07/uva572/"},{"categories":["紫书刷题录-ch6"],"content":"The Falling Leaves 二叉树的计算，直接递归读入遍历即可 所有数据要以空行相隔，UVA特色 #include \u003cbits/stdc++.h\u003e using namespace std; const int M = 5e5 + 5; int node[M], t = 0; void build(int mid) { int v; scanf(\"%d\", \u0026v); if (v == -1) return; node[mid] += v; build(mid - 1); build(mid + 1); } bool read() { int v, mid = M \u003e\u003e 1; scanf(\"%d\", \u0026v); if (v == -1) return false; memset(node, 0, sizeof node); node[mid] = v; build(mid - 1); build(mid + 1); return true; } int main() { while (read()) { int indx = 0, f = 1; while (!node[indx]) indx++; printf(\"Case %d:\\n\", ++t); for (; node[indx] != 0; indx++) { if (f) f = 0; else printf(\" \"); printf(\"%d\", node[indx]); } puts(\"\\n\"); } return 0; } ","date":"2020-07-31","objectID":"/2020/07/uva699/:1:0","tags":["题解","树"],"title":"UVA699","uri":"/2020/07/uva699/"},{"categories":["紫书刷题录-ch6"],"content":"Not so Mobile 题意：天平平衡，题意很好懂，就是让你判断给的天平平不平衡，直接递归读入就好了 #include \u003cbits/stdc++.h\u003e using namespace std; int t, w; bool ok; void read(int \u0026w) { int wl, dl, wr, dr; scanf(\"%d%d%d%d\", \u0026wl, \u0026dl, \u0026wr, \u0026dr); if (wl == 0) read(wl); if (wr == 0) read(wr); w = wl + wr; if (wl * dl != wr * dr) ok = false; } int main() { scanf(\"%d\", \u0026t); while (t--) { ok = true; read(w); if (ok) puts(\"YES\"); else puts(\"NO\"); if (t) puts(\"\"); } return 0; } 总结：这题是一个很特殊的树，在输入时就开始递归，值得学习 ","date":"2020-07-31","objectID":"/2020/07/uva839/:1:0","tags":["题解","树"],"title":"UVA839","uri":"/2020/07/uva839/"},{"categories":["紫书刷题录-ch6"],"content":"Dropping Balls 题意：小球在一个二叉树上下落，每个节点都有一个开关，起初全是关的，如果节点是开小球往右走，反之往左走，让你求最后一个球落到了哪个节点 如果直接单纯的模拟是会超时的，观察可以发现一个节点的第奇数个球都会落到左子树，第偶数个球都落到了右边，自己草稿模拟一下就好了 代码如下 #include \u003cbits/stdc++.h\u003e using namespace std; int d, n, t; int main() { scanf(\"%d\", \u0026t); while (t--) { scanf(\"%d%d\", \u0026d, \u0026n); int ans = 1; for (int i = 1; i \u003c d; i++) { if (n \u0026 1) { ans \u003c\u003c= 1; n = (n + 1) \u003e\u003e 1; } else { ans = ans \u003c\u003c 1 | 1; n \u003e\u003e= 1; } } printf(\"%d\\n\", ans); } return 0; } ","date":"2020-07-31","objectID":"/2020/07/uva679/:1:0","tags":["题解","树","思维"],"title":"UVA679","uri":"/2020/07/uva679/"},{"categories":["紫书刷题录-ch6"],"content":"Tree 给你二叉树的中序和先序遍历，让你求从根节点到叶节点的的距离权值和最小，如果有多解，叶节点的权值要小，输出叶节点的权值 #include \u003cbits/stdc++.h\u003e using namespace std; const int M = 1e4 + 10; string str; int ino[M], posto[M], ans, Max, lson[M], rson[M], len = 0; void dfs(int u, int sum) { if (!lson[u] \u0026\u0026 !rson[u]) { if (sum \u003c Max || (sum == Max \u0026\u0026 ans \u003e u)) { ans = u, Max = sum; } } if (lson[u] != 0) dfs(lson[u], sum + lson[u]); if (rson[u] != 0) dfs(rson[u], sum + rson[u]); } int build(int a, int b, int c, int d) { if (c \u003e d) return 0; int v = posto[b], indx = c; while (ino[indx] != v \u0026\u0026 indx \u003c= d) indx++; int l = indx - c; lson[v] = build(a, a + l - 1, c, indx - 1); rson[v] = build(a + l, b - 1, indx + 1, d); return v; } void init(int *A) { char *s = \u0026str[0]; len = 0; while (1) { sscanf(s, \"%d\", A + len++); if (strchr(s, ' ') == nullptr) return; s = strchr(s, ' ') + 1; } } int main() { while (getline(cin, str)) { init(ino); getline(cin, str); init(posto); build(0, len - 1, 0, len - 1); ans = Max = 1e5; dfs(posto[len - 1], posto[len - 1]); printf(\"%d\\n\", ans); memset(lson, 0, sizeof lson); memset(rson, 0, sizeof rson); } return 0; } ","date":"2020-07-31","objectID":"/2020/07/uva548/:1:0","tags":["题解","树"],"title":"UVA548","uri":"/2020/07/uva548/"},{"categories":["紫书刷题录-ch6"],"content":"Rails 让你判断列车出站是否正确，栈的运用 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cstack\u003e using namespace std; const int M = 1e3 + 10; int n, arr[M]; int main() { while (scanf(\"%d\", \u0026n), n) { while (scanf(\"%d\", \u0026arr[1]), arr[1]) { for (int i = 2; i \u003c= n; i++) { scanf(\"%d\", arr + i); } stack\u003cint\u003e st; int in = 1, out = 1; bool ok = true; while (out \u003c= n) { if (in == arr[out]) { in++, out++; } else if (st.size() \u0026\u0026 st.top() == arr[out]) { st.pop(); out++; } else if (in \u003c= n) { st.push(in++); } else { puts(\"No\"); ok = false; break; } } if (ok) puts(\"Yes\"); memset(arr, 0, sizeof arr); } puts(\"\"); } return 0; } ","date":"2020-07-31","objectID":"/2020/07/uva514/:1:0","tags":["题解","栈"],"title":"UVA514","uri":"/2020/07/uva514/"},{"categories":["紫书刷题录-ch6"],"content":"Matrix Chain Multiplication 矩阵链乘，栈的运用 #include \u003cbits/stdc++.h\u003e using namespace std; using pii = pair\u003cint, int\u003e; int n; pii m[30]; char str[100000]; int main() { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; i++) { char a; int x, y; scanf(\"\\n%c%d%d\", \u0026a, \u0026x, \u0026y); m[a - 'A'] = make_pair(x, y); } getchar(); while (fgets(str, sizeof str, stdin)) { stack\u003cpii\u003e st; int len = strlen(str), ans = 0; if (str[len - 1] == '\\n') str[len-- - 1] = '\\0'; bool ok = true; for (int i = 0; i \u003c len; i++) { if (isalpha(str[i])) { st.push(m[str[i] - 'A']); } else if (str[i] == ')') { pii a = st.top(); st.pop(); pii b = st.top(); st.pop(); if (a.first != b.second) { puts(\"error\"); ok = false; break; } ans += a.first * a.second * b.first;//b * a st.push(make_pair(b.first, a.second)); } } if (ok) printf(\"%d\\n\", ans); } return 0; } ","date":"2020-07-31","objectID":"/2020/07/uva442/:1:0","tags":["题解","栈"],"title":"UVA442","uri":"/2020/07/uva442/"},{"categories":["紫书刷题录-ch6"],"content":"Trees on the level 二叉树的建立 #include \u003cbits/stdc++.h\u003e using namespace std; const int M = 1e5 + 10; int lson[M], rson[M], cnt, node[M]; bool ok, in[M] = {false};//in记录节点是否存在 vector\u003cint\u003e ans; int newnode() {//申请新的地址 int u = ++cnt; lson[u] = rson[u] = 0; return u; } void newtree() {//建新树 lson[1] = rson[1] = 0; in[1] = false; cnt = 1; } void build(int v, char *s) { int indx = 0, u = 1; while (s[indx] != ')') { if (s[indx] == 'L') { if (!lson[u]) lson[u] = newnode(); u = lson[u]; } else { if (!rson[u]) rson[u] = newnode(); u = rson[u]; } indx++; } if (in[u]) ok = true; node[u] = v; in[u] = true; } void init() { memset(lson, 0, sizeof lson); memset(rson, 0, sizeof rson); memset(in, 0, sizeof in); memset(node, 0, sizeof node); } bool read() { char str[100]; init(); newtree(); while (scanf(\"%s\", str) != EOF) { if (strcmp(\"()\", str) == 0) return true; int node; sscanf(\u0026str[1], \"%d\", \u0026node); build(node, strchr(str, ',') + 1); } return false; } void dfs() { queue\u003cint\u003e q; q.push(1); while (q.size()) { int u = q.front(); q.pop(); if (!in[u]) { ok = true; return; } ans.push_back(node[u]); if (lson[u] != 0) q.push(lson[u]); if (rson[u] != 0) q.push(rson[u]); } } int main() { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif while (read()) { dfs(); if (ok) puts(\"not complete\"); else { bool f = true; for (auto i : ans) { if (f) f = false; else printf(\" \"); printf(\"%d\", i); } puts(\"\"); } ans.clear(); ok = false; } return 0; } 总结（收获）：在一般情况下利用指针建树和新建节点的原理就是申请新的地址内存（指针），但是如果这样的话在释放内存的时候会很不方便。所以这里我利用了变量模拟地址，即代码中的cnt，cnt = x代表申请了一个地址是x的内存（模拟的），这样的好处就是方便建树和建立新的节点，也没有因为难以释放指针内存的后顾之忧了。 ","date":"2020-07-31","objectID":"/2020/07/uva122/:1:0","tags":["题解","树"],"title":"UVA122","uri":"/2020/07/uva122/"},{"categories":["cf刷题计划"],"content":"传送门 题意：给你两个同长数组代表n个人两场比赛的成绩，再给你一个x，某两个数组的和$a_i + b_j \\ge x$，问你两数组组合成满足式子的排名最高和最低是多少。具体看样例就懂了。 思路：此题对于最高排名一定是1，即第一名，而最低排名的话，一开始知道是一个双指针的贪心，但是就是不知道怎么贪，后来看到大佬的想法豁然开朗：只要找到组合后大于等于x的个数有多少就好了。 具体找法：一个数组a大到小排序，一个数组b小到大排序，然后只要从a从头开始一个一个遍历，从b数组中从头找能与a数组的数加起来大于等于x的数就好了，然后记录个数，就是答案 心得：贪心题目是难想，想到之后就很简单，代码量也不大，还有一个比较考验的就是模拟的功力了（从人的思维去想想如果这不是一道编程题，而是一个生活的益智题，你会怎么做？然后再用代码实现,说的简单，感觉还是要多刷题） 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e using namespace std; const int M = 1e5 + 5; int n, x, a[M], b[M]; int main() { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif scanf(\"%d%d\", \u0026n, \u0026x); for (int i = 0; i \u003c n; i++) { scanf(\"%d\", a + i); } for (int i = 0; i \u003c n; i++) { scanf(\"%d\", b + i); } printf(\"1 \"); sort(a, a + n); sort(b, b + n); reverse(a, a + n); //a从大到小排序 int j = 0, ans = 0; for (int i = 0; i \u003c n; i++) { while (j \u003c n \u0026\u0026 b[j] + a[i] \u003c x) { j++; } if (j \u003e= n) break; ans++; j++; } printf(\"%d\", ans); return 0; } ","date":"2020-07-24","objectID":"/2020/07/olympiad/:1:0","tags":["模拟","题解","思维","贪心"],"title":"Olympiad","uri":"/2020/07/olympiad/"},{"categories":["cf刷题计划"],"content":"传送门 题意：给你一个矩阵，每次进行与行之间的交换，或者是列与列之间的交换，或者查询(x, y)点的值 思路：一开始想着是不是直接就纯模拟算了，后来想想，直接用数组把行和列也记录下来不就好了吗 代码如下 #include \u003ccstdio\u003e using namespace std; const int M = 1e3 + 10; int r[M], c[M], g[M][M], n, m, k; int main() { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif scanf(\"%d%d%d\", \u0026n, \u0026m, \u0026k); for (int i = 1; i \u003c= n; i++) r[i] = i; for (int i = 1; i \u003c= m; i++) c[i] = i; for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { scanf(\"%d\", \u0026g[i][j]); } } while (k--) { char a; int x, y; scanf(\"\\n%c %d %d\", \u0026a, \u0026x, \u0026y); if (a == 'r') {//交换操作 r[x] ^= r[y], r[y] ^= r[x], r[x] ^= r[y]; } else if (a == 'c') { c[x] ^= c[y], c[y] ^= c[x], c[x] ^= c[y]; } else { printf(\"%d\\n\", g[r[x]][c[y]]); } } return 0; } ","date":"2020-07-24","objectID":"/2020/07/cosmic_tables/:1:0","tags":["模拟","题解","思维"],"title":"Cosmic_Tables","uri":"/2020/07/cosmic_tables/"},{"categories":["cf刷题计划"],"content":"传送门 什么鬼，div2也出水题？还是我变强了？😂 题意：给你一个长为n的序列，再给你一个k，你每次都必须要这样做：选择第k个数，把他复制到序列的最后，再把序列的第一个数给删了，问你要操作多少次可以使得序列数组的数全部相同，如果根本不可能通过上述操作使得序列数组的数全部相同，则输出-1 思路：不难发现，如果一开始第k个数及后面的数有出现不同的数的话，是不可能通过上述操作使得整个数组完全相同，如果可能的话，就往k前找，即往左找，找到第一个与第k个数不同的数，输出他的下标就好了（因为要一直删到那个不同的数），模拟一下就好了。 代码如下 #include \u003ccstdio\u003e using namespace std; const int M = 1e5 + 10; int n, k, arr[M]; int main() { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif scanf(\"%d%d\", \u0026n, \u0026k); for (int i = 0; i \u003c n; i++) { scanf(\"%d\", arr + i); } int tmp = arr[k - 1]; for (int i = k; i \u003c n; i++) { if (arr[i] != tmp) { printf(\"-1\"); return 0; } } for (int i = k - 2; i \u003e= 0; i--) { if (arr[i] != tmp) { printf(\"%d\", i + 1); return 0; } } printf(\"0\"); return 0; } ","date":"2020-07-24","objectID":"/2020/07/shooshuns_and_sequence/:1:0","tags":["模拟","题解","思维"],"title":"Shooshuns_and_Sequence","uri":"/2020/07/shooshuns_and_sequence/"},{"categories":["cf刷题计划"],"content":"传送门 题意：旅行者每天都会记录自己的海拔高度，他每天规定走海拔相差不超过1的路线，有一天他的记录丢失了，只剩下几天的，问你他之前有可能到达的最高海拔是多少，如果数据出现矛盾，输出\"IMPOSSIBLE\" 思路：用两个数组记录天数和当天的海拔高度，如果相隔的海拔差比相隔的天数差还大的话就是矛盾，否则就这样计算相隔天数中可能的最大海拔高度：$MaxHight = ( day[i] + hight[i] - (day[i - 1] - hight[i - 1]) ) / 2$，最后取众多MaxHight的最大值 注意：第一天和最后一天的数据可能没给，所以我们要自己造一个可能的最大高度，例如只给你第3天的海拔高度为5，总共旅行的天数为4，那么我们就自己造一个第一天的高度为7$(5 + 3 - 1)$，第4天的高度为6$(5 + (4 - 3))$，就是一开始没想到这个，wa了2发/(ㄒoㄒ)/~~ 代码如下： #include \u003calgorithm\u003e#include \u003ccmath\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e using namespace std; const int M = 1e5 + 10; int n, m, d[M], h[M]; bool ok = true; int main() { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= m; i++) { scanf(\"%d%d\", d + i, h + i); if (i != 1 \u0026\u0026 d[i] - d[i - 1] \u003c abs(h[i] - h[i - 1])) { ok = false; } } if (ok) { h[0] = h[1] + d[1] - 1, h[m + 1] = h[m] + (n - d[m]); d[0] = 1, d[m + 1] = n; int Max = h[0]; for (int i = 1; i \u003c= m + 1; i++) { int tmp = (d[i] + h[i] - (d[i - 1] - h[i - 1])) \u003e\u003e 1; Max = max(Max, tmp); } printf(\"%d\\n\", Max); } else { printf(\"IMPOSSIBLE\\n\"); } return 0; } ","date":"2020-07-24","objectID":"/2020/07/tourists_notes/:1:0","tags":["模拟","题解"],"title":"Tourist's_Notes","uri":"/2020/07/tourists_notes/"},{"categories":["cf刷题计划"],"content":"传送门 题意：一个只由1和0组成的十进制数叫做Quasi Binary，例如11（十一）就是，现在给你一个n，让你求出他可能有哪些Quasi Binary的和组成，输出最少的Quasi Binary个数并将他们输出 思路：模拟，用个二维数组记录所有的结果位数结果，然后相加输出。例如32就是记录10、10、10、1、1，然后分别将不同位数的相加得到11（10 + 1），11（10 + 1），10（10 + 0） 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e using namespace std; int main() { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif int n; scanf(\"%d\", \u0026n); int t = n, sum = 0; while (t) { sum = max(t % 10, sum); t /= 10; } printf(\"%d\\n\", sum); int tmp, x = 0, y = 0, numset[7][10] = {0}, w = 1; while (n) { tmp = n % 10, y = 0; while (tmp) { numset[x][y++] = w; tmp--; } n /= 10, x++, w *= 10; } for (int i = 0; i \u003c sum; i++) { int res = 0; for (int j = 0; j \u003c 7; j++) { res += numset[j][i]; } printf(\"%d \", res); } return 0; } ","date":"2020-07-23","objectID":"/2020/07/quasi_binary/:1:0","tags":["模拟","题解"],"title":"Quasi_Binary","uri":"/2020/07/quasi_binary/"},{"categories":["cf刷题计划"],"content":"传送门 题意：给你个字符串，减去一段子串，是否能将剩下的不改变顺序拼成\"CODEFORCES\"，能则输出\"YES\"，否则输出\"NO\" 思路：直接枚举减去的长度，然后暴力 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cstring\u003e#include \u003cvector\u003e using namespace std; char aim[] = \"CODEFORCES\", str[200], tmp[200]; int main() { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif scanf(\"%s\", str); if (strcmp(str, aim) == 0) { puts(\"YES\"); return 0; } int len = strlen(str); for (int i = 1; i \u003c= len; i++) { for (int j = 0; j + i - 1 \u003c len; j++) { int ind = 0; for (int k = 0; k \u003c len; k++) { if (k \u003c j || k \u003e j + i - 1) { tmp[ind++] = str[k]; } } tmp[ind] = '\\0'; if (strcmp(tmp, aim) == 0) { puts(\"YES\"); return 0; } } } puts(\"NO\"); return 0; } ","date":"2020-07-23","objectID":"/2020/07/cutting_banner/:1:0","tags":["暴力","题解"],"title":"Cutting_Banner","uri":"/2020/07/cutting_banner/"},{"categories":["总结"],"content":"前言 起因是一次力扣周赛时被一道最短论的题给整蒙了，决定这几天恶补图论，正好POJ的刷题题单刷到了图 打算学习图论从零开始，目前刷的题不多 ","date":"2020-07-21","objectID":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:1:0","tags":["图论"],"title":"图论刷题总结","uri":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"总结 关于存图 不同的存图方式可以使得不同的算法更加方便，例如：邻接表可以使Dijkstra算法在堆优化中方便不少，而邻接矩阵可以使Floyd算法更加方便 关于建图 有一些题目在描述的时候给的数据不好建图，这需要经验的积累 而有一些题目并没有直接说明是图，换句话说能否看出是使用图论的知识来解题也需要经验的累积 关于计算 题目中的要求并不是一成不变的，有时候最短路径并不是仅仅指的是值最短，有时候也有可能题目让你求最大值，但最短路依然可以解 ","date":"2020-07-21","objectID":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:2:0","tags":["图论"],"title":"图论刷题总结","uri":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"最短路 先从最短路开始刷，刷到后面发现有些题三个算法（Dijkstra、Bellman-Ford、Floyd）都是可以解的 ","date":"2020-07-21","objectID":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:3:0","tags":["图论"],"title":"图论刷题总结","uri":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"Dijkstra [例题] 洛谷P4779 【模板】单源最短路径（标准版） 题意：最短路板子题，不解释 思路：直接用Dijkstra的堆优化做，因为没有负环 直接上代码 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003clocale\u003e#include \u003cqueue\u003e#include \u003cutility\u003e#include \u003cvector\u003e using namespace std; typedef long long ll; typedef pair\u003cint, int\u003e pii; const int M = 2e5 + 10; const ll INF = 0x3f3f3f3f; int n, m, s, cnt = 0; struct edges { int w, to, next; edges(int a = 0, int b = 0, int c = -1) : w(b), to(a), next(c) {} }; vector\u003cint\u003e head, dis; vector\u003cedges\u003e edge; inline void add(int u, int v, int w) { edge[++cnt] = edges(v, w, head[u]); head[u] = cnt; } void dij() { vector\u003cbool\u003e vis(n + 1, false); dis = vector\u003cint\u003e(n + 1, INF); priority_queue\u003cpii, vector\u003cpii\u003e, greater\u003cpii\u003e \u003e heap; dis[s] = 0; heap.push(make_pair(0, s)); while (heap.size()) { int u = heap.top().second; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to, w = edge[i].w; if (dis[v] \u003e dis[u] + w) { dis[v] = dis[u] + w; heap.push(make_pair(dis[v], v)); } } } } int main() { scanf(\"%d%d%d\", \u0026n, \u0026m, \u0026s); head = vector\u003cint\u003e(n + 1, -1); edge = vector\u003cedges\u003e(m + 1); for (int i = 0; i \u003c m; i++) { int u, v, w; scanf(\"%d%d%d\", \u0026u, \u0026v, \u0026w); add(u, v, w); } dij(); for (int i = 1; i \u003c= n; i++) { printf(\"%d \", dis[i]); } puts(\"\"); return 0; } 洛谷P1629 邮递员送信 题意：一个邮递员从一号顶点出发送东西，一次只能送一个，送完就要回到1号节点，求送完后的最短路(注意：有向图的往返) 思路：两次Dijkstra就可以了 代码如下 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cqueue\u003e#include \u003cutility\u003e#define mk(a, b) make_pair(a, b) using namespace std; typedef pair\u003cint, int\u003e pii; const int INF = 0x3f3f3f3f; int n, m, cnt = 0; vector\u003cint\u003e dis, ddis, head, head2; struct edges { int to, w, next; edges(int a = 0, int b = 0, int c = -1) : to(a), w(b), next(c) {} }; vector\u003cedges\u003e edge, bk; void init() { head = vector\u003cint\u003e(n + 1, -1); head2 = vector\u003cint\u003e(n + 1, -1); dis = vector\u003cint\u003e(n + 1, INF); ddis = vector\u003cint\u003e(n + 1, INF); edge = vector\u003cedges\u003e(m + 1); bk = vector\u003cedges\u003e(m + 1); } void add(int u, int v, int w) { edge[++cnt] = edges(v, w, head[u]); bk[cnt] = edges(u, w, head2[v]); head[u] = cnt; head2[v] = cnt; } void dij() { priority_queue\u003cpii\u003e heap; vector\u003cbool\u003e vis(n + 1, false); heap.push(mk(0, 1)); while (heap.size()) { int u = heap.top().second; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to, w = edge[i].w; if (dis[v] \u003e dis[u] + w) { dis[v] = dis[u] + w; heap.push(mk(-dis[v], v)); } } } } void dij2() { priority_queue\u003cpii\u003e heap; vector\u003cbool\u003e vis(n + 1, false); heap.push(mk(0, 1)); while (heap.size()) { int u = heap.top().second; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head2[u]; ~i; i = bk[i].next) { int v = bk[i].to, w = bk[i].w; if (ddis[v] \u003e ddis[u] + w) { ddis[v] = ddis[u] + w; heap.push(mk(-ddis[v], v)); } } } } int main() { scanf(\"%d%d\", \u0026n, \u0026m); init(); for (int i = 0; i \u003c m; i++) { int u, v, w; scanf(\"%d%d%d\", \u0026u, \u0026v, \u0026w); add(u, v, w); } dis[1] = ddis[1] = 0; dij(); dij2(); int ans = 0; for (int i = 1; i \u003c= n; i++) { ans += dis[i] + ddis[i]; } printf(\"%d\", ans); return 0; } 洛谷P1144 最短路计数 题意：无向图，每条边的权值都为 1， 求从一号顶点出发到其他顶点的最短路的个数 思路：用个$ans$数组储存最短路的个数，Dijkstra内加个计数条件，如果有松弛操作则$ans$继承上一个节点最短路的个数，如果没用松弛操作，就直接让$ans$加上一节点的$ans$（注：ans[1]初始化为1， 其余都初始化为0） 代码如下 #include \u003cbits/stdc++.h\u003e using namespace std; typedef pair\u003cint, int\u003e pii; const int M = 1e6 + 5; int n, m, dis[M], head[M], ans[M], cnt = 0; struct es { int to, next; es(int a = 0, int b = -1) : to(a), next(b) {} } e[M \u003c\u003c 2]; void add(int a, int b) { e[++cnt] = es(b, head[a]); head[a] = cnt; } void dij() { for (int i = 2; i \u003c= n; i++) { dis[i] = 0x3f3f3f3f; } ans[1] = 1; vector\u003cbool\u003e vis(n + 1, false); priority_queue\u003cpii\u003e heap; heap.push(make_pair(0, 1)); while (heap.size()) { int u = heap.top().second; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (dis[v] \u003e dis[u] + 1) {//松弛操作 dis[v] = dis[u] + 1; ans[v] = ans[u]; heap.push(make_pair(-dis[v], v)); } else if (dis[u] + 1 == dis[v]","date":"2020-07-21","objectID":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:3:1","tags":["图论"],"title":"图论刷题总结","uri":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"Bellman-Ford 这个算法更多的不是用来计算最短路，而是用来计算是否有负环或者正环（负环dis初始化为INF，正环dis初始化为0） 【例题】 EOlymp - 1453 Ford-Bellman 题意：给你一个有向图，有负权边，保证没有负环，求1号顶点到各个点的最短距离，如果无法到达顶点，距离输出30000 思路：就是一个很纯正的Bellman - Ford的板子题 直接上代码 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; const int INF = 0x3f3f3f3f; int n, m; vector\u003cint\u003e dis; struct edges { int u, v, w; edges(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) {} }; vector\u003cedges\u003e e; int add(int a, int b) { //无穷大加任何数还是无穷大 if (a == INF || b == INF) return a; return a + b; } void bf() { bool flag; while (true) { flag = true; for (int j = 0; j \u003c m; j++) { if (dis[e[j].v] \u003e add(dis[e[j].u], e[j].w)) { dis[e[j].v] = dis[e[j].u] + e[j].w; flag = false; } } if (flag) return; } } int main() { scanf(\"%d%d\", \u0026n, \u0026m); dis = vector\u003cint\u003e(n + 1, INF); for (int i = 0; i \u003c m; i++) { int u, v, w; scanf(\"%d%d%d\", \u0026u, \u0026v, \u0026w); e.push_back(edges(u, v, w)); } dis[1] = 0; bf(); for (int i = 1; i \u003c= n; i++) { if (dis[i] == INF) dis[i] = 30000; printf(\"%d \", dis[i]); } puts(\"\"); return 0; } POJ 2240 Arbitrage 题意：给你一个有向图，判断是否有正环 思路：把字符串的顶点用hash来代替，然后就是标准的Bellman - Ford模板题了,正环判断dis初始化为0 代码如下 #include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cmap\u003e#include \u003cstring\u003e#include \u003cvector\u003e using namespace std; int n, m, test = 0; double dis[100]; string str; struct es { int u, v; double w; es(int a = 0, int b = 0, double c = 0) : u(a), v(b), w(c) {} }; vector\u003ces\u003e e; bool bf() { for (int i = 1; i \u003c= n - 1; i++) { for (int j = 0; j \u003c m; j++) { if (dis[e[j].v] \u003c dis[e[j].u] * e[j].w) { dis[e[j].v] = dis[e[j].u] * e[j].w; } } } for (int i = 0; i \u003c m; i++) { if (dis[e[i].v] \u003c dis[e[i].u] * e[i].w) { return true; } } return false; } int main() { map\u003cstring, int\u003e hsh; while (cin \u003e\u003e n, n) { for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e str; hsh[str] = i; } cin \u003e\u003e m; e = vector\u003ces\u003e(m); for (int i = 0; i \u003c m; i++) { string a, b; double w; cin \u003e\u003e a \u003e\u003e w \u003e\u003e b; e[i] = es(hsh[a], hsh[b], w); } memset(dis, 0, sizeof dis); dis[1] = 1; if (bf()) { cout \u003c\u003c \"Case \" \u003c\u003c ++test \u003c\u003c \": Yes\" \u003c\u003c endl; } else { cout \u003c\u003c \"Case \" \u003c\u003c ++test \u003c\u003c \": No\" \u003c\u003c endl; } } return 0; } POJ 3259 Wormholes 题意：有两种边，一种是双向边，一种是单线负权边，问你是否有负环 思路：双向边和负权边都用邻接表存起来，然后就是普通的Bellman - Ford了 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; const int M = 3e3; int n, m, ww, f, dis[510]; struct es { int u, v, w; es(int a = 0, int b = 0, int c = 0) : u(a), v(b), w(c) {} }; vector\u003ces\u003e e; bool bf() { for (int i = 1; i \u003c= n; i++) { bool flag = true; for (int j = 0; j \u003c m + m + ww; j++) { if (dis[e[j].v] \u003e dis[e[j].u] + e[j].w) { dis[e[j].v] = dis[e[j].u] + e[j].w; flag = false; } } if (flag) break; if (i == n) return true;//有负环，因为松弛了 n 次 } return false; } int main() { scanf(\"%d\", \u0026f); while (f--) { scanf(\"%d%d%d\", \u0026n, \u0026m, \u0026ww); int u, v, w; for (int i = 0; i \u003c m; i++) { scanf(\"%d%d%d\", \u0026u, \u0026v, \u0026w); e.push_back(es(u, v, w)); e.push_back(es(v, u, w)); } for (int i = 0; i \u003c ww; i++) { scanf(\"%d%d%d\", \u0026u, \u0026v, \u0026w); e.push_back(es(u, v, -w)); } memset(dis, 0x3f, sizeof dis); dis[1] = 0; if (bf()) puts(\"YES\"); else puts(\"NO\"); e.clear(); } return 0; } POJ 1860 Currency Exchange 题意：给你一个有向图，你手中有v元的a货币，每个顶点都是一个货币兑换点，每个兑换点都有自己的兑换费用和兑换比例，并且兑换是双向的，例如 a → b, b → a，但兑换比率和兑换费用不一定一样，由测试样例给，问你从某点出发，回到该点时，即兑换会原本的货币种类，他手中的钱能否变多 思路：判断正环，唯一要注意的就是初始化 $ dis[s] = V $，其余初始化为0 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003eusing namespace std; const int M = 300; int n, m, s; double vv, dis[M] = {0}; //vv是一开始手中的钱的数量 struct es { int u, v; double r, c; es(int a = 0, int b = 0, double c = 0, double d = 0) : u(a), v(b), r(c), c(d) {} } e[M]; bool bf() { for (int i = 1; i \u003c= n - 1; i++) { for (int j = 0; j \u003c m + m; j++) { if (dis[e[j].v] \u003c (dis[e[j].u] - e[j].c) * e[j].r) { dis[e[j].v] = (dis[e[j].u] - e[j].c) * e[j].r; } } } for (int j = 0; j \u003c m + m; j++) { if (dis[e[j].v] \u003c (dis[e[j].u] - e[j].c) * e[j].r) { return true; //手中的钱变多了 } } return false;//手中的钱没变或者少了 } int main() { scanf(\"%d%d%d%lf\", \u0026n, \u0026m, \u0026s, \u0026vv); for (int i = 0; i \u003c m; i++)","date":"2020-07-21","objectID":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:3:2","tags":["图论"],"title":"图论刷题总结","uri":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"Floyd POJ 2253 Frogger 题意：一直青蛙想通过石头跳到另一只青蛙那里，但是他的跳跃能力是有封顶的，即他的能力是有限的，最多能跳1米的话，绝对跳不到1.1米远的石头上，给你石头的坐标，和两只青蛙的坐标，问你青蛙的最远能跳的封顶距离的最小值是多少 思路：一个最短路的变形题，用Floyd比较好想（其他方法也可），转换成人话就是让你求从 a 点到 b 点的路径中，最小边权的最大值是多少，有点绕，自己草稿纸画个图就明白了 代码如下 #include \u003calgorithm\u003e#include \u003ccmath\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; const int M = 2e2 + 10; int n, x[M], y[M], test = 0; double dis[M][M]; void Floyd() { for (int k = 1; k \u003c= n; k++) { for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= n; j++) { if (dis[i][j] \u003e max(dis[i][k], dis[k][j])) { dis[i][j] = max(dis[i][k], dis[k][j]); } // dis[i][j] = min(dis[i][j], max(dis[i][k], dis[k][j]));//更清晰的代码 } } } } int main() { while (scanf(\"%d\", \u0026n), n) { scanf(\"%d%d%d%d\", \u0026x[1], \u0026y[1], \u0026x[2], \u0026y[2]); double a = x[2] - x[1], b = y[2] - y[1]; dis[1][2] = sqrt(a * a + b * b); for (int i = 3; i \u003c= n; i++) { scanf(\"%d%d\", \u0026x[i], \u0026y[i]); for (int j = 1; j \u003c i; j++) { a = x[i] - x[j], b = y[i] - y[j]; dis[i][j] = sqrt(a * a + b * b); dis[j][i] = dis[i][j]; } } Floyd(); printf(\"Scenario #%d\\nFrog Distance = %.3f\\n\\n\", ++test, dis[1][2]); memset(dis, 0, sizeof dis); } return 0; } POJ 1125 Stockbroker Grapevine 题意：给你一个有向图，问你是否能从一点出发到达所有其他顶点，如果有输出该点编号并输出到达这些顶点的最短路中的最大值，否则输出\"disjoint\" 思路：显然Floyd算法，在Floyd完了之后遍历每个最短路，看看取最短路的最大值和其起点，如果这个最大值是无穷大则说明没有一个顶点可以到达其他顶点 代码如下 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; const int M = 110; int n, tm[M][M], dis[M][M]; void floyd() { for (int k = 1; k \u003c= n; k++) { for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= n; j++) { dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); } } } } int main() { #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif while (scanf(\"%d\", \u0026n), n) { memset(dis, 0x3f, sizeof dis); memset(tm, 0x3f, sizeof tm); for (int i = 1; i \u003c= n; i++) { int m; scanf(\"%d\", \u0026m); for (int j = 0; j \u003c m; j++) { int x, y; scanf(\"%d%d\", \u0026x, \u0026y); dis[i][x] = y; } } floyd(); int ans = -1, Min = 0x3f3f3f3f; for (int i = 1; i \u003c= n; i++) { int Max = 0; for (int j = 1; j \u003c= n; j++) { if (i != j \u0026\u0026 dis[i][j] \u003e Max) { Max = dis[i][j]; } } if (Max \u003c Min) { ans = i; Min = Max; } } if (Min == 0x3f3f3f3f) { puts(\"disjoint\"); continue; } printf(\"%d %d\\n\", ans, Min); } return 0; } ","date":"2020-07-21","objectID":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:3:3","tags":["图论"],"title":"图论刷题总结","uri":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"Spfa 一种速度极快的最短路算法，但是听说被一位大佬卡死了，但是在一些题目上还是能用的，下面利用这个算法来解决上面的一些题 存图的方式最好是邻接表法，这样比较方便松弛 其实道理都差不多，题目的不同，主要修改的就是松弛操作部分的代码 【例题】 POJ 3259 Wormholes 上面的Bellman - Ford算法的例题，除了存图的方式不同，松弛的操作还是不变 直接上代码 #include \u003calgorithm\u003e#include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003cqueue\u003e#include \u003cvector\u003e using namespace std; const int M = 2e4; int n, m, ww, f, dis[510], head[510], cnt = 0; struct es { int to, w, next; es(int a = 0, int b = 0, int c = -1) : to(a), w(b), next(c) {} }; vector\u003ces\u003e e; void add(int u, int v, int w) { e[++cnt] = es(v, w, head[u]); head[u] = cnt; } bool spfa() { queue\u003cint\u003e q; vector\u003cbool\u003e inq(n + 1); vector\u003cint\u003e nums(n + 1, 0); q.push(1); inq[1] = true; nums[1]++; while (q.size()) { int u = q.front(); q.pop(); inq[u] = false; for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to, w = e[i].w; if (dis[v] \u003e dis[u] + w) { dis[v] = dis[u] + w; if (!inq[v]) { q.push(v); inq[v] = true; nums[v]++; if (nums[v] \u003e= n) return true; } } } } return false; } int main() { scanf(\"%d\", \u0026f); while (f--) { cnt = 0; memset(head, -1, sizeof head); scanf(\"%d%d%d\", \u0026n, \u0026m, \u0026ww); e = vector\u003ces\u003e(m + m + ww + 1); int u, v, w; for (int i = 0; i \u003c m; i++) { scanf(\"%d%d%d\", \u0026u, \u0026v, \u0026w); add(u, v, w); add(v, u, w); } for (int i = 0; i \u003c ww; i++) { scanf(\"%d%d%d\", \u0026u, \u0026v, \u0026w); add(u, v, -w); } memset(dis, 0x3f, sizeof dis); dis[1] = 0; if (spfa()) puts(\"YES\"); else puts(\"NO\"); e.clear(); } return 0; } ","date":"2020-07-21","objectID":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:3:4","tags":["图论"],"title":"图论刷题总结","uri":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["总结"],"content":"未完待续 ","date":"2020-07-21","objectID":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/:4:0","tags":["图论"],"title":"图论刷题总结","uri":"/2020/07/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["cf补题"],"content":"传送门 ","date":"2020-07-06","objectID":"/2020/07/654div2problemc/:0:0","tags":["数学","思维","模拟","题解"],"title":"C. A Cookie for You题解","uri":"/2020/07/654div2problemc/"},{"categories":["cf补题"],"content":"题意 有 a 个 饼干，和 b 个巧克力 有 n 个 第一类人，有 m 个第二类人 对于第一类人， if (a \u003e b)吃一个饼干，else 吃一个巧克力 对于第二类人， if (a \u003e b)吃一个巧克力，else 吃一个饼干 问你是否有一种方法能让第一类和第二类人都有东西吃，有输出Yes，否则输出No ","date":"2020-07-06","objectID":"/2020/07/654div2problemc/:1:0","tags":["数学","思维","模拟","题解"],"title":"C. A Cookie for You题解","uri":"/2020/07/654div2problemc/"},{"categories":["cf补题"],"content":"思考 很显然第一类人优先吃多的（一样多就吃巧克力），第二类人优先吃少的（一样多就吃饼干） 有两种思路，一个是我自己比赛时想到的，一个是x大佬讲的 方法一 一来就判断饼干和巧克力的总数够不够第一类和第二类人吃，如果不够，直接No，如果够如下 先让第二类人吃，方便我们思考，因为东西只会被越吃越少嘛，不可能越吃越多，所以他自始至终都会不会换别的吃 然后就是判断最少的是否够第二类人吃。先讨论最简单的——够，显然如果够的话则第一类人一定够吃，为什么，因为第一类人是优先吃最多的，而我们先判断的是总数都够吃，所以无论怎么吃，不管最多的东西怎么变化，都是够吃的,所以是Yes； 但是如果不够吃呢，直接就是No，为什么，解释起来有点麻烦（比赛时候我就是这里没有想好，一直往别的地方想，自己扰乱了自己的思维）。先这样想，如果不够吃，那么最小的永远都是那一个（饼干或者巧克力一开始最少的）：因为不够吃，所以那一个就会被吃完（即等于0），但是呢第二类人还有没吃到的，他们只会吃最少的那一个，而最少的那一个个数是0了，所以无论如何都吃不了了。 比赛的时候我往别的地方想了（相信不止我会这样想歪，现在想通了，解释一下，可能会有点啰嗦）：就是如果最少的不够第二类人吃的话那就一开始先让第一类人吃，或者中途到了某个关系后交替来吃。但是这样只会让自己陷入窘境，其实这种情况下，无论是让第一类人先吃，还是交替吃，都不会改变第二类人没得吃的结果。因为第一类人的插入只会让最多数量的那个东西变少，一直吃到饼干和巧克力个数一样时，最少的个数依然是最少，即便最少的种类可能会变，但是第二类人能吃的个数不会变。换句话说就是，即便它最少或最多的种类转移了，第二类依然会吃最少的，他不可能可以多吃一个多的那一个（即便饼干和巧克力相等） 详细见代码solve()函数 方法二 第一步和方法一相同，总数不够就No，否则如下 利用一个小规律：先让第二类人吃一次，再让第一类人吃一次，这样的话无论两者大小，饼干数和巧克力数都会各自减一。利用这个特点把人和东西给简化。 第一种可能，东西（饼干或者巧克力）优先有一方优先减到0，而两类人都还有，那么一定是No，因为第二类人只吃最少的，而最少的为0了 第二种可能就是，人优先有一方减到了0，这时候如果是第二类人减到了0，显然就是Yes（道理和方法一中最少数量的东西够第一类人吃是一样的）。如果是第一类人减到了0，那么也就是说只剩下第二类人，因为第二类人只吃最少的，所以只要判断最少的那个东西够不够第二类人吃就行了，够就Yes，不够就No 详细见代码solve2()函数 代码如下 #include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef vector\u003cint\u003e vi; typedef vector\u003clong long\u003e vll; typedef pair\u003cint, int\u003e pii; typedef pair\u003clong long, long long\u003e pll; #define debug printf(\"(hao)\") #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i \u003c (b); i++) #define clr(a, v) memset(a, v, sizeof(a)) void solve() {//方法一 // int n; ll a, b, n, m; scanf(\"%lld%lld%lld%lld\", \u0026a, \u0026b, \u0026n, \u0026m); if (a + b \u003c n + m) printf(\"No\\n\"); //判断总数够不够吃，不够吃就No else { ll Min = min(a, b); //寻找最小的一堆食物 if (Min \u003e= m) printf(\"Yes\\n\"); // 最少的够第二类人吃 else printf(\"No\\n\"); //最少的不够第二类人吃 } } void solve2() {//方法二 // int n; ll a, b, n, m; scanf(\"%lld%lld%lld%lld\", \u0026a, \u0026b, \u0026n, \u0026m); if (a + b \u003c n + m) printf(\"No\\n\"); else { ll temp = min(n, m), tmin = min(a, b); if (tmin \u003e= temp) { //如果人先出现0，即第二种可能 a -= temp, b -= temp, n -= temp, m -= temp;//全部均掉简化 if (m == 0) printf(\"Yes\\n\");//第二类人为0 else { //还有第二类人剩下 if (min(a, b) \u003e= m) printf(\"Yes\\n\"); else printf(\"No\\n\"); } } else printf(\"No\\n\"); //食物先出现0，即上述第一种可能 } } // #define LOCAL int main() { std::ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif int T; scanf(\"%d\", \u0026T); while (T--) { solve(); // solve2(); } return 0; } ","date":"2020-07-06","objectID":"/2020/07/654div2problemc/:2:0","tags":["数学","思维","模拟","题解"],"title":"C. A Cookie for You题解","uri":"/2020/07/654div2problemc/"},{"categories":["cf补题"],"content":"反思 在比赛的时候想到了方法一，但是没有认真用代码实现，并且在往深处思考的时候反而被别个可能性干扰了，也没能及时想出方法反驳自己，而是冒出让第一类人先吃的想法解决自己的矛盾，并没有想到就算第一类人吃了耶挽回不了第二类人的命运（没得吃） 感觉自己当时思维会混乱极有可能就是比赛的状态，打得少，做得少 想到方法就往一处想，尽量不要再想别的，或者想到别的发现想不下去就回到之前的状态重新换方向想 ","date":"2020-07-06","objectID":"/2020/07/654div2problemc/:3:0","tags":["数学","思维","模拟","题解"],"title":"C. A Cookie for You题解","uri":"/2020/07/654div2problemc/"},{"categories":["cf补题"],"content":"总结 模拟就是要看题量如何 思维的严谨和正确性都是题量堆积出来的，经验的多少决定（十分影响）了思维的快慢和正误 所以做刷题，多打比赛，多总结 ","date":"2020-07-06","objectID":"/2020/07/654div2problemc/:4:0","tags":["数学","思维","模拟","题解"],"title":"C. A Cookie for You题解","uri":"/2020/07/654div2problemc/"},{"categories":["cf补题"],"content":"传送门 ","date":"2020-07-06","objectID":"/2020/07/653div3probleme1/:0:0","tags":["贪心","思维","排序","题解"],"title":"E1. Reading Books (easy version)题解","uri":"/2020/07/653div3probleme1/"},{"categories":["cf补题"],"content":"题意 小A和小B要读书，现在共又 n 本书，对于每本书都有三个参数，$t_i$：阅读的时间、$a_i$：小A喜欢读的书、$b_i$：小B喜欢读的书 现在小A和小B都要读 k 本书，但是他俩只读自己喜欢的书 问你小A和小B最少要读多久可以读到 k 本书，（对于都喜欢的书，时间是可以只算一次的） 如果他俩有一个没读到 k 本书就输出 -1 ","date":"2020-07-06","objectID":"/2020/07/653div3probleme1/:1:0","tags":["贪心","思维","排序","题解"],"title":"E1. Reading Books (easy version)题解","uri":"/2020/07/653div3probleme1/"},{"categories":["cf补题"],"content":"思路 一道思维贪心题cf好狠呀，网上有很多的解法，大多数都是模拟+贪心，但是我看到了一位大佬的贪心思路，醍醐灌顶，下面就用它的思路了 对于每个书本可以分为以下四类 小A和小B都喜欢的书 只有小A喜欢的书 只有小B喜欢的书 他俩都不喜欢的书 显然最后一类可以不管不要呀，看书长知识，目前只考虑第二三类的书，可以分别用数组$a_n$和$b_n$记录这些书的阅读时间，然后从小到大排序，精彩的来了，把$a_i 和 b_i$合成一本书当作是第一类的书（妙呀,我怎么没想到，太笨了，太菜了，刷题少），然后放入第一类，再来对第一类的书的阅读时间排序，选前 k 个书，记录阅读时间就是最终答案 代码如下 #include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef vector\u003cint\u003e vi; typedef vector\u003clong long\u003e vll; typedef pair\u003cint, int\u003e pii; typedef pair\u003clong long, long long\u003e pll; #define debug printf(\"(hao)\") #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i \u003c (b); i++) #define clr(a, v) memset(a, v, sizeof(a)) const int M = 2e5 + 10; vi a, b, t; void solve() { int n, k; scanf(\"%d%d\", \u0026n, \u0026k); rep(i, 0, n) { int _t, _a, _b; scanf(\"%d%d%d\", \u0026_t, \u0026_a, \u0026_b); if (_a \u0026\u0026 _b) t.push_back(_t); // 第一类 else if (_a) a.push_back(_t); // 第二类 else if (_b) b.push_back(_t); //第三类 } sort(all(a)); sort(all(b)); rep(i, 0, (int)min(a.size(), b.size())) t.push_back(a[i] + b[i]);//精辟之处 if ((int)t.size() \u003c k) {//如果不够 k 本，就输出 -1 printf(\"-1\\n\"); return; } sort(all(t)); int res = 0; rep(i, 0, k) res += t[i]; printf(\"%d\\n\", res); } // #define LOCAL int main() { std::ios::sync_with_stdio(false); #ifdef LOCAL freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif // int T; // scanf(\"%d\", \u0026T); // while (T--) solve(); return 0; } ","date":"2020-07-06","objectID":"/2020/07/653div3probleme1/:2:0","tags":["贪心","思维","排序","题解"],"title":"E1. Reading Books (easy version)题解","uri":"/2020/07/653div3probleme1/"},{"categories":["cf补题"],"content":"反思 比赛的时候没做到这题，一个字：菜 一开始用结构体来分析每一本书，后来才学到了把书本分类，然后贪心 贪心渐渐地不会了 以后cf前几题看看和贪心有没有关系 ","date":"2020-07-06","objectID":"/2020/07/653div3probleme1/:3:0","tags":["贪心","思维","排序","题解"],"title":"E1. Reading Books (easy version)题解","uri":"/2020/07/653div3probleme1/"},{"categories":["cf补题"],"content":"总结 这个结构题的题很巧妙地把他拆开，从而没有用到结构题，好处就是排序压力小 这场比赛很喜欢思维题和贪心 当有两个（或多个）共同影响时，要考虑把他们拆开来计算 …… ","date":"2020-07-06","objectID":"/2020/07/653div3probleme1/:4:0","tags":["贪心","思维","排序","题解"],"title":"E1. Reading Books (easy version)题解","uri":"/2020/07/653div3probleme1/"},{"categories":["cf补题"],"content":"传送门 ","date":"2020-07-06","objectID":"/2020/07/653div3problemd/:0:0","tags":["数学","思维","数组","排序","题解"],"title":"D. Zero Remainder Array题解","uri":"/2020/07/653div3problemd/"},{"categories":["cf补题"],"content":"题意 给你一个长度为 n 的数组$a_n$，和一个 k，你有一个 x（一开始为0），你有以下两种操作 给 x 加上 1，即$x = x + 1$ 选择一个任意一个$a_i$($0 \\le i \u003c n$)加上 x，然后 x 加上 1 每个元素最多只能被执行一次上诉操作 问你执行上述操作，x 最小为多少可以使得数组所有元素都能整除 k ","date":"2020-07-06","objectID":"/2020/07/653div3problemd/:1:0","tags":["数学","思维","数组","排序","题解"],"title":"D. Zero Remainder Array题解","uri":"/2020/07/653div3problemd/"},{"categories":["cf补题"],"content":"思路 记录数组的每一个数至少要加多少才可以被 k 整除 寻找上述数中的最大的众数，计算 x 加到多少才可以使得这些数都能被 k 整除。 例如 对于一个数组 {1，1，1，2，3}，k = 6 则其至少要加的数为 {5，5，5，4，3} 显然最大的众数是 5，其个数是 3，那么对于第一个 5 则需要把 x 加到 5 就行了，对于第二个 5 ，就需要再等到下一个能模 6 为 5 的数，显然就是11($5 + 6 = 11$), 而第三个 5 也是同理就是 17，但这个还不是最终答案，因为题目的第二个操作是先给数组加上 x，再让 $x + 1$,所以最终答案就是 18 为什么这样就是对的呢？很简单，如果想要执行题中把所有数都弄成可以整除 k 并且每个数只能执行一次，对于两个相同且不能被 k 整除的数 y，想要把这两个 y 都弄成能被 k 整除，第二个数 y 一定要等到下一次有一个数 x 加上这个 y 使得它能整除 k。 所以我们要求出每个数最少加多少才可以被 k 整除，然后求一个最大的众数，计算最后一个众数需要的最小x（因为最后的 x 一定是停在了能使这些最大众数的最后一个数被 k 整除的结果），记得最后的答案要再加一才是最终答案。 那么其余的非最大众数呢？别担心，这些数在为最大众数服务的时候就能有一个 x 使得他们的一些能被 k 整除。例如上面的例子，我们在把 x 走到 5 的之前就有个4，可以使得数组中的 2 加上这个 4 能被 6 整除 还想不明白就想想模数具有周期性，例如将0 ~ n中的数都摸上 3 ，就会有这么一个规律 ：0 1 2 0 1 2 0 1 2 0 1 2····· 代码如下（求众数有点滑稽，因为我不会利用简单代码的求众数的方法） #include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef vector\u003cint\u003e vi; typedef vector\u003clong long\u003e vll; typedef pair\u003cint, int\u003e pii; typedef pair\u003clong long, long long\u003e pll; #define debug printf(\"(hao)\") #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i \u003c (b); i++) #define clr(a, v) memset(a, v, sizeof(a)) void solve() { long long n, k; scanf(\"%lld%lld\", \u0026n, \u0026k); vll arr; rep(i, 0, n) { long long tmp; scanf(\"%lld\", \u0026tmp); if (tmp % k != 0) //如果这个数不能被 k 整除 arr.push_back(k - tmp % k); //对于每个数把最少加多少能被 k 整除的数放到数组里 } if (arr.empty()) {//如果数组的数都能被 k 整除，操作次数就使 0 printf(\"0\\n\"); return; } sort(all(arr)); long long Max = 1, w = arr[0]; int len = arr.size(); for (int i = 1; i \u003c len;) { //求最大众数，方法比较蠢 int sen = 1; //计算出现个数 if (arr[i] == arr[i - 1]) { while (arr[i] == arr[i - 1] \u0026\u0026 i \u003c len) { sen++; i++; } } else { i++; } if (Max \u003c= sen) Max = sen, w = arr[i - 1];//如果出现次数比之前算的要多 } printf(\"%lld\\n\", w + k * (Max - 1) + 1); } // #define LOCAL int main() { std::ios::sync_with_stdio(false); #ifdef LOCAL freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif int T; scanf(\"%d\", \u0026T); while (T--) solve(); return 0; } ","date":"2020-07-06","objectID":"/2020/07/653div3problemd/:2:0","tags":["数学","思维","数组","排序","题解"],"title":"D. Zero Remainder Array题解","uri":"/2020/07/653div3problemd/"},{"categories":["cf补题"],"content":"反思 找规律的能力不强 面对模没有想到他的一个周期性 ","date":"2020-07-06","objectID":"/2020/07/653div3problemd/:3:0","tags":["数学","思维","数组","排序","题解"],"title":"D. Zero Remainder Array题解","uri":"/2020/07/653div3problemd/"},{"categories":["cf补题"],"content":"总结 对连续的数模具有一定周期性 众数的求法不熟练 这题在真正计算的时候用的不是原数组 ","date":"2020-07-06","objectID":"/2020/07/653div3problemd/:4:0","tags":["数学","思维","数组","排序","题解"],"title":"D. Zero Remainder Array题解","uri":"/2020/07/653div3problemd/"},{"categories":["cf补题"],"content":"传送门 ","date":"2020-07-06","objectID":"/2020/07/653div3problemc/:0:0","tags":["贪心","思维","字符串","栈","题解"],"title":"C. Move Brackets题解","uri":"/2020/07/653div3problemc/"},{"categories":["cf补题"],"content":"题意 给你一串字符串，只有\"(\" h和\")“组成，你每次都能选择一个字符把它移到最左边或者最右边，问你最少移动几次可以使得字符串的括号合法 ","date":"2020-07-06","objectID":"/2020/07/653div3problemc/:1:0","tags":["贪心","思维","字符串","栈","题解"],"title":"C. Move Brackets题解","uri":"/2020/07/653div3problemc/"},{"categories":["cf补题"],"content":"思路 一道贪心题（比赛的时候没看出来，太菜了😭） 只要计算出合法的括号对，然后用总长度减去合法的括号对的个数，即剩余的不合法长度除以 2 就是最少的步数 例如 ： “()))))((((()”, 去掉合法的后就是”))))((((\", 那么移动的长度就是$8 \\div 2 = 4$就是答案 这题我一开始想复杂了，对于上一个样例，我以为必须要把下标为2 ~ 5（从0开始）的先一道最左边，再把（原本的）6 ~ 9移到最左边，变成这样：\"(((())))()()\",总次数是8，所以就很搞了，然而正确答案是把6 ~ 9 移到最左边就合法了，就是这样：\"((((()))))()\",总次数就是 4 所以最终的思路就是判断合法的有多少对：在博客中遇到了两种方法，一种是用栈，一种是不用栈（根据括号合法的特性一定要左括号先出现， 即从头到尾遍历，用一个变量来储存左括号出现次数，一旦遇到右括号变量值就自减） 代码如下（用栈）： #include \u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef vector\u003cint\u003e vi; #define debug printf(\"(hao)\") #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i \u003c (b); i++) #define clr(a, v) memset(a, v, sizeof(a)) void solve() { int n; char bra[55]; stack\u003cchar\u003e res; scanf(\"%d\", \u0026n); scanf(\"%s\", bra); for (int i = 0; i \u003c n; i++) { if (res.empty()) res.push(bra[i]); //栈为空，就无论什么括号都放进去 else if (bra[i] == ')') //如果是右括号 if (res.top() == '(') res.pop();//栈顶是左括号，就弹出 else res.push(bra[i]); //否则把右括号入栈 else res.push(bra[i]); //如果是左括号，就直接入栈 } printf(\"%d\\n\", (int)res.size() \u003e\u003e 1); } // #define LOCAL int main() { std::ios::sync_with_stdio(false); #ifdef LOCAL freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif int T; scanf(\"%d\", \u0026T); while (T--) solve(); return 0; } ","date":"2020-07-06","objectID":"/2020/07/653div3problemc/:2:0","tags":["贪心","思维","字符串","栈","题解"],"title":"C. Move Brackets题解","uri":"/2020/07/653div3problemc/"},{"categories":["cf补题"],"content":"反思 这题我最开始是误会了求最小移动步数，后来发现是操作次数，还是没看出要贪心 遇到括号就直接想想括号的一些小性质（例如：合法的括号长度一定是偶数、括号的合法一定是左括号在前等等） 有括号优先考虑是否要用到栈来辅助 ","date":"2020-07-06","objectID":"/2020/07/653div3problemc/:3:0","tags":["贪心","思维","字符串","栈","题解"],"title":"C. Move Brackets题解","uri":"/2020/07/653div3problemc/"},{"categories":["cf补题"],"content":"总结 cf的前几题不是思维就是贪心，代码不难，但是找规律难 多刷这种题，我觉得这也是解决一些困难题目的基础 ","date":"2020-07-06","objectID":"/2020/07/653div3problemc/:4:0","tags":["贪心","思维","字符串","栈","题解"],"title":"C. Move Brackets题解","uri":"/2020/07/653div3problemc/"},{"categories":["cf补题"],"content":"传送门 ","date":"2020-07-06","objectID":"/2020/07/653div3problemb/:0:0","tags":["思维","数学","题解","模拟"],"title":"B. Multiply by 2, divide by 6题解","uri":"/2020/07/653div3problemb/"},{"categories":["cf补题"],"content":"题意 给一个数 n,问你只进行以下两种操作，要操作最少多少次能够使得 n 为 1： 把 n 除以 6 （前提是可以整除） 把 n 乘 2 输出最少的操作次数，如果无论如何都没办法得到 1，则输出 -1 ","date":"2020-07-06","objectID":"/2020/07/653div3problemb/:1:0","tags":["思维","数学","题解","模拟"],"title":"B. Multiply by 2, divide by 6题解","uri":"/2020/07/653div3problemb/"},{"categories":["cf补题"],"content":"思路 首先要知道的是，如果对一个数同时进行两个操作就相当于对 n 除以 3 思考一个极端的例子就是：n 的质因子只有 3，那么它一定可以最终得到 1。为什么呢？因为我们可以让每个 3 都乘 2， 这样他就有了因子 6， 便可以做第一个操作了，并且最终得到 1 如果这个数既有 2 又有 3 怎么办？ 很简单，只需要把一对 2 和 3 看成 6，最终剩下的因子如果是 2（因为已经无望再去除以 6 了），则不可能得到 1，如果是 3， 则当成只有因子 3 的数看待（即上述的极端情况） 最后一种情况就是 n 的质因子除了 3 和 2 还有其他的质因子的话，一定最终无法得到 1 所以最终的想法就是：计算出质因子 2 的个数a，和计算出质因子 3 的个数 b, 如果 $a \u003e b$ 则无法得到 1，否则要操作的次数最少为 $(b - a) \\times 2 + a$ 代码如下 #include \u003cbits/stdc++.h\u003eusing namespace std; typedef long long ll; typedef vector\u003cint\u003e vi; #define debug printf(\"(hao)\") #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i \u003c (b); i++) #define clr(a, v) memset(a, v, sizeof(a)) //主代码函数 void solve() { int n, a = 0, b = 0; scanf(\"%d\", \u0026n); while (n % 2 == 0) n /= 2, a++; //计算质因子 2 的个数 while (n % 3 == 0) n /= 3, b++; //计算质因子 3 的个数 if (n != 1) printf(\"-1\\n\"); //如果质因子有其他 else if (a \u003e b) printf(\"-1\\n\"); //如果 2 个数比三多，则无法得到 1 else printf(\"%d\\n\", (b - a) * 2 + a); } // #define LOCAL int main() { std::ios::sync_with_stdio(false); #ifdef LOCAL freopen(\"test.in\", \"r\", stdin); freopen(\"test.out\", \"w\", stdout); #endif int T; scanf(\"%d\", \u0026T); while (T--) solve(); return 0; } ","date":"2020-07-06","objectID":"/2020/07/653div3problemb/:2:0","tags":["思维","数学","题解","模拟"],"title":"B. Multiply by 2, divide by 6题解","uri":"/2020/07/653div3problemb/"},{"categories":["cf补题"],"content":"反思 第一次没做出来是使用了模拟的暴力解法，理论上是过了，第一次提交过了，重判之后又错在了第11个test，后来看了才发现是爆int了一定是因为我第一次打cf比赛的原因 看到int范围就要优先考虑使用long long不然这题我也不会错 最知道思考的是本文的解法，思维题嘛，锻炼自己思维，毕竟不是每道思维题都可以直接模拟 ","date":"2020-07-06","objectID":"/2020/07/653div3problemb/:3:0","tags":["思维","数学","题解","模拟"],"title":"B. Multiply by 2, divide by 6题解","uri":"/2020/07/653div3problemb/"},{"categories":["cf补题"],"content":"总结 遇到这种题尝试思考因子的问题 在草稿纸上找找规律，毕竟cf就喜欢考这些思维题 ","date":"2020-07-06","objectID":"/2020/07/653div3problemb/:4:0","tags":["思维","数学","题解","模拟"],"title":"B. Multiply by 2, divide by 6题解","uri":"/2020/07/653div3problemb/"},{"categories":["成长心得"],"content":"1、写在前面 这几天疯狂刷leetcode的dp题，刷到我都想吐了，看到一个题就先往dp想，感觉中毒不浅，话不多说，赶紧开始总结一下我的成长历程心得。 ","date":"2020-06-27","objectID":"/2020/06/dynamicprogramming/:1:0","tags":["动态规划"],"title":"动态规划刷题总结","uri":"/2020/06/dynamicprogramming/"},{"categories":["成长心得"],"content":"2、我对dp的看法和理解 首先引入《算法笔记》里的一句话: 动态规划是一种非常精妙的算法思想，他没有固定的写法、极其灵活，常常需要具体问题具体分析。 没错正式这种具体问题具体分析的设定让我刷到吐了 平时在思考动态规划的往往是利用一个小小的公式：递推 = 递归 + 记忆化（下面会赘述我是怎么利用这个公式思考的） 虽然他是这么说，但是我还是觉得dp的是有套路可循的，例如给dp分类 （背包dp、树形dp、区间dp……），经典题的记忆 （爬楼梯、树塔问题、LIS……） 一般来说，我思考dp都是从结果往前想的（即从末尾开始想） dp的基本使用条件： 1. 拥有重叠子问题、 2. 最优子结构、3.无后效性 dp思考三步走： 1. 状态定义 → 2.列状态转移方程 → 3.验证方程 我觉得的动规成长路线：小白 → 利用小公式辅助建立dp → 正常dp三步走思维思考 → 大佬 （我还没触及 将来一定达到( ఠൠఠ )ﾉ） ","date":"2020-06-27","objectID":"/2020/06/dynamicprogramming/:2:0","tags":["动态规划"],"title":"动态规划刷题总结","uri":"/2020/06/dynamicprogramming/"},{"categories":["成长心得"],"content":"3、典型例题 ","date":"2020-06-27","objectID":"/2020/06/dynamicprogramming/:3:0","tags":["动态规划"],"title":"动态规划刷题总结","uri":"/2020/06/dynamicprogramming/"},{"categories":["成长心得"],"content":"①爬楼梯（leetcode #70） 题意 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1、 1 阶 + 1 阶 2、 2 阶 示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1、 1 阶 + 1 阶 + 1 阶 2、 1 阶 + 2 阶 3、 2 阶 + 1 阶 分析 （抛开动规，假设我们是小白）我的思考过程，利用上述提到的小小公式（递推 = 递归 + 记忆化 首先：从末尾结果开始想，如果我们要走到最后一个台阶,那么我们就有两种走到这个台阶的方法：一是从这一个台阶的前一个台阶上来、二是从这个台阶的前第二个台阶上来。如图： 这样我们就很容易想到到达最后一个台阶的方法数为到前一个台阶的方法数加上到前第二个台阶的方法数，可能很拗口。看下面的公式就懂了。 设 dp(n) 为到台阶n的总方法数，这样很容易就能写出这个方法数的公式为： $$ dp(n) = dp(n - 1) + dp(n - 2) $$ 不难写出递归代码 int dp(int n){ if(n == 1 || n == 0) return 1; return dp(n - 1) + dp(n - 2); } 仔细分析一下这个代码，时间复杂度不难发现式O(2^n)，例如假设我们求的是dp(5) 不难发现有很多重复计算(黄色部分)，这里采取了一个比较好的优化方法–记忆化递归（是不是觉得很接近那个小公式了？别急看代码） const int Max = 50; int memor[Max] = {0}; int dp(int n) { if (n == 1 || n == 0) return 1; if (memor[n] != 0) return memor[n]; memor[n] = dp(n - 1) + dp(n - 2); return memor[n]; } 时间复杂度降到了O(n),就是变成这样 两者时间对比： 普通递归计算dp(45) : 3464 ms 记忆化递归计算dp(45) : 1 ms 天壤之别！！！ 回过头来看这题，这题是一个典型的动规问题，那么我是怎么利用那个小公式来思考这个题的状态方程的呢，很简单就是按照刚刚的思路走一遍。 不难发现我们按照那个思路走，其实已经写出了转移状态方程，就是下面这个，并且这个方程的含义就是我们递归时的含义，这就相当于一下完成了dp三步走的前两步。 $$ dp(n) = dp(n - 1) + dp(n - 2) $$ 接下来的一步就是检查（验证）方程，首先我们要思考这道题适不适合用动规的方法来写，这就需要我们验证这个题是否满足1.有重叠子问题，2.有最优子结构。重叠子问题的话，刚刚分析递归的时候已经发现了，并且优化后不会出现重复计算子问题；最优子结构就是分析没有个状态（即dp(n)）是否是最优的解，在一开始分析题目时不难发现每一个台阶的步数只取决于他前两个台阶的步数。 验证方程的最后一步，设定状态边界（我们总不可能让他一直计算下去吧），其实这道题的边界就是我们一开始的递归边界。 到了这里dp的代码就不难了,递归式自顶向下地计算，而我们动规就是自顶向下地思考，自底向上地计算，多说无益，上代码 const int Max = 50; int dp[Max], n; int main() { scanf(\"%d\", \u0026n); dp[0] = 1, dp[1] = 1; for (int i = 2; i \u003c= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } printf(\"%d\", dp[n]); return 0; } 时间复杂度同样是O(n),虽然还有更快O(logn)的方式解这题，但我们现在是小白呀，下次再聊。 小结 通过这道题我们从小白晋级到了会用小公式来思考dp。 1、首先从末尾结果开始思考 2、思考怎么递归 3、再来就是写出递归的的方程 4、分析递归，去除重叠问题 5、转换成dp思想，直接走dp三步走的第三步，检查是否状态方程，若不满足，回到1看看有没有另一种更好的办法（一般不会出现这种情况),当然还有另一种方法就是在原有的基础上再次优化（这些都是后话）；若满足直接dp走你。 写不动了未完待续…… ","date":"2020-06-27","objectID":"/2020/06/dynamicprogramming/:3:1","tags":["动态规划"],"title":"动态规划刷题总结","uri":"/2020/06/dynamicprogramming/"}]