# 寒假cf刷题


# 寒假cf刷题

## cf478B Random Teams(*1300)

- 求参赛员的朋友数
- 贪心就好，最少的情况就是均分，最多的情况就是其余m-1队都只有1人的情况
- **总结**：找找规律，大胆猜测：最大和最小一定是两个极端。做的时候读不懂题目，后来靠样例猜出的题目的意思。

## cf1463B Find The Array(*1400)

- 给定一个长度为n的数组a，总和为s，求一个同长的数组b，使其和给定的数组每个对应的数的绝对值即$a_i - b_i$的二倍小于等于s，并且对于每一对相邻的数$b_i$和$b_{i+1}$要么$b_i \% b_{i+1} == 0$要么$b_{i+1} \% b_i == 0$
- 我的思路：不难发现目的就是为了使得$a_i - b_i$尽可能的小，那就很容易想到可以使其直接为0，然后又要满足相邻的可以被除的条件，则可是在奇数（或者偶数）下标取$a_i$，在偶数（或者奇数）下标取1，这样的话只需要求出给定数组的奇数下标的和与偶数下标的和，对比大小来决定到底是奇数放1还是偶数放1了
- 大佬的思路：对于b数组让每个数都是2的k次幂即$2^k,k\ge0$，并且保证$2^k \le a_i$
- **总结**：回归本质，思考题目设置的限制条件的意义，从那里出发思考，同时可以自己举例子

## cf1453B Suffix Operations(*1400)

- 给一个数组，有操作：选取一个下标i，将i（包括i）之后的所有数加一或者减一，你有一次可以把任何数变换的机会，问你将所有数变成一样的最小操作数（不包括变换的那个操作）
- 去除那个变换的机会，（大胆猜测）不难发现如果要将所有数变成一样的，所需要的操作顺序是任意的，其最小的操作次数就是相邻两个数的差值的绝对值之和。对于那个把任意数变换的一次机会我们可以将一个数变成其前面的数或者后面的数以减小差值绝对值。做法求一下差值的绝对值的和，之后再暴力遍历每一个数，要么变成前面的数，要么变成后面的数，最后取一个最小值就行了
- **总结**：将问题分解一步一步地找到解决问题的方法，还可以大胆猜想出一个结论出来，证明无误后，利用这个结论来解题

## cf1408B Arrays Sum(*1400)

- 给一个单调不减且数组a，求一个数组组，数组组中的每个数组的也要是单调不减且不同数的个数不超过k，并且数组的下标i的总和正好为$a_i$，输出最小的数组组的大小，无解输出-1
- 纸上模拟，反向推演找数组组，不难发现若要个数不超过k，除了第一次，之后的每次最多能使k - 1个数变为0，而第一次能使k个数变为0（包括本来的0）。所以最终得到的公式就是$k + (k - 1) * num \ge dif$，其中dif为a数组不同数的个数，num为答案。不难发现若$dif > k$则无解
- **总结**：想清楚题目要我干嘛，寻找规律，大胆猜想，纸上推演，理清思路，排除不必要的干扰，防止思维混乱。

## cf1393B Applejack and Storages(*1400)

- 起初你有n根木棍，有q询问，每次询问都添加一根或者去除一根，同时你要回答每次添加或者去除后能否组成一个正方形和一个长方形（正方形也是长方形）
- 正难则反，不难发现要一个正方形必须要4根同长的木棍，一个长方形要1对2根同长的木棍;我的做法：用三个set分别存放个数为1，个数为2和3的，个数为不低于4的，剩下的就是模拟了。大佬的做法：用两个变量记录个数是2的倍数的two，和个数为4的倍数的four，无论是询问还是原本有的木棍，假设成一根一根添加，一旦添加到为2的倍数则two自增，一旦添加到为4的倍数则four自增，最终答案就是$four \ge 2$或者$four \ge 1 \&\& two \ge 3$就能达到目的
- **总结**：我的思路是比较贴近现实生活中遇到此问题时我们会怎么解决来思考的，大佬的做法是在此基础上加上更加妙的实现做法

## cf1365C Rotation Matching(*1400)

- 给你两个长度相等为n的排列数组a和b，问题经过平移后最多有多少个相等的数下标能对应上
- 仔细思考不难发现：假设平移b数组，并且只能向一个方向平移，若$a_i$和$b_j$相等，要使其位置对应，则平移的位置就是$(i - j + n) \% n$，最终就是求相同平移量的个数最大值
- **总结**：从本质出发，不用考虑太多算法，就是纯思维

## cf1144D Equalize Them All(*1400)

- 给你一个数组，你能选择相邻的两个数$a_i$和$a_{i+1}$进行操作:$a_i = a_i + |a_i - a_{i+1}|$或者$a_i = a_i - |a_i - a_{i+1}|$，问你最小的操作数使得数组所有数都相等，输出方案
- 贪心就好，首先纸上推演，题中给的操作能够实现将一个数变成另一个数，然后就是大胆贪心，最小的操作次数一定是数组中所有的数最终变成原本数组的众数，利用发现的规律来使得所有数都变成那个数便可以了
- **总结**：大胆猜想，然后验证，目前主要障碍就是读题，还有码代码时候优先选择思路清晰的码代码方式，基本内存可能很大，wa了之后人肉跑一遍代码检查，还是查不出就举反例

## cf1355D Game With Array(*1400)

- 请你求一个长度为n的数组，其总和为s，输出一个k，使得你求的数组没有一个子数组的总和为k，若无解输出NO，否则输出YES和数组和k
- 仔细思考一下，贪心，最极端的就是n-1个1，设剩下一个就是x = s - (n - 1)，不难啊发现x到s范围的都可以组合出来，若$n - 1 \ge x - 1$，则说明1到n-1都能组合出来，即无解，否则有解
- 大佬思路：让所有数都大于等于2，最后k = 1，便可。至于无解情况就是$s < n * 2$
- **总结**：大胆猜想，贪心，从极端情况考虑

## cf1348B Phoenix and Beauty(*1400)

- 给你一个长度为n的数组a，求一个数组b，数组a是数组b的子序列，数组b的所有长度为k的连续子序列的和总是一样，有解输出数组b，无解输出-1
- 不难发现，要让b数组的长度为k的连续子数组和总是相等，其实只要让其一直循环长度为k的数组就好了，对于数组a是数组b的子序列也不难处理，显然若要有解就是a数组中的不同个数不得超过k
- **总结**：这题不是很难，但是要注意细节，有些时候检查代码人肉跑一次是非常必要的，在一定不会超时的前提下怎么方便怎么来，stl放心用

## cf1316B String Modification(*1400)

- 给你一个字符串，你可以操作：从左到右遍历，每k个就进行翻转。让你计算一个最小的k，操作后字典序最小
- 观察不难这样的操作，其实就是把从下标为k - 1开始到最后的子串平移到最前面，然后就是将0到k-2下标的补到后面，若k-1之后的个数为奇数，则需要将0到k-2的子串进行翻转再补到后面
- **总结**：这题不难，但是字符串的处理有点麻烦，同上题一样，不超时放心用stl的东西

## cf1270C Make Good(*1400)

- 给你一个数组a，让你添加不超过3个数，使得$a_1 + a_2 ... a_n = 2\times(a_1 \bigoplus a_2 ... \bigoplus a_n)$
- 纸上推演，利用异或的特性可以推出第一次异或本来的异或和使等式右边为0，再来就是异或左边加上刚刚的异或值的和，便是答案，可见这个方法只要加两个数便可以了
- **总结**：本题不难，思考问题从位运算的特性中思考，还有就是注意此题会爆int

## cf1266C Diverse Matrix

- 你需要求出以个$r\times c$的矩阵，并且对于矩阵的每一行每一列的最大公因数都不一样，让你求最小化这个矩阵中行列的最大公因数的矩阵
- 此题有点偏数学，在纸上推理，不难发现：最小的最大公因数一定是r + c，然后就是反向推演，不难发现对列和行从1到r+c编号，然后对于矩阵上的一个数要满足题意只需要求出对应编号的最小公倍数即可，但需要注意的是编号优先从行数和列数中小的开始，例如行数比列数少，则编号需要从行开始
- **总结**：纸上推演，大胆猜想，然后简单验证和人肉debug

